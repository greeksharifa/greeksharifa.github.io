<!DOCTYPE html>
<html lang="en-us">
<head>
  <head>
  <!-- Description of Blog -->
  <meta name="description" content="Python, Machine & Deep Learning">
  <link rel="canonical" href="https://greeksharifa.github.io/">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Python, Machine & Deep Learning">
  <meta property="og:description" content="Python, Machine Learning & Deep Learning 설명서">
  <meta property="og:image" content="https://greeksharifa.github.io/public/img/icon-144x144.png">
  <meta property="og:url" content="https://greeksharifa.github.io/">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Python, Machine & Deep Learning">
  <meta name="twitter:description" content="Python, Machine Learning & Deep Learning 설명서">
  <meta name="twitter:image" content="https://greeksharifa.github.io/public/img/icon-144x144.png">
  <meta name="twitter:domain" content="https://greeksharifa.github.io/">

  <!-- link -->
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/main.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="icon-144x144" sizes="144x144" href="/public/img/icon-144x144.png">
  <link rel="shortcut icon" href="/public/img/icon_32x32.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"> </script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });
  </script>
  

  <!-- Ads -->
  <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
  </script>
</head>

  <!-- for Google AdSense-->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-9951774327887666",
    enable_page_level_ads: true
  });
</script>

  <style>blockquote {
    font-size: 1em;
    line-height: 1.4
  }</style>
  <link href='http://fonts.googleapis.com/css?family=Gill+Sans' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Consolas' rel='stylesheet' type='text/css'>
</head>
<body>

<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <div class="sidebar-personal-info">
      <div class="sidebar-personal-info-section">
        <a href="http://gravatar.com/3c2986ad7ac1f2230ea3596f44563328">
          <img src="/public/img/maple_tree.jpg" title="Cover Photo" alt="Maple tree" />
        </a>
      </div>
      <div class="sidebar-personal-info-section">
        <p><strong>Developer and Analyst</strong>, YW & YY.</p>
      </div>
      
      
      
      <div class="sidebar-personal-info-section">
        <p> Follow me:
        
        
        
        <a href="https://github.com/greeksharifa">
          <i class="fa fa-github" aria-hidden="true"></i>
        </a>
        
        |
        
        
        
        <a href="mailto:greeksharifa@gmail.com">
          <i class="fa fa-envelope" aria-hidden="true"></i>
        </a>
        
        
        
        </p>
      </div>
      
    </div>
  </div>

  <nav class="sidebar-nav">
    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/">
          Home
        </a>

        
      </span>

    
      
      
      

      

      <span class="foldable">
        <a class="sidebar-nav-item " href="/blog/">
          Blog
        </a>

        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/categories/">
                Categories
              </a>
          
        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/tags/">
                Tags
              </a>
          
        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/about/">
          About
        </a>

        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="http://greeksharifa.github.io/">
          Github Project
        </a>

        
      </span>

    

  </nav>

  <div class="sidebar-item">
    <p>
    &copy; 2020 YW & YY. This work is liscensed under <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a>.
    </p>
  </div>

  <div class="sidebar-item">
    <p>
    Powered by <a href="http://jekyllrb.com">jekyll</a> and <a href="http://greeksharifa.github.io">YW & YY</a>
    </p>
  </div>
</div>


<!-- Wrap is the content to shift when toggling the sidebar. We wrap the
     content to avoid any CSS collisions with our real content. -->
<div class="wrap">
  <div class="masthead">
    <div class="container">
      <h3 class="masthead-title" align="center">
        <a href="/" title="Home" title="YW & YY">
          <img class="masthead-logo" src="/public/img/logo.png"/>
        </a>
        <small>YW & YY's Python, Machine & Deep Learning</small>
        <!-- HTML elements for search -->
        <a href="/search/" id="search_icon">
          <img src="/public/img/search.png" width="25" height="25"
               align="right" style="margin-top:5px; margin-bottom:0;"
               onmouseover="this.style.opacity=0.7" onmouseout="this.style.opacity=0.5"
               alt="search">
        </a>
      </h3>
    </div>
  </div>

  <div class="container content">
    <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/BERT-Pre-training-of-Deep-Bidirectional-Transformers-for-Language-Understanding/">
        BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding
      </a>
    </h1>

    <span class="post-date">23 Aug 2019</span>
     |
    
    <a href="/blog/tags/#paper-review" class="post-tag">Paper_Review</a>
    
    <a href="/blog/tags/#nlp" class="post-tag">NLP</a>
    
    

    <article>
      <hr />

<p>이 글에서는 2018년 10월 <em>Jacob Devlin</em> 등이 발표한 BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding를 살펴보도록 한다.</p>

<p>어쩐지 <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/20/ELMo-Deep-contextualized-word-representations/">ELMo</a>를 매우 의식한 듯한 모델명이다.</p>

<p>코드와 사전학습(기학습)된 모델은 <a href="https://github.com/google-research/bert">여기</a>에서 볼 수 있다.</p>

<p>중요한 부분만 적을 예정이므로 전체가 궁금하면 원 논문을 찾아 읽어보면 된다.</p>

<hr />

<h1 id="bert-pre-training-of-deep-bidirectional-transformers-for-language-understanding">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</h1>

<p>논문 링크: <strong><a href="https://arxiv.org/abs/1810.04805">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a></strong></p>

<p>Pytorch code: <strong><a href="https://github.com/dhlee347/pytorchic-bert">Github: dhlee347</a></strong></p>

<h2 id="초록abstract">초록(Abstract)</h2>

<p>이 논문에서는 새로운 언어표현모델(language representation model)인 <strong>BERT</strong>(<strong>B</strong>idirectional <strong>E</strong>ncoder <strong>R</strong>epresentations from <strong>T</strong>ransformers)를 소개한다. 최근의 언어표현모델과는 다르게 BERT는 모든 layer의 좌우 문맥 모두에서 깊은 양방향 표현(deep bidirectional representations)를 사전학습(pre-train)하도록 설계되었다. 결과적으로 사전학습된 BERT는 QA나 언어추론 등 대부분의 과제(task)에서, 해당 과제에 특화된 모듈을 추가하지 않고 딱 하나의 추가 출력 layer만 붙여도 state-of-the-art 결과를 얻을 수 있었다.</p>

<p>BERT는 개념적으로 간단하고 경험적으로 강력하다. GLUE benchmark에서 7.7% 상승한 80.5%, MultiNLI에서 4.6$ 상승한 86.7%, SQuAD v1.1에서 1.5 상승한 93.2(F1 score), SQuAD v2.0에서 5.1 상승한 83.1 F1 score를 기록하였다.</p>

<hr />

<h2 id="1-서론introduction">1. 서론(Introduction)</h2>

<p>언어모델 사전학습은 자연어처리 과제들에서 효과적이다. 사전학습된 언어표현을 downstream task에 적용하는 데는 두 가지 전략이 있는데</p>

<ol>
  <li>사전학습된 표현을 특정과제에 특화된(task-specific) 모델구조에 추가하는 특성기반 접근법(feature-based approach), 예로 <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/20/ELMo-Deep-contextualized-word-representations/">ELMo</a>가 있다.</li>
  <li>특정과제에 특화된 parameter를 최소로 추가하여, 간단히 사전학습된 <em>모든</em> parameter를 세부조정(fine-tune)함으로써 downstream task에서 학습하는 방법, 예로 <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/21/OpenAI-GPT-1-Improving-Language-Understanding-by-Generative-Pre-Training/">Generative Pre-trained Transformer(OpenAI GPT)</a>가 있다.</li>
</ol>

<p>이 두 접근법은 범용언어표현을 학습하기 위해 단방향 언어모델을 사용하기 때문에 사전학습기간 동안 같은 목적함수를 공유한다.<br />
그러나 이러한 방법은, 특히 fine-tuning 접근법은 사전학습된 표현의 능력을 제한시킨다. 가장 큰 한계는 표준언어모델은 단방향이며 이것이 사전학습하는 동안 모델구조의 선택권을 제한한다. 예로 <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/21/OpenAI-GPT-1-Improving-Language-Understanding-by-Generative-Pre-Training/">OpenAI GPT</a>의 경우, 좌$\rightarrow$우 구조를 사용하였는데 이는 Transformer의 self-attention layer에서 모든 token이 이전 token에만 의존하게 만든다.</p>

<p>이 논문에서는 fine-tuning을 기반으로 한 BERT라는 접근법을 제안한다. 이 모델은 <strong>MLM</strong>(Masked Language Model) 사전학습을 사용하여 단방향성을 제거하였다. 이는</p>

<ul>
  <li>입력의 일부 token을 무작위로 <code class="highlighter-rouge">[mask]</code> token으로 치환하고, 목적은 주변 문맥으로부터 마스크 처리된 단어를 유추하는 것이다.</li>
  <li>좌$\rightarrow$우 사전학습 언어모델과는 다르게 MLM objective는 좌/우 문맥을 결합하여 깊은 양방향(deep bidirectional) Transformer을 미리 학습시킬 수 있게 한다.</li>
  <li>추가로 <strong>NSP</strong>(Next Sentence Prediction) 과제를 사용하여 문자-쌍 표현을 미리 결합학습(jointly pre-train)할 수 있게 하였다.</li>
</ul>

<p>그래서 이 논문의 기여한 바는</p>

<ul>
  <li>언어표현을 위한 양방향 사전학습의 중요성을 보여주었다. 즉 deep bidirectional representation을 사전학습할 수 있다.</li>
  <li>사전학습된 표현은 특정과제에 특화된 구조를 만들기 위해 조정을 계속할 필요를 줄여준다는 것을 보였다.</li>
  <li>11개의 NLP 과제에서 state-of-the-art 결과를 얻어내었다.</li>
</ul>

<hr />

<h2 id="2-관련-연구related-work">2. 관련 연구(Related work)</h2>

<p>범용언어표현의 사전학습 연구는 긴 역사가 있다. 간단히 살펴보자.</p>

<h3 id="21-unsupervised-feature-based-approaches">2.1. Unsupervised Feature-based Approaches</h3>

<p>넓은 범위에서 사용가능한 단어의 표현을 학습시키는 것은 비신경망 모델과 신경망 모델 모두에서 많은 연구가 이러우졌다. 현대 NLP 체계에서 사전학습된 단어 embedding은 굉장한 성과를 거두었는데, 이 벡터를 학습시키기 위해서 좌$\rightarrow$우 언어모델 objective 또는 좌우 문맥으로부터 정확/부정확한 단어를 가려내는 방법 등이 사용되었다.<br />
이러한 접근법은 문장/문단 embedding과 갈은 더 세부적인 부분으로 일반화되었다. 문장표현을 학습하기 위해서 다음 후보문장의 순위를 매기거나, 이전문장의 표현이 주어졌을 때 다음문장의 좌$\rightarrow$우 생성을 하거나, auto-encoder의 noise를 줄이는 방법 등이 사용되었다.</p>

<p>ELMo와 그 이전 모델들은 전통적인 단어 embedding을 다른 차원으로 일반화했다. 이들은 문맥에 민감한 특성들을 좌$\rightarrow$우 및 우$\rightarrow$좌 모델로부터 추출했다. 각 token의 문맥 표현은 좌$\rightarrow$우 및 우$\rightarrow$좌 표현의 결합으로 만들어진다.<br />
이외 여러 모델이 있으나 전부 특정기반이며 또한 깊은 양방향 학습이 이루어지지 못했다.</p>

<h3 id="22-unsupervised-fine-tuning-approaches">2.2. Unsupervised Fine-tuning Approaches</h3>

<p>이 방법은 미분류된(unlabeled) 문자로부터 사전학습된 단어 embedding을 얻는 것부터 시작한다.</p>

<p>더 최근에는, 문맥 token 표현을 생성하는 문장/문서 인코더가 미분류 문자로부터 사전학습되고 지도 downstream task에 맞춰 세부조정되었다. 이 접근법의 장점은 parameter의 수가 적다는 것이다.<br />
<a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/21/OpenAI-GPT-1-Improving-Language-Understanding-by-Generative-Pre-Training/">OpenAI GPT</a>는 GLUE benchmark에서 높은 성능을 기록핬다. 좌$\rightarrow$우 언어모델링과 auto-encoder objective가 이러한 모델에 사용되었다.</p>

<h3 id="23-transfer-learning-from-supervised-data">2.3. Transfer Learning from Supervised Data</h3>

<p>언어추론이나 기계번역 등의 분야에서 지도가 있는 task에서 큰 dataset으로 효과적인 전이학습을 하려는 연구가 있어왔다. Computer vision 연구는 또한 ImageNet 등 사전학습된 큰 모델로부터의 전이학습이 중요함을 보였다.</p>

<hr />

<h2 id="3-bert">3. BERT</h2>

<p>이 framework에는 크게 두 가지 단계가 있다: <em>pre-training</em>(사전학습)과 <em>fine-tuning</em>(세부조정)이다.<br />
<em>pre-training</em> 동안 모델은 다른 사전학습된 과제, 미분류된 데이터로 학습된다.<br />
<em>fine-tuning</em> 동안 BERT 모델은 사전학습된 parameter로 초기화된 후, 모든 parameter가 downstream task로부터 분류된 데이터를 사용하여 세부조정된다. 각 downstream task는 그들이 같은 사전학습된 parameter로 초기화되었다 하더라도 독립된 fine-tuned 모델이다. 다음 Figure 1에 나오는 QA 예제로 설명이 이어질 것이다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/01.png" width="100%" alt="Architecture" /></center>

<p>BERT의 다른 모델과 구분되는 특징은 여러 다른 과제에 대해서도 통합된 모델구조를 갖는다는 것이다. 사전학습된 모델구조와 최종 downstream 구조에는 최소한의 차이만 존재한다.</p>

<p><strong>Model Architecture</strong></p>

<p>BERT의 모델구조는 <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/17/Attention-Is-All-You-Need/">Attention Is All You Need</a>의 <strong>Transformer</strong>를 기반으로 한 multi-layer bidirectional Transformer encoder이다. Transformer를 썼기 때문에 특별할 것이 없으며 그 구현은 원본과 거의 같기 때문에 자세한 설명은 생략한다. <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/17/Attention-Is-All-You-Need/#3-%EB%AA%A8%EB%8D%B8-%EA%B5%AC%EC%84%B1model-architecture">여기</a>에서 인코더 부분을 살펴보자.</p>

<p>Layer의 수를 $L$, 은닉층의 크기를 $H$, self-attention head의 수를 $A$라 한다.<br />
BERT에는 두 가지 모델이 있는데</p>

<ul>
  <li>BERT_base: $L=12, H=768, A=12$. 전체 parameter 수: 110M</li>
  <li>BERT_large: $L=24, H=1024, A=16$. 전체 parameter 수: 340M</li>
</ul>

<p>BERT_base는 비교를 위해 <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/21/OpenAI-GPT-1-Improving-Language-Understanding-by-Generative-Pre-Training/">OpenAI GPT</a>와 같은 크기를 가지도록 만들었다. 그러나 BERT Transformer는 양뱡향 self-attention을 사용하고 GPT Transformer는 모든 token이 왼쪽 문맥만 참조하도록 제한된 self-attention을 사용한다.</p>

<p><strong>Input/Output Representations</strong></p>

<p>BERT가 다양한 downstream task를 처리할 수 있게 하기 위해, 입력표현은 단일 문장인지 문장들의 쌍(Q &amp; A 등)인지 구분되어야 한다. 여기서 “문장”이란 실제 언어학적 문장이 아닌 인접한 문자들의 연속으로 본다. “Sequence”가 BERT의 입력 token sequence가 되는데, 이는 단일 문장이나 문장의 쌍이 될 수 있다.</p>

<p>이 논문에서는 3만 개의 단어 수를 갖는 <a href="https://arxiv.org/abs/1609.08144">WordPiece</a> embedding을 사용한다. 모든 sequence의 첫 번째 token은 <code class="highlighter-rouge">[CLS]</code>라는 특별한 분류 token이다. 이 token과 연관된 최종 은닉상태는 분류문제에서 sequence 표현을 총합하는 것으로 사용된다. 문장의 쌍은 한 개의 문장으로 합쳐지는데 두 가지 방법으로 구분된다:</p>

<ol>
  <li><code class="highlighter-rouge">[SEP]</code>라는 특별한 token이 두 문장 사이에 들어간다.</li>
  <li>문장들의 모든 token에 해당 토큰이 문장 A에 속하는지 B에 속하는지에 대한 정보를 담은 embedding이 추가된다.</li>
</ol>

<p>위 그림에서처럼, 입력 embedding을 $E$라 하면, <code class="highlighter-rouge">[CLS]</code> token의 최종 은닉벡터 $C$와 $i$번째 입력 token에 대한 최종 은닉벡터 $T_i$는 $C \in \mathbb{R}^H, T_i \in \mathbb{R}^H$를 만족한다.</p>

<p>주어진 token에 대해 그 입력표현은 연관된 token, segment, position embedding의 합으로 구성된다. 이 구조는 Figure 2에서 볼 수 있다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/02.png" width="100%" alt="BERT input representation" /></center>

<h3 id="31-pre-training-bert">3.1. Pre-training BERT</h3>

<p>BERT를 사전학습시키기 위해 전통적인 좌$\rightarrow$우 또는 우$\rightarrow$좌 언어모델을 사용하지 않는다. 대신, 다음의 두 가지 비지도 task를 사용하여 학습시켜 놓는다.</p>

<p><strong>Task #1: Masked LM</strong></p>

<p>직관적으로, 깊은 양방향 모델은 좌$\rightarrow$우 모델 또는 얕은 양방향 모델보다 더 강력할 것이다. 그러나, 전통적인 언어모델은 단방향으로만 쉽게 학습가능한데, 양방향 조건은 각 단어가 간접적으로 ‘그 단어 자체’를 의미할 수 있으며, 모델은 자명하게 다층 문맥 안에서 목표 단어를 예측할 수 있기 때문이다.</p>

<p>양방향 모델을 학습시키기 위해 입력 token을 무작위로 masking한 다음, 문맥을 통해 해당 단어를 예측하게 한다. 문학에서 <em>Cloze</em> task라고도 하지만 이 과정을 MLM(masked LM)라 부르기로 한다.<br />
이 경우, mask token과 연관된 최종 은닉벡터는 표준 LM처럼 단어집합 내 출력 softmax로 넘어간다. Denoising auto-encoder과는 다르게 전체 입력이 아닌 masked word만을 예측한다.</p>

<p>이것이 양방향 사전학습 모델을 얻을 수 있도록 해주지만, <code class="highlighter-rouge">[mask]</code> token은 <em>fine-tuning</em> 단계에 나타나지 않기 때문에 <em>pre-training</em> 단계와 <em>fine-tuning</em> 단계 간 mismatch가 생긴다는 단점이 있다. 이를 완화하기 위해, 어떤 token을 항상 <code class="highlighter-rouge">[mask]</code> token으로 바꿔버리지 않는다. 구체적으로는,</p>

<ul>
  <li>학습데이터 생성자는, 전체 token 중 무작위로 15%를 선택한다.</li>
  <li>선정된 위치의 token은
    <ul>
      <li>80%의 확률로 <code class="highlighter-rouge">[mask]</code> token으로 치환되고,</li>
      <li>10%의 확률로 무작위 token으로 치환되고,</li>
      <li>10%의 확률로 그대로 남는다.</li>
    </ul>
  </li>
</ul>

<p>그러면 $T_i$는 cross entropy loss로 원본 token을 예측한다. 이 과정의 변형은 부록 C.2에서 다룬다.</p>

<p><strong>Task #2: Next Sentence Prediction(NSP)</strong></p>

<p>QA(Question Answering)나 NLI(Natural Language Inference) 등의 많은 중요한 문제는 언어모델에는 직접적으로 포착되지 않는 두 문장 사이의 <strong>관계</strong>(relationship)를 이해하는 것에 기반한다. 문장 간 관계를 모델이 학습하도록, 아무 단일 언어 말뭉치에서 생성될 수 있는 이진화된 다음 문장 예측(binarized <em>next sentence prediction</em>)을 사전학습시켰다.<br />
구체적으로, 학습 예제에서 문장 A와 B를 선택하는데,</p>

<ul>
  <li>학습 데이터의 50%는 A와 B가 이어지는 문장이고(<code class="highlighter-rouge">IsNext</code>로 분류됨)</li>
  <li>학습 데이터의 50%는 B는 A와는 아무 관련 없는 무작위로 선택된 문장(<code class="highlighter-rouge">NotNext</code>로 분류됨)이다.</li>
</ul>

<p>Figure 1에 나와 있듯이 $C$는 NSP(Next Sentence Prediction)을 위해 사용된다. 이렇게 간단함에도 이 task가 QA와 NLI에 굉장히 유용함을 Section 5.1에서 보일 것이다.<br />
이 NSP task는 표현 학습에 긴밀히 연관되어 있지만, 이전 연구에서는 오직 문장 embedding만 downstream task로 이전(transfer)이 됐는데, BERT는 end-task 모델 parameter를 초기화하기 위해 모든 parameter를 이전시킨다.</p>

<p><strong>Pre-training data</strong></p>

<p>사전학습 과정은 언어모델 사전학습에서 이미 있던 것을 거의 따라간다. 사전학습 말뭉치로 BooksCorpus(800M 단어)와 English Wikipedia(2,500M 단어)를 사용했다. 위키피디아에 대해서는 문자 정보만을 추출했다.<br />
긴 연속적 seqeunce를 추출하기 위해서는, 순서가 섞인 문장들의 집합인 Billion Word Benchmark같은 것보다는 문서단위 말뭉치를 쓰는 것이 매우 중요하다.</p>

<h3 id="32-fine-tuning-bert">3.2. Fine-tuning BERT</h3>

<p><em>Fine-tuning</em> 단계는 Transformer의 self-attention mechanism이 적절한 입력과 출력은 교환해냄으로써, BERT가 많은 downstream task이 문자 또는 문자 쌍을 포함함에도 이들을 모델링할 수 있게 해주기 때문에 간단하다.<br />
문자 쌍을 포함하는 문제에 대해 일반적인 패턴은 양방향 교차 attention을 적용하기 전 문자 쌍을 독립적으로 encoding하는 것이다.<br />
BERT는 이 두 단계를 통합하기 위해 self-attention mechanism을 사용했다. 이는 두 문장 간 <em>양방향</em> 교차 attention을 효과적으로 포함하는 self-attention으로 결합한 문자 쌍을 encoding하는 것으로 이루어진다.</p>

<p>각 task마다, task-specific한 입출력을 BERT에 연결하고 모든 parameter를 end-to-end로 세부조정(fine-tune)했다.</p>

<p>입력 단계에서, 사전학습에서 나온 문장 A와 문장 B는</p>

<ol>
  <li>‘의역에서의 문장 쌍(sentence pairs in paraphrasing)’이나</li>
  <li>‘함의에서 가장-전제 쌍(hypothesis-premise pairs in entailment)’이나</li>
  <li>‘질답에서 질문-지문 쌍(question-passage pairs in question answering)’이나</li>
  <li>‘문서분류나 sequence tagging에서의 퇴색된 문장-공집합 쌍(a degenerate text-∅ pair in text classification or sequence tagging)’</li>
</ol>

<p>과 유사하다.</p>

<p>출력 단계에서,</p>

<ol>
  <li>token 표현은, sequence tagging이나 QA처럼, token-level task을 위한 출력층으로 넘어가고,</li>
  <li><code class="highlighter-rouge">[CLS]</code> 표현은, 함의나 감정분석처럼, 분류를 위한 출력층으로 넘어간다.</li>
</ol>

<p><em>pre-training</em>과 비교하여, <em>fine-tuning</em>은 상대적이로 연산량이 적다. 이 논문의 모든 결과는 같은 사전학습된 모델로부터 시작했을 때 단일 Cloud TPU에서 최대 한 시간, GPU에서 몇 시간 정도 안에 재현될 수 있다.<br />
실험 결과는 Section 4에, 더 자세한 것은 부록 A.5를 보면 된다.</p>

<hr />

<h2 id="4-실험experiments">4. 실험(Experiments)</h2>

<h3 id="41-glue">4.1. GLUE</h3>

<p>GLUE benchmark는 다양한 자연어이해 문제들을 모아놓은 것이다.<br />
GLUE에 대해 세부조정하기 위해, 입력 sequence를 Section 3에서 언급한 대로 변환하고, 첫 번째 token(<code class="highlighter-rouge">[CLS]</code>)와 연관된 최종 은닉벡터 $C \in \mathbb{R}^H$를 총합 표현으로 사용한다. <em>fine-tuning</em> 단계에서 새로 도입하는 유일한 parameter는 분류 layer weights $W \in \mathbb{R}^{K \times H}$($K$는 분류의 수)이다. 이제 $C$와 $W$의 표준 분류 loss log(softmax($CW^T$))를 계산한다.<br />
모든 GLUE task에 대해 batch size 32, 3 epochs으로 실험한 결과는 다음과 같다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/03.png" width="100%" alt="GLUE Results" /></center>

<ul>
  <li>각 task마다 Dev set에서 최적의 learning rate를 선택했다.</li>
  <li>BERT_large는 작은 dataset에 대해 <em>fine-tuning</em> 학습이 불안정할 때가 있어서, 무작위 시작을 여러 번 하여 가장 좋은 것을 선택했다.</li>
</ul>

<p>BERT_base만으로도 state-of-the-art 결과를 얻었으며, BERT_large는 그보다도 더 뛰어난 성능을 보여준다.</p>

<h3 id="42-squad-v11">4.2. SQuAD v1.1</h3>

<p>Stanford Question Answering Dataset은 10만여 개의 질답 쌍으로 구성되어 있다. 질문과 그에 대한 답을 포함하는 위키피디아 지문이 주어지면, 해당 지문에서 답이 되는 부분을 찾는 과제이다.</p>

<p>Figure 1에서 보인 것과 같이, QA task에서는 입력 질문(A)과 지문(B)을 하나의 결합된 sequence로 둔다. <em>fine-tuning</em> 중에 새로 추가하는 것은 시작벡터 $S \in \mathbb{R}^H$와 종료벡터 $E \in \mathbb{R}^H$ 뿐이다. 답이 지문의 $i$번째 span(단어뭉치)의 시작이 될 확률은 지문에서 다음 식으로 계산된다:</p>

<script type="math/tex; mode=display">P_i = \frac{e^{S \cdot T_i}}{\sum_f e^{S \cdot T_i}}</script>

<p>유사한 식이 span의 끝에도 사용된다. 위치 $i \sim j$의 점수는 $S \cdot T_i + E \cdot T_j$로 정의되며, $j \ge i$이면서 최대 점수를 갖는 span이 예측 결과가 된다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/04.png" width="100%" alt="SQuAD Results" /></center>

<h3 id="43-squad-v20">4.3. SQuAD v2.0</h3>

<p>SQuAD v2.0은 (짧은) 답이 지문에 없는 경우를 포함시켜 더 확장한, 더 현실적인 task이다.</p>

<p>이를 위해 답이 없는 경우는 답이 되는 span의 시작과 끝이 <code class="highlighter-rouge">[CLS]</code>인 것으로 바꿔서 생각하는 것으로 해결한다. 이 때 점수는 다음과 같이 계산된다.</p>

<script type="math/tex; mode=display">s_{null}(\text{null span}) = S \cdot C + E \cdot C, \quad s_{\hat{i}, j}(\text{non-null span}) = \max_{j \ge i} S \cdot T_i + E \cdot T_j</script>

<p>F1을 최대화하기 위해, non-null span이 답이 되려면 한계점 $\tau$에 대해 $ s_{\hat{i}, j} &gt; s_{null} + \tau$이어야 한다.</p>

<h3 id="44-swag">4.4. SWAG</h3>

<p>Situations With Adversarial Generations dataset은 113k개의 배경상식을 평가하는 문장 쌍으로 되어 있다. 이어지는 문장으로 4개 중 가장 그럴듯하게 이어지는 문장을 고르는 과제이다.</p>

<p>여기서도 첫 번째 문장(A)과 나머지 4개 선택지(B)로 묶어 진행하였고, 추가되는 parameter는 벡터 하나뿐인데, 이 벡터와 <code class="highlighter-rouge">[CLS]</code> token 표현 $C$와의 내적이 softmax로 정규화된 각 선택지의 점수를 나타낸다.</p>

<p>batch size 16, learning rate 2e^-5, 3 epochs로 진행한 결과는 다음과 같다. 역시 성능이 상당히 좋다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/05.png" width="60%" alt="SWAG Results" /></center>

<hr />

<h2 id="5-ablation-studies">5. Ablation Studies</h2>

<p>이 섹션에서는 특정 부분을 빼거나 교체해서 해당 부분의 역할을 알아보는 ablation 분석을 수행한다. 한국어로 번역하기 참 어려운 단어이다.</p>

<p>추가 연구는 부록 C에서 찾아볼 수 있다.</p>

<h3 id="51-effect-of-pre-training-tasks">5.1. Effect of Pre-training Tasks</h3>

<p>다음 두 가지 경우와 BERT_base를 비교한다: (No NSP), (LTR &amp; No NSP).<br />
MLM 대신 좌$\rightarrow$우(left-to-right, LTR) LM을 사용한 것으로, 이러한 제약은 <em>pre-training</em>뿐 아니라 <em>fine-tuning</em>에도 적용되었는데 두 단계 사이의 mismatch를 피하기 위해서다. 이는 같은 dataset, 입력표현, fine-tuning scheme을 사용하여 <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/21/OpenAI-GPT-1-Improving-Language-Understanding-by-Generative-Pre-Training/">OpenAI GPT</a>와도 직접비교가 가능하다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/06.png" width="60%" alt="Effect of Pre-training Tasks" /></center>

<p>NSP를 제거했을 때에도, MLM을 LTR로 바꿨을 때에도 성능이 크게 하락함을 볼 수 있다.</p>

<p>직관적으로, SQuAD에서는 token-level 은닉상태가 오른쪽 문맥에 대한 정보가 없기 때문에 이러한 결과가 명백하다.</p>

<h3 id="52-effect-of-model-size">5.2. Effect of Model Size</h3>

<p>Layer 수, hidden units, attention head 등의 hyperparameter를 각각 바꿔보면서 최적의 모델을 찾아 보았다.</p>

<p>일반적으로 모델 크기가 커지면 성능도 향상되는데, 이 논문에서는 충분히 사전 학습되었다는 가정 하에 극단적으로 크기를 키우는 것 또한 아주 작은 규모의 과제에서도 큰 성능 향상이 있다는 것을 첫 번째로 보여주기도 했다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/07.png" width="60%" alt="Effect of Model Size" /></center>

<h3 id="53-feature-based-approach-with-bert">5.3. Feature-based Approach with BERT</h3>

<p>BERT의 모든 결과는 간단한 분류 layer만 사전학습된 모델에 추가하는 fine-tuning 접근법을 사용했고, 모든 parameter는 downstream task에서 결합학습되었다.<br />
그러나 이러한 특성기반 접근법에서, 고정된 특성이 사전학습된 모델로부터 추출될 때 특정 이점을 갖는다.</p>

<ol>
  <li>모든 task가 Transformer 인코더 구조로 쉽게 표현될 수 있는 것은 아니며, 따라서 특정과제에 특화된 모델구조가 추가될 필요가 있다.</li>
  <li>학습데이터에 대한 한 번의 ‘비싼’ 사전 계산에 대한 연산량 관점에서의 이득이 있고 이 표현 위에서 연산량이 적은 모델에 대한 많은 실험을 진행할 수 있다.</li>
</ol>

<p>BERT에 특성기반 접근법을 적용할 과제로는 CoNLL-2003 Named Entity Recognition(NER) task이 선정되었다. BERT에는 WordPiece 모델을 사용했고, 데이터에서 제공된 최대한의 문서 문맥을 포함시켰다.<br />
fine-tuning 접근법을 피하기 위해, BERT의 어떤 parameter에 대해서도 fine-tuning 없이 하여 하나 또는 더 많은 layer에 대해 활성값을 추출한 특성기반 접근법을 사용하였다. 이러한 문맥 embedding은 분류 layer에 들어가기 전 무작위 초기화된 768차원 2-layer BiLSTM의 입력으로 사용되었다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/08.png" width="60%" alt="Feature-based Approach with BERT" /></center>

<p>BERT_large는 거의 state-of-the-art 성능을 가지며, 이는 BERT가 세부조정과 특성기반 접근법 모두에서 효율적임을 보여준다.</p>

<hr />

<h2 id="6-결론conclusion">6. 결론(Conclusion)</h2>

<p>최근 경험적 향상은 언어모델에서의 전이학습, 비지도 사전학습 등에 의해 이루어졌다. 특히, 이러한 결과들은 자원이 적은 task에서도 깊은 양방향 구조에서 이점을 얻도록 하였다. 이 논문의 가장 큰 기여는 같은 사전학습된 모델을 넓은 범위의 NLP task에 적용시킬 수 있도록 하는 깊은 <em>양방향</em> 구조를 일반화한 것이다.</p>

<hr />

<h2 id="refenrences">Refenrences</h2>

<p>논문 참조. 레퍼런스가 많다.</p>

<hr />

<h2 id="appendix">Appendix</h2>

<h3 id="a-additional-details-for-bert">A. Additional Details for BERT</h3>

<p>부록 A.1은 MLM이 어떻게 masking을 하는지, NSP는 어떤지 예시와 함께 자세히 설명한다. 예시는 다음과 같다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/09.png" width="100%" alt="MLM &amp; NSP" /></center>

<p>부록 A.2와 A.3은 각각 <em>pre-training</em> 단계와 <em>fine-tuning</em> 단계를 부가 설명한다.</p>

<p>부록 A.4는 다른 모델과의 구조 차이를 설명한다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/10.png" width="100%" alt="BERT, OpenAI GPT, ELMo" /></center>

<p>부록 A.5는 다른 task에 fine-tuning을 적용하는 방법을 설명한다. 그림으로 설명한 것은 다음과 같다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/11.png" width="100%" alt="Fine tuning on different tasks" /></center>

<h3 id="b-detailed-experimental-setup">B. Detailed Experimental Setup</h3>

<p>부록 B.1은 GLUE benchmark에서 사용한 실험 세팅을 더 자세히 설명한다. 재현하고 싶다면 눈여겨보자.</p>

<h3 id="c-additional-ablation-studies">C. Additional Ablation Studies</h3>

<p>부록 C.1은 학습단계(Training Steps)의 수를 바꿔서 실험했다. 실험 결과는</p>

<ol>
  <li>BERT는 엄청난 사전학습을 필요로 한다(128k words/batch * 1M steps).</li>
  <li>MLM 사전학습은 LTR보다 더 느리게 수렴하지만(최대 15%만이 치환되므로), 최종 정확도는 더 높다.</li>
</ol>

<p>부록 C.2는 masking 과정을 변화시켰을 때의 실험이다.</p>

<center><img src="/public/img/2019-08-23-BERT - Pre-training of Deep Bidirectional Transformers for Language Understanding/12.png" width="100%" alt="Ablation Study for Masking" /></center>

<p>결국 처음 설명한 80%-10%-10% 비율이 가장 적절했다는 결론이다.</p>

<hr />


    </article>
    <div class="post-more">
      
      <a href="/BERT-Pre-training-of-Deep-Bidirectional-Transformers-for-Language-Understanding/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/BERT-Pre-training-of-Deep-Bidirectional-Transformers-for-Language-Understanding/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/OpenAI-GPT-1-Improving-Language-Understanding-by-Generative-Pre-Training/">
        OpenAI GPT-1 - Improving Language Understanding by Generative Pre-Training
      </a>
    </h1>

    <span class="post-date">21 Aug 2019</span>
     |
    
    <a href="/blog/tags/#paper-review" class="post-tag">Paper_Review</a>
    
    <a href="/blog/tags/#nlp" class="post-tag">NLP</a>
    
    

    <article>
      <hr />

<p>이 글에서는 2018년 6월 <em>Alec Radford</em> 등이 발표한 OpenAI GPT-1: Improving Language Understanding by Generative Pre-Training를 살펴보도록 한다.</p>

<p>코드와 논문은 <a href="https://openai.com/blog/language-unsupervised/">여기</a>에서 볼 수 있다.</p>

<p>중요한 부분만 적을 예정이므로 전체가 궁금하면 원 논문을 찾아 읽어보면 된다.</p>

<hr />

<h1 id="openai-gpt-1---improving-language-understanding-by-generative-pre-training">OpenAI GPT-1 - Improving Language Understanding by Generative Pre-Training</h1>

<p>논문 링크: <strong><a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">OpenAI GPT-1 - Improving Language Understanding by Generative Pre-Training</a></strong></p>

<p>홈페이지: <strong><a href="https://openai.com/blog/language-unsupervised/">OpenAI</a></strong></p>

<p>Tensorflow code: <strong><a href="https://github.com/openai/finetune-transformer-lm">Official Code</a></strong></p>

<h2 id="초록abstract">초록(Abstract)</h2>

<p>자연어이해는 원문함의, 질답, 의미 유사성 평가, 문서분류 등 넓은 범위의 과제로 이루어져 있다. 미분류 상태의 큰 말뭉치가 풍부함에도, 이러한 특정 과제의 학습을 위한 분류된 데이터는 부족하며, 모델이 적절히 수행하도록 만드는 것을 어렵게 한다.<br />
이 논문에서는 이러한 과제들에서의 큰 성능 향상은, 언어모델을 다양한 미분류 말뭉치로 생성적 사전학습(<em>generative pre-training</em>)을 시킨 후 각 특정 과제에 맞춘 세부조정(fine-tuning) 과정을 거쳐 가능하다. 이전의 접근법과는 달리 모델구조는 최소한으로 변화시키면서 효과적인 전이(transfer)를 얻기 위한 세부조정 단계에서 과제에 맞는 입력표현(input representations)을 사용했다. 그리고 이 접근법이 다양한 과제에 대해 효과적임을 보일 것이다.</p>

<p>이 논문에서 제시하는 과제에 대한 별다른 지식이 없는(task-agnostic) 모델은 특정과제에 특화된 구조를 사용하는 모델의 성능을 뛰어넘는데 연구된 12개의 과제 중 9개에서는 state-of-the-art를 달성하였다. 예를 들어 상식추론(<em>Cloze</em>)에서는 8.9%, QA에서는 5.7%, 원문함의에서는 1.5% 상승하였다.</p>

<hr />

<h2 id="1-서론introduction">1. 서론(Introduction)</h2>

<p>원본 그대로의 텍스트에서 효과적으로 학습하는 능력은 NLP에서 지도학습에 대한 의존성을 낮추는 데 있어 매우 중요하다. 대부분의 딥러닝 방법은 수동으로 분류된 방대한 양의 데이터를 필요로 하는데 이는 분류된 자원의 부족으로 인한 많은 범위로의 응용에 제약을 건다. 이러한 상황에서 미분류 데이터로부터 언어적 정보를 얻어낼 수 있는 모델은 힘들게 분류된 데이터를 만드는 것의 훌륭한 대안이 될 뿐만 아니라, 괜찮은 지도 방법이 있다 하더라도 비지도학습이 더 좋을 결과를 얻기도 한다. 사전학습된 단어 embedding이 그러한 예이다.</p>

<p>그러나 미분류 텍스트에서 단어 수준 정보 이상의 것을 얻는 것은 다음 두 가지 이유로 어렵다.</p>

<ol>
  <li>어떤 최적화 목적함수가 전이(transfer)에 유용한 텍스트 표현(representation)을 배우는 데 효과적인지 불분명하다. 최근 연구들은 언어모델링이나 기계번역, 담화 일관성(discourse coherence) 등 다양한 objective에서 각 방법이 다른 과제에서는 다른 방법을 능가하는 것을 보여 왔다.</li>
  <li>학습된 표현을 다른 과제로 전이하는 가장 효과적인 방법에 대한 일치된 의견이 없다. 존재하는 방법들은 복잡한 학습전략이나 부가 학습 목적함수를 더하는 등 모델 구성에 과제에 특화된(task-specific) 변화를 주어야 한다.</li>
</ol>

<p>이러한 불확실성은 언어처리에 대한 효과적인 준지도학습 접근법의 개발을 어렵게 한다.</p>

<p>이 논문에서는 비지도 사전학습(unsupervised pre-training)과 지도 세부조정(supervised fine-tuning)의 조합을 사용하여 언어이해 과제를 위한 준지도학습 접근법을 탐색한다. 목표는 약간의 조정만으로 넓은 범위의 과제에 전이 및 적용할 수 있는 범용 표현을 학습하는 것이다. 미분류 대량의 말뭉치와 수동으로 주석을 단(annotated) 학습예제를 갖는 여러 dataset에 대한 접근가능을 가정한다. 또한 학습은 두 단계를 거치게 된다.</p>

<ol>
  <li>신경망모델의 초기 parameter를 학습하기 위해 미분류 데이터에 대한 언어모델링 목적함수를 사용한다.</li>
  <li>이 parameter를 연관된 지도 목적함수를 사용하여 목표 과제에 적용시킨다.</li>
</ol>

<p>모델 구성은 기계번역, 문서생성, 구문분석 등에 상당한 성능을 보이는 <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/17/Attention-Is-All-You-Need/#3-%EB%AA%A8%EB%8D%B8-%EA%B5%AC%EC%84%B1model-architecture"><em>Transformer</em></a>를 사용한다. 이 모델은 RNN 등에 비해 장거리 의존성을 다루는 데 뛰어나 더 많은 구조화된 memory를 쓸 수 있게 한다. 전이 중에는 traversal-style 접근법에서 얻은 과제특화된 입력적응을 이용하며 입력은 한 개의, 일련의 ‘연속된 token’으로 주어진다. 이러한 적응방법은 사전학습된 모델의 구조를 바꾸는 것을 최소화한다.</p>

<p>이 접근법을 네 가지(자연어추론, 질답, 의미 유사성, 문서분류)에 대해 평가한다. 과제에 대한 지식이 없는 이 범용 모델은 12개 중 9개의 과제에서 state-of-the-art 결과를 보이며 선전했다.</p>

<hr />

<h2 id="2-관련-연구related-work">2. 관련 연구(Related work)</h2>

<p><strong>Semi-supervised learning for NLP</strong></p>

<p>이 연구는 자연어의 준지도학습에 넓게 걸쳐 있다. 이 체계는 sequence labeling이나 문서분류 등의 응용에 큰 관심을 불러일으켰다.</p>

<p>초기의 연구는 나중에 지도모델의 특징으로 사용될, 단어수준이나 구 수준의 통계를 계산하기 위해 미분류 데이터를 사용했다. 지난 몇 년간 연구자들은 미분류 말뭉치로부터 학습된 단어 embedding의 장점(다양한 과제에서의 성능 향상 가능성)을 발견했다. 그러나 이 접근법은 주로 단어 수준 표현을 학습할 뿐이다.</p>

<p>최근의 연구는 미분류 데이터로부터 단어수준 이상의 정보를 학습하려 하고 있다. 구 수준이나 문장 수준의 embedding은 미분류 데이터로부터 학습될 수 있으며 다양한 문제에서 텍스트를 적절한 벡터표현으로 변환할 수 있다.</p>

<p><strong>Unsupervised pre-training</strong></p>

<p>목표가 지도학습 목적함수를 수정하는 것이 아닌 좋은 초기화 지점을 찾는 것일 때, 비지도 사전학습은 준지도학습의 특별한 경우가 된다. 초기에는 이미지 분류나 회귀문제에 사용했다. 후속 연구는 사전학습이 정규화처럼 동작하며 DNN에서 더 좋은 일반화를 가능하게 함을 보였다. 최근에는 이미지분류, 음성인식, 다의어 명확화, 기계번역 등에 사용되고 있다.</p>

<p>GPT와 가장 유사한 연구는 신경망을 언어모델링 목적함수를 사용하여 사전학습시키고 지도 하에 목표 과제에 맞춰 세부조정하는 것을 포함한다. 그러나 어떤 언어적 정보를 포착하는 데 있어 LSTM의 사용은 이를 좁은 범위에 한정시킨다. 하지만 Transformer를 사용함으로써 넓은 범위에 걸친 언어적 구조와 정보를 학습할 수 있게 하였고 나아가 다양한 과제에 사용할 수 있게 되었다.<br />
다른 접근법은 목표 과제에 맞춘 감독학습 중에 사전학습된 언어/기계번역 모델에서 얻은 은닉표현을 부가정보르 사용하였는데 이는 상당한 양의 parameter를 추가하는데, GPT는 그렇지 않다.</p>

<p><strong>Auxiliary training objectives</strong></p>

<p>보조 학습 목적함수를 추가하는 것은 준지도학습의 대안이다. <a href="https://ronan.collobert.com/pub/matos/2008_nlp_icml.pdf">A unified architecture for natural language processing deep neural networks with multitask learning</a>이 여러 NLP task에 사용되었으며, 최근에는 <a href="https://arxiv.org/abs/1704.07156">Semi-supervised Multitask Learning for Sequence Labeling</a>이 목표 과제에 보조 언어모델링 목적함수를 추가해 sequence labeling task에서 성능향상을 얻었다. GPT도 보조목적함수를 추가하지만, 비지도 사전학습이 이미 목표 과제에 대한 여러 언어적 정보를 학습했다는 것을 보일 것이다.</p>

<hr />

<h2 id="3-framework">3. Framework</h2>

<p>학습은 두 단계로 진행된다.</p>

<ol>
  <li>큰 말뭉치에서 대용량의 언어모델을 학습한다.</li>
  <li>분류 데이터를 써서 특정 과제에 맞춰 모델을 세부조정한다.</li>
</ol>

<h3 id="31-unsupervised-pre-training">3.1. Unsupervised pre-training</h3>

<p>token의 비지도 말뭉치 $\mathcal{U} = {u_1, …, u_n}$이 주어질 때, 다음 우도를 최대화하도록 표준언어모델링 목적함수를 사용한다:</p>

<script type="math/tex; mode=display">L_1(\mathcal{U}) = \sum_i \log P(u_i \vert u_{i-k}, ..., u_{i-1}; \Theta)</script>

<p>$k$는 문맥고려범위(context window)이고 조건부확률 $P$는 parameter가 $\Theta$인 신경망을 사용하도록 설계된다. 이들은 확률적 경사하강법(SGD)에 의해 학습된다.</p>

<p>GPT는 언어모델로 Transformer의 변형인 multi-layer <em>Transformer decoder</em>를 사용한다. 이 모델은 입력 문맥 token에 multi-headed self-attention을 적용한 후, 목표 token에 대한 출력분포를 얻기 위해 position-wise feedforward layer를 적용한다:</p>

<script type="math/tex; mode=display">h_0 = UW_e + W_p \qquad \qquad \qquad \qquad \ \ \qquad</script>

<script type="math/tex; mode=display">h_l = \text{transformer_block}(h_{l-1}) \ \ \forall l \in [1, n]</script>

<script type="math/tex; mode=display">P(u) = \text{softmax}(h_n W_e^T) \qquad \qquad \qquad \quad \ \ \qquad</script>

<p>$U = (u_{-k}, …, u_{-1})$는 token의 문맥벡터, $n$은 layer의 수, $W_e$는 token embedding 행렬, $W_p$는 위치 embedding 행렬이다.</p>

<p>(참고: 논문에는 위 식에서 $\forall l$이 $\forall i$로 오타가 나 있다)</p>

<h3 id="32-supervised-fine-tuning">3.2. Supervised fine-tuning</h3>

<p>위 $L_1(\mathcal{U})$ 우도에 따라 모델을 학습시키고 나면, parameter를 목표 과제에 맞춰 세부조정한다. 분류된 dataset $\mathcal{C}$이 있고 각 구성요소가 일련의 입력 token $x^1, …, x^m$ 및 그 정답(label) $y$로 되어 있다고 하자. 입력은 최종 transformer block의 활성값 $h_l^m$을 얻기 위해 위의 사전학습된 모델에 전달하고 이 결과는 다시 $y$를 예측하기 위해 parameter $W_y$와 함께 선형 출력층으로 전달된다:</p>

<script type="math/tex; mode=display">P(y \vert x^1, ..., x^m) = \text{softmax}(h_l^m W_y)</script>

<p>이는 다음 우도를 최대화하도록 한다:</p>

<script type="math/tex; mode=display">L_2(\mathcal{C}) = \sum_{(x, y)} \log P(y \vert x^1, ..., x^m)</script>

<p>세부조정 단계에 언어모델을 보조 목적함수로 포함시키는 것은 다음 이유에서 학습을 돕는다.</p>

<ul>
  <li>지도 모델의 일반화를 향상시키고</li>
  <li>수렴을 가속화한다.</li>
</ul>

<p>이는 이전 연구들과 결을 같이한다.</p>

<p>구체적으로, weight $\lambda$에 대해 다음 목적함수를 최적화한다:</p>

<script type="math/tex; mode=display">L_3(\mathcal{C}) = L_2(\mathcal{C}) + \lambda \ast L_1(\mathcal{C})</script>

<p>종합적으로, 세부조정 단계에서 추가된 parameter는 $W_y$과 구분자 token을 위한 embedding 뿐이다.</p>

<h3 id="33-task-specific-input-transformations">3.3. Task-specific input transformations</h3>

<p>텍스트 분류와 같은 몇몀 과제에 대해서는 모델 세부조정을 위에서 언급한 방법으로 직접 할 수 있다. 그러나 질답과 원문함의와 같은 과제에서는 입력 형태가 문장의 2~3개 쌍인 등 많이 다르므로 이를 처리해주어야 한다. 그 방법은 아래 Figure 1에 나와 있는데, 질문/텍스트/선택지/가정/전제 등을 하나씩 따로 구분자(delimiter)로 구분하여 하나로 연결하는 방식을 쓴다. 구체적인 방법은 다음과 갈다.</p>

<p><strong>Textual entailment</strong></p>

<p>함의 문제에서는 전제 $p$와 가정 $h$를 구분자 <code class="highlighter-rouge">$</code>로 연결하였다.</p>

<p><strong>Similarity</strong></p>

<p>두 개의 텍스트 사이에 순서가 딱히 없으므로 텍스트 두 개를 다른 순서로 이어붙여 총 2개를 입력으로 쓴다. 이는 각각의 Transformer에 입력으로 들어간다.</p>

<p><strong>Question Answering and Commonsense Reasoning</strong></p>

<p>문맥 문서 $z$, 질문 $q$, 가능한 답변 ${a_k}$이라 하면, <code class="highlighter-rouge">[z; q; $; a_k]</code>로 연결하고 입력의 개수는 답변의 개수만큼 생성된다.</p>

<center><img src="/public/img/2019-08-21-OpenAI GPT-1 - Improving Language Understanding by Generative Pre-Training/01.png" width="100%" alt="Architecture" /></center>

<hr />

<h2 id="4-실험experiments">4. 실험(Experiments)</h2>

<h3 id="41-setup">4.1. Setup</h3>

<p><strong>Unsupervised pre-training</strong></p>

<p>언어모델을 학습하기 위한 dataset으로 7천 개의 다양한 분야의 미출판 책에 대한 내용을 포함하는 <a href="https://arxiv.org/abs/1506.06724">BooksCorpus</a>를 사용한다. 이는 특히 넓은 범위에 걸친 언어적 정보를 포함하기에 중요하다. 대안이 되는 dataset으로는 <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/20/ELMo-Deep-contextualized-word-representations/">ELMo</a>에서 사용된 1B Word Benchmark가 있다. 이는 크기는 비슷하지만 문장들이 서로 섞여 있어 장거리 의존정보가 파괴되어 있다.</p>

<p>사용하는 dataset 정보는 아래와 같다.</p>

<center><img src="/public/img/2019-08-21-OpenAI GPT-1 - Improving Language Understanding by Generative Pre-Training/02.png" width="100%" alt="List of dataset" /></center>

<p><strong>Model specifications</strong></p>

<p>Transformer의 세부 세팅을 대부분 따르지만, Encoder-Decoder 중 Decoder만 사용한다. 이 decoder는 <a href="https://greeksharifa.github.io/nlp(natural%20language%20processing)%20/%20rnns/2019/08/17/Attention-Is-All-You-Need/#31-encoder-and-decoder-stacks">원본</a>은 6번 반복되지만, GPT는 12번 반복한다.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Descrption</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>State dimension</td>
      <td>decoder: 768, inner state: 3072</td>
    </tr>
    <tr>
      <td>Batch size</td>
      <td>64 random sample $\times$ 512 token/sample</td>
    </tr>
    <tr>
      <td>Schedule</td>
      <td>100 epochs,</td>
    </tr>
    <tr>
      <td>Optimizer</td>
      <td>Adam</td>
    </tr>
    <tr>
      <td>Learning Rate</td>
      <td>0~2000 step까지 2.5e-4까지 증가, 이후 cosine 함수를 따라 0으로 서서히 감소</td>
    </tr>
    <tr>
      <td>warmup_steps</td>
      <td>4000</td>
    </tr>
    <tr>
      <td>Regularization</td>
      <td>L2($w=0.01$)</td>
    </tr>
    <tr>
      <td>Activation</td>
      <td>GELU(Gaussian Error Linear Unit)</td>
    </tr>
  </tbody>
</table>

<p>논문에는 안 나와있지만 모델의 크기는 parameter가 117M개이다.</p>

<p><strong>Fine-tuning details</strong></p>

<p>비지도 사전학습에서 사용한 hyperparameter를 그대로 사용했다. $p=0.1$의 dropout을 추가했다.<br />
learning rate는 6.25e-5와 batch size는 32, 세부조정은 3 epoch 동안 진행되었으며 learning rate decay는 warmup을 포함해 각 학습당 0.2%였고, $\lambda=0.5$이다.</p>

<h3 id="42-supervised-fine-tuning">4.2. Supervised fine-tuning</h3>

<p>자연어추론, 질답, 의미유사성, 문서분류에 대해 평가를 진행하였으며 이 중 일부는 GLUE benchmark에 포함되어 있다. 결과는 아래 Table 2, 3에 있다.</p>

<p><strong>Natural Language Inference</strong></p>

<p>Image caption(SNLI), 문서화된 음성, 대중소설, 정부 보고서(MNLI), 위키피디아 기사(QNLI), 과학시험(SciTail), 뉴스기사(RTE) 등의 다양한 데이터로 실험하였다. 각 0.6~5.8% 정도 성능이 향상되었다.</p>

<center><img src="/public/img/2019-08-21-OpenAI GPT-1 - Improving Language Understanding by Generative Pre-Training/03.png" width="100%" alt="Results" /></center>

<p><strong>Question answering and commonsense reasoning</strong></p>

<p>중고등학교 시험에서 나온 영어지문과 관련 질문으로 구성된 RACE dataset으로 진행하였다. 또 Story Cloze에 대해서도 진행했는데 이는 무려 8.9%까지 높은 성능을 내며 결과를 종합했을 때 GPT가 넓은 범위에 걸친 문맥 정보도 잘 포착해냄을 알 수 있다.</p>

<center><img src="/public/img/2019-08-21-OpenAI GPT-1 - Improving Language Understanding by Generative Pre-Training/04.png" width="100%" alt="Results" /></center>

<p><strong>Semantic Similarity</strong></p>

<p>QQP에 대해서는 BiLSTM + ELMo + Attention을 사용한 모델보다도 특히 성능이 향상되었다.</p>

<center><img src="/public/img/2019-08-21-OpenAI GPT-1 - Improving Language Understanding by Generative Pre-Training/05.png" width="100%" alt="Results" /></center>

<p><strong>Classification</strong></p>

<p>두 개의 다른 텍스트 분류 과제에 대해서도 평가를 진행했다. CoLA(The Corpus of Linguistic Acceptability)는 어떤 문장이 문법적으로 옳은지를 전문가가 평가한 답변과, 학습된 모델에 대한 언어적 편향에 대한 테스트를 포함한다.  SST-2(The Stanford Sentiment Treebank)는 표준 이진 분류 문제이다. CoLA에 대해서는 35.0 $\to$ 45.4점으로, SST-2에서는 68.9 $\to$ 72.8점으로 상승하였다.</p>

<p><strong>종합하면, 12개의 task 중 9개에서 state-of-the-art를 달성하였다.</strong></p>

<hr />

<h2 id="5-분석analysis">5. 분석(Analysis)</h2>

<p><strong>Impact of number of layers transferred</strong></p>

<p>아래 Figure 2의 왼쪽은 layer의 수를 다르게 하면서 RACE와 MultiNLI에 대해 실험을 진행한 것인데, transferring embedding이 성능 향상을 가져오며, 각 transformer layer 당 9%까지 향상시킨다(on MultiNLI)는 내용이다. 이는 사전학습된 모델의 각각의 layer가 문제를 푸는 데 있어 유용한 기능을 포함한다는 것을 의미한다.</p>

<center><img src="/public/img/2019-08-21-OpenAI GPT-1 - Improving Language Understanding by Generative Pre-Training/06.png" width="100%" alt="Impact of number of layers transferred" /></center>

<p><strong>Zero-shot Behaviors</strong></p>

<p>저자는 근본적인 generative model이 LM capability를 향상시키기 위해 많은 task를 수행하는 법을 배울 수 있고, LSTM과 비교해서 transformer의 attentional memory가 transfer에 도움이 된다고 가정하였다
Transformer를 통한 언어모델의 사전학습이 효과적인지에 대한 가정이 하나 있다. 기반 생성모델은 언어모델링 역량을 향상시키기 위해 평가에 포함된 여러 과제를 수행하는 것을 학습하였으며, Transformer의 attentional memory는 LSTM에 비해 전이를 더 원활하게 해 준다는 것이다. 지도 세부조정 없이 과제를 수행하기 위해 기반 생성모델을 사용하는 일련의 체험적 해결책(heuristic solutions)을 사용했다. 이 결과를 위 Figure 2의 오른쪽 부분에 시각화하였다.<br />
이 체험적 해결책의 성능은 안정적이며 학습에 따라 꾸준히 증가하는 것으로 보아 생성적 사전학습은 과제와 관련된 넓은 범위의 기능성(functionality)의 학습을 뒷받침한다. 또한 LSTM은 zero-shot 성능에서 큰 편차를 보여 Transformer 구조의 귀납적 편향이 전이를 돕는다고 할 수 있다.</p>

<p><strong>Ablation studies</strong></p>

<p>세 가지 분석을 수행하였다.</p>

<ol>
  <li>세부조정 단계에서 보조 LM 목적함수는 NLI task와 QQP에 도움을 주는데, 큰 dataset에서는 이점이 있지만 작은 dataset에서는 그렇지 못함을 보여준다.</li>
  <li>Transformer을 같은 구조의 2048 unit의 LSTM로 대체하였는데 5.6점의 점수 하락이 있었다. 성능이 좋은 경우는 MRPC 뿐이었다.</li>
  <li>Transformer를 사전학습 없이 바로 지도학습을 하도록 해보았는데, 14.8%의 성능 하락이 있었다.</li>
</ol>

<center><img src="/public/img/2019-08-21-OpenAI GPT-1 - Improving Language Understanding by Generative Pre-Training/07.png" width="100%" alt="Ablation studies" /></center>

<hr />

<h2 id="6-결론conclusion">6. 결론(Conclusion)</h2>

<p>생성적 사전학습과 특정과제에 특화된 세부조정을 통해 학습된, 과제에 대해 별다른 지식이 없으며 자연어이해 능력이 뛰어난 단일 모델(framework)를 소개하였다. 넓은 범위에 걸친 언어적 정보를 포함하는 다양한 말뭉치에 대해 사전학습을 진행하여 중요한 일반지식과 질답, 의미유사성 평가, 함의 확인, 문서분류 등의 과제에서 성공적으로 전이되는 장거리 의존성을 처리하는 능력을 학습하여 12개 중 9개의 과제에 대해 state-of-the-art를 달성하였다. 특정 과제에 대한 성능을 높이는 비지도 사전학습은 기계학습연구의 중요한 목표가 되었다.<br />
이 연구는 상당한 성능향상이 정말로 가능하며 어떤 모델(Transformers)과 dataset(장거리 의존성을 포함하는 텍스트)가 이 접근법에 가장 좋은지에 대한 조언을 제공한다. 이 연구가 자연어이해와 다른 분야에 대한 비지도학습에 대한 새로운 연구에 도움이 되기를 희망하며, 나아기 비지도학습이 언제 그리고 어떻게 작동하는지에 대한 우리의 이해를 증진시키기를 바란다.</p>

<hr />

<h2 id="refenrences">Refenrences</h2>

<p>논문 참조. 71개의 레퍼런스가 있다.</p>

<p>부록은 없다(yeah).</p>

<hr />


    </article>
    <div class="post-more">
      
      <a href="/OpenAI-GPT-1-Improving-Language-Understanding-by-Generative-Pre-Training/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/OpenAI-GPT-1-Improving-Language-Understanding-by-Generative-Pre-Training/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/ELMo-Deep-contextualized-word-representations/">
        ELMo - Deep contextualized word representations
      </a>
    </h1>

    <span class="post-date">20 Aug 2019</span>
     |
    
    <a href="/blog/tags/#paper-review" class="post-tag">Paper_Review</a>
    
    <a href="/blog/tags/#nlp" class="post-tag">NLP</a>
    
    

    <article>
      <hr />

<p>이 글에서는 2018년 2월 <em>Matthew E. Peters</em> 등이 발표한 Deep contextualized word representations를 살펴보도록 한다.</p>

<p>참고로 이 논문의 제목에는 ELMo라는 이름이 들어가 있지 않은데, 이 논문에서 제안하는 모델의 이름이 ELMo이다.<br />
Section 3에서 나오는 이 모델은 <strong>E</strong>mbeddings from <strong>L</strong>anguage <strong>Mo</strong>dels이다.</p>

<p>중요한 부분만 적을 예정이므로 전체가 궁금하면 원 논문을 찾아 읽어보면 된다.</p>

<hr />

<h1 id="elmo---deep-contextualized-word-representations">ELMo - Deep contextualized word representations</h1>

<p>논문 링크: <strong><a href="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">Deep contextualized word representations</a></strong></p>

<p>홈페이지: <strong><a href="https://openai.com/blog/language-unsupervised/">OpenAI Blog</a></strong></p>

<h2 id="초록abstract">초록(Abstract)</h2>

<p>이 논문에서는 단어 사용의 복잡한 특성(문법 및 의미)과 이들이 언어적 문맥에서 어떻게 사용되는지(다의성)를 모델링하는, 새로운 종류의 <strong><em>문맥과 깊게 연관된</em> 단어표현(<em>Deep contextualized</em> word representation)</strong>을 소개한다. 이 논문에서의 word vector는 큰 말뭉치에서 학습된 deep bidirectional language model(<strong>biLM</strong>)의 내부 상태로부터 학습한다. 이 표현(representation)은 이미 존재하는 모델에 쉽게 불일 수 있으며 이로써 QA 등 6개의 도전적인 NLP 문제에서 상당히 향상된 state-of-the-art 결과를 얻을 수 있음을 보였다. 또한 기학습된(pre-trained) 네트워크의 깊은 내부를 살펴보는 분석도 보인다.</p>

<hr />

<h2 id="1-서론introduction">1. 서론(Introduction)</h2>

<p><strong>기학습된 단어 표현(Pre-trained word representations)</strong>은 많은 자연어이해 모델에서 중요한 요소였다. 그러나 문법, 의미, 다의성을 학습한 높은 품질의 representation을 얻는 것은 어려운 일이다. 이 논문에서는 쉽게 다른 모델에 적용가능하며 성능도 뛰어난 <strong>Deep contextualized word representation</strong>을 소개한다.</p>

<p>이 representation은 (문장 내) 각 token이 전체 입력 sequence의 함수인 representation를 할당받는다는 점에서 전통적인 단어 embedding과 다르다. 이를 위해 이어붙여진 <strong>language model(LM)</strong>로 학습된 bidirectional LSTM(biLM)로부터 얻은 vector를 사용한다. 이 때문에 이를 <strong>ELMo(Embeddings from Language Models) representation</strong>이라 부른다. 이는 LSTM layer의 최종 layer만을 취한 것이 아닌, 각 layer 결과를 가중합하여 얻어지며 이것이 성능이 더 좋다.<br />
LSTM의 낮은 단계의 layer(입력과 가까운 층)는 품사 등 문법 정보를, 높은 단계의 layer(출력과 가까운 층)는 문맥 정보를 학습하는 경향이 있다.</p>

<p>많은 실험에서 ELMo representation이 매우 뛰어남을 보여 주었는데, 상대적으로 에러율을 20% 줄이기도 하였다.</p>

<hr />

<h2 id="2-관련-연구related-work">2. 관련 연구(Related work)</h2>

<p>기학습된 단어 벡터(pretrained word vectors)는 많은 NLP 모델에서 매우 중요한 역할을 했다. 그러나 미리 학습된 단어 벡터는 다의어도 한 개의 벡터로 표현하기 때문에 문맥 정보를 고려하지 못한다.<br />
이를 극복하기 위한 방안으로 보조단어 정보를 활용하거나 각 단어당 여러 벡터를 만드는 방법이 고려되었다. 이 논문의 방법(ELMo representation)은 보조정보로부터의 이점을 가지며 또한 명시적으로 여러 벡터를 만들 필요도 없다.</p>

<p>문맥의존 표현을 학습하는 다른 연구로는 다음이 있다.</p>

<ul>
  <li>양방향 LSTM을 사용하는 context2vec(Melamud et al., 2016)</li>
  <li>표현 안에 pivot word 자체를 포함하는 CoVe(McCann et al., 2017)</li>
</ul>

<p>Deep biRNN의 낮은 단계의 layer를 사용하여 dependency parsing(Hashimoto et al., 2017)이나 CCG super tagging(Søgaard and Goldbert, 2016) 등의 문제에서 성능 향상을 시킨 연구도 있었다.<br />
Dai and Le(2015)와 Ramachandran et al.(2017)에서는 언어모델(LM)로 인코더-디코더 쌍을 기학습시키고 특정 task에 fine-tune시켰다.</p>

<p>이 논문에서는 미분류된 데이터로부터 biLM을 기학습시킨 후 weights를 고정시키고 task-specific한 부분을 추가하여 leverage를 증가시키고 풍부한 biLM representation을 얻을 수 있게 하였다.</p>

<hr />

<h2 id="3-elmo-embeddings-from-language-models">3. ELMo: Embeddings from Language Models</h2>

<p>다른 단어 embedding과는 다르게 ELMo word representation은 전체 입력 sequence의 함수이다. 이는 글자수준 합성곱(character convolutions, Sec. 3.1)로부터 얻은 biLM의 가장 위 2개의 layer의 선형함수(가중합, Sec. 3.2)으로 계산된다. 이는 준지도학습과 더불어 biLM이 대규모에서 기학습되며(Sec 3.4) 쉽게 다른 NLP 모델에 붙일 수 있도록(Sec 3.3) 해준다.</p>

<h3 id="31-bidirectional-language-models">3.1. Bidirectional language models</h3>

<p>$N$개의 token $(t_1, t_2, …, t_N)$이 있을 때, 전방언어모델(forward language model)은 $(t_1, …, t_{k-1})$이 주어졌을 때 token $t_k$가 나올 확률을 계산한다:</p>

<script type="math/tex; mode=display">p(t_1, t_2, ..., t_N) = \prod_{k=1}^N p(t_k \vert t_1, t_2, ..., t_{k-1})</script>

<p>최신 언어모델은 token embedding이나 문자단위 CNN을 통해 문맥-독립적 token representation $x_k^{NM}$을 계산하고 이를 전방 LSTM의 $L$개의 layer에 전달한다.<br />
각 위치 $k$에서, 각 LSTM layer는 문맥-의존적 representation $\overrightarrow{h}_{k, j}^{LM}(j = 1, …, L)$을 출력한다.</p>

<p>LSTM의 최상위 layer LSTM 출력 $\overrightarrow{h}_{k, L}^{LM}$은 Softmax layer와 함께 다음 token을 예측하는 데 사용된다.</p>

<p>후방(backward) LSTM은 거의 비슷하지만 방향이 반대라는 것이 다르다. 식의 형태는 똑같지만 뒤쪽 token을 사용해 확률을 계산하고 token을 예측한다.</p>

<script type="math/tex; mode=display">p(t_1, t_2, ..., t_N) = \prod_{k=1}^N p(t_k \vert t_{k+1}, t_{k+2}, ..., t_N)</script>

<p>즉 $(t_{k+1}, …, t_N)$이 주어졌을 때 representation $\overleftarrow{h}_{k, j}^{LM}$을 계산한다.</p>

<p>biLM은 이 둘을 결합시킨 로그우도를 최대화한다.</p>

<script type="math/tex; mode=display">\sum_{k=1}^N \Big( \log \ p(t_k \vert t_1, ..., t_{k-1}; \Theta_x, \overrightarrow{\Theta}_{LSTM}, \Theta_s) + \log \ p(t_k \vert t_{k+1}, ..., t_N; \Theta_x, \overleftarrow{\Theta}_{LSTM}, \Theta_s) \Big)</script>

<p>$\Theta_x$는 token representation, $\Theta_s$는 Softmax layer이며 이 둘은 LSTM의 parameter과는 다르게 고정된다.</p>

<h3 id="32-elmo">3.2. ELMo</h3>

<p>ELMo는 biLM의 중간 layer representation을 task-specific하게 결합한다. biLM의 $L$개의 layer는 각 token $t_k$당 $2L+1$개의 representation을 계산한다.</p>

<p>각 biLSTM layer에서</p>

<script type="math/tex; mode=display">h_{k, 0}^{LM}: \text{token layer}, h_{k, j}^{LM} = [\overrightarrow{h}_{k, j}^{LM}; \overleftarrow{h}_{k, j}^{LM}]</script>

<p>일 때</p>

<script type="math/tex; mode=display">R_k = \{ x_k^{LM}, \overrightarrow{h}_{k, j}^{LM}, \overleftarrow{h}_{k, j}^{LM} \vert j = 1, ..., L \} = \{ h_{k, j}^{LM} \vert j = 0, ..., L \}</script>

<p>위의 식은 위치 $k$에서 $R_k$는 $1+L+L=2L+1$개의 representation으로 이루어져 있다는 뜻이다.</p>

<p>Downstream model로의 포함을 위해, ELMo는 $R$의 모든 layer를 하나의 벡터 $\text{ELMo}_k = E(R_k; \Theta_e)$로 압축시킨다.</p>

<p>가장 단순한 예로 ELMo가 단지 최상위 레이어를 택하는 $E(R_k) = h_{k, L}^{LM}$는 TagLM이나 CoVe의 것과 비슷하다.</p>

<p>더 일반적으로, 모든 biLM layer의 task-specific한 weighting을 계산한다:</p>

<script type="math/tex; mode=display">\text{ELMo}_k^{task} = E(R_k; \Theta^{task}) = \gamma^{task} \sum_{j=0}^L s_j^{task} h_{k, j}^{LM}</script>

<p>$s^{task}$는 softmax-정규화된 가중치이고 scalar parameter $\gamma^{task}$는 전체 ELMo 벡터의 크기를 조절하는 역할을 한다. $\gamma$는 최적화 단계에서 중요하다.<br />
각 biLM layer에서의 활성함수는 다른 분포를 갖는데, 경우에 따라 가중치를 정하기 전 각 biLM layer에 정규화를 적용하는 데 도움이 되기도 한다.</p>

<h3 id="33-using-bilms-for-supervised-nlp-tasks">3.3. Using biLMs for supervised NLP tasks</h3>

<p>목표 NLP task에 대한 기학습된 biLM과 지도(supervised) 모델구성이 주어지면, 해당 task 모델을 향상시키도록 biLM을 쓰는 과정은 간단하다.</p>

<ul>
  <li>단지 biLM을 돌리고 각 단어마다 모든 layer representation을 기록한다.</li>
  <li>그리고 모델이 이 representation들의 선형결합을 배우도록 한다.
    <ul>
      <li>먼저 biLM이 없는 지도 모델을 고려한다.</li>
      <li>대부분의 NLP 지도 모델은 가장 낮은 단계의 layer에서 공통구조를 공유하는데, 이는 ELMo를 일관된 방법으로 추가할 수 있게 해 준다.</li>
      <li>$(t_1, t_2, …, t_N)$이 주어지면 기학습된 단어 embedding(+글자기반 representation)을 사용하여 각 token 위치마다 문맥-독립적 token representation $x_k$를 만든다.</li>
      <li>그러면 모델은 biRNN이든 CNN이든 FFN이든 사용하여 문맥-의존적 representation $h_k$를 생성한다.</li>
    </ul>
  </li>
</ul>

<p>ELMo를 지도 모델에 추가하려면</p>

<ul>
  <li>먼저 biLM의 weight를 고정시키고</li>
  <li>ELMo 벡터 $\text{ELMo}_k^{task}$와 $x_k$를 이어붙인 후</li>
  <li>ELMo enhanced representation $[x_k; \text{ELMo}_k^{task}]$를 task RNN에 전달한다.</li>
</ul>

<p>SNLI, SQuAD 등의 task에서는 $h_k$를 $[x_k; \text{ELMo}_k^{task}]$로 대체하면 성능이 더 향상되었다.<br />
또한 ELMo에 dropout을 적용하는 것과, $\lambda \Vert w \Vert_2^2$를 loss에 더해 ELMo weight를 정규화하는 것이 ELMo weight에 inductive bias를 유도하여 모든 biLM layer의 평균에 더 가까워지도록 하여 성능에 도움을 주는 것을 발견하였다.</p>

<h3 id="34-pre-trained-bidirectional-language-model-architecture">3.4. Pre-trained bidirectional language model architecture</h3>

<p>기학습된 biLM은 이전 모델(Józefowicz et al. 2016)의 것과 비슷하지만 양방향 학습의 동시학습을 가능하게 하고 LSTM layer 사이에 residual connection을 추가하였다.</p>

<p>완전히 문자기반인 입력 representation을 유지하면서도 모델복잡도와 계산요구량의 균형을 맞추기 위해, embedding과 은닉차원을 반으로 줄였다.<br />
최종 모델은 4096개의 unit과 512차원의 projection layer, 1-2번 layer 사이 residual connection을 갖는 $L=2$ biLSTM을 사용한다.<br />
그 결과 biLM은 각 입력 token마다 순수 문자기반 입력 때문에 학습셋을 벗어나는 것을 포함한, 3개의 layer of representation을 생성한다. 이는 전통적인 단어 embedding이 고정된 단어사전 하에서 token에 대해 단 한개의 layer of representation을 생성하는 것과 대비된다.</p>

<p>1B word Benchmark로 10 epoch만큼 학습시킨 결과 perplexity가 30.0에서 39.7로 크게 늘었다.</p>

<p>일단 기학습된 biLM은 어떤 task에서도 representation을 계산할 수 있다. 대부분의 downstream task에서는 fine-tuned biLM을 사용하였다.</p>

<hr />

<h2 id="4-평가evaluation">4. 평가(Evaluation)</h2>

<center><img src="/public/img/2019-08-20-ELMo - Deep contextualized word representations/01.png" width="100%" alt="Results" /></center>

<p>6개의 NLP task에서 에러율을 상대적으로 6~20%만큼 줄였다.</p>

<p>Question Answering 부문에선 SQuAD, Textual Entailment에서는 SNLI 데이터셋을 사용했으며, Semantic role labeling, Coreference resolution, Named entity extraction, Sentiment analysis 등의 task에서도 높은 점수를 기록했음을 볼 수 있다.<br />
데이터셋과 어떤 향상이 있었는지에 대한 정보는 원문을 찾아보면 된다.</p>

<hr />

<h2 id="5-분석analysis">5. 분석(Analysis)</h2>

<p>이 섹션에서는 특정 부분을 빼거나 교체해서 해당 부분의 역할을 알아보는 ablation 분석을 수행한다.</p>

<h3 id="51-alternate-layer-weighting-schemes">5.1. Alternate layer weighting schemes</h3>

<p>biLM layer를 결합시키는 방법은 매우 다양하다. 또한 정규화 parameter $\lambda$도 매우 중요한 역할을하는데, $\lambda$가 크면(e.g., $\lambda=1$) 가중함수를 단순평균함수로 만들고, 작으면(e.g., $\lambda=0.001$) layer 가중치를 서로 달라지게 한다.</p>

<script type="math/tex; mode=display">\text{ELMo}_k^{task} = E(R_k; \Theta^{task}) = \gamma^{task} \sum_{j=0}^L s_j^{task} h_{k, j}^{LM}</script>

<center><img src="/public/img/2019-08-20-ELMo - Deep contextualized word representations/02.png" width="80%" alt="Results" /></center>

<p>위 결과에서 보듯이 단지 마지막 layer만 쓰는 것보다 모든 layer를 쓰는 것이 더 좋으며, 각각을 단순평균하는 것이 아닌 가중합을 하였을 때(이는 $\lambda$가 작은 것으로 구현됨) 더 성능이 좋아지는 것을 볼 수 있다.<br />
즉 작은 $\lambda$가 ELMo에 도움이 되며 task의 종류에는 크게 영향받지 않는 것 같다.</p>

<h3 id="52-where-to-include-elmo">5.2. Where to include ELMo?</h3>

<p>이 논문에서는 단어 embedding을 biRNN의 최하층에만 넣었지만 일부 task에서는 biRNN의 출력에 ELMo를 포함시키는 것이 성능향상을 가져오는 것을 볼 수 있다.</p>

<center><img src="/public/img/2019-08-20-ELMo - Deep contextualized word representations/03.png" width="80%" alt="Results" /></center>

<p>단 위에서 보듯이 모든 경우에 좋은 것은 아니다. SQuAD와 SNLI 모델구성은 biRNN 뒤에 attention layer을 사용하므로 이 layer에 ELMo를 추가하는 것은 biLM의 내부 representatino에 직접 접근할 수 있도록 해 주며 SRL의 경우 task-specific한 문맥 representation이 더 중요하기 때문이라는 설명이 가능하다.</p>

<h3 id="53-what-information-is-captured-by-the-bilms-representations">5.3. What information is captured by the biLM’s representations?</h3>

<p>ELMo를 추가하는 것만으로 단어 벡터만 있을 때보다 성능이 향상되었기 때문에, biLM의 문맥적 representation은 단어 벡터가 잡아내지 못한 어떤 정보를 갖고 있어야 한다. 직관적으로 biLM은 다의어를 명확화(disambiguation, 다의어의 여러 뜻 중 어떤 의미로 쓰였는지 알아내는 것)한 정보를 갖고 있어야 한다.</p>

<center><img src="/public/img/2019-08-20-ELMo - Deep contextualized word representations/04.png" width="100%" alt="Results" /></center>

<p>위 표에서 GloVe 단어벡터에서 ‘play’ 와 비슷한 단어는 품사를 변형한 것 또는 스포츠에 관한 것만 유사 단어로 뜬다.<br />
그러나 biLM에서는 ‘play’이 비슷한 의미로 쓰인 문장을 유사한 것으로 판단할 수 있음을 알 수 있다.</p>

<p><strong>Word sense disambiguation</strong></p>

<center><img src="/public/img/2019-08-20-ELMo - Deep contextualized word representations/05.png" width="80%" alt="Results" /></center>

<p>단어 의미 명확화에서 충분히 괜찮은 성능을 보여준다.</p>

<p><strong>POS tagging</strong></p>

<center><img src="/public/img/2019-08-20-ELMo - Deep contextualized word representations/06.png" width="80%" alt="Results" /></center>

<p>품사 태깅도 꽤 잘 한다고 한다.</p>

<p><strong>Implications for supervised tasks</strong></p>

<p>이러한 실험들은 왜 biLM에서 모든 layer가 중요한지를 알려 준다. 각 layer마다 잡아낼 수 있는 문맥정보가 다르기 때문이다.</p>

<h3 id="54-sample-efficiency">5.4. Sample efficiency</h3>

<p>ELMo를 추가했을 때는 그렇지 않을 때보다 학습속도도 빠르며(최대 49배 정도) 학습데이터가 적을 때도 훨씬 효율적으로 학습한다.</p>

<center><img src="/public/img/2019-08-20-ELMo - Deep contextualized word representations/07.png" width="80%" alt="Results" /></center>

<h3 id="55-visualization-of-learned-weights">5.5. Visualization of learned weights</h3>

<center><img src="/public/img/2019-08-20-ELMo - Deep contextualized word representations/08.png" width="100%" alt="Results" /></center>

<p>입력 layer에서 task 모델은, 특히 corefenrece와 SQuAD에서 첫번째 biLSTM layer를 선호한다. 출력 layer에서 낮은 레이어에 조금 더 중점을 두지만 상대적으로 균형잡힌 모습을 보여준다.</p>

<hr />

<h2 id="6-결론conclusion">6. 결론(Conclusion)</h2>

<p>이 논문에서는 biLM으로부터 고품질의 깊은 문맥의존 representation을 학습하는 일반적인 방법을 소개했으며, 넓은 범위의 NLP 문제들에서 ELMo를 적용했을 때 많은 성능 향상을 가져오는 것을 보였다. 또한 ablation을 통해 biLM의 모든 layer들이 각각 효율적으로 문맥 정보를 포착하여, 이를 모두 사용하는 것이 좋다는 것을 보였다.</p>

<hr />

<h2 id="refenrences">Refenrences</h2>

<p>논문 참조. 레퍼런스가 많다.</p>

<p>또한 이 논문이 일부 모듈의 원형으로 삼은 모델들의 구조를 살펴볼 수 있다.</p>

<hr />

<h2 id="appendix">Appendix</h2>

<p>부록에서는 $\gamma$의 중요성이나, 각 NLP task에서 ELMo를 붙였을 때 성능 향상이 이루어지는 예시들을 많이 들고 있다. 한번쯤 살펴보자.</p>

<hr />


    </article>
    <div class="post-more">
      
      <a href="/ELMo-Deep-contextualized-word-representations/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/ELMo-Deep-contextualized-word-representations/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/Attention-Is-All-You-Need/">
        Attention Is All You Need
      </a>
    </h1>

    <span class="post-date">17 Aug 2019</span>
     |
    
    <a href="/blog/tags/#paper-review" class="post-tag">Paper_Review</a>
    
    <a href="/blog/tags/#nlp" class="post-tag">NLP</a>
    
    

    <article>
      <hr />

<p>이 글에서는 2017년 6월(v1) <em>Ashish Vaswani</em> 등이 발표한 Attention Is All You Need를 살펴보도록 한다.</p>

<p>중요한 부분만 적을 예정이므로 전체가 궁금하면 원 논문을 찾아 읽어보면 된다.</p>

<hr />

<h1 id="attention-is-all-you-need">Attention Is All You Need</h1>

<p>논문 링크: <strong><a href="https://arxiv.org/abs/1706.03762">Attention Is All You Need</a></strong></p>

<p>Pytorch code: <strong><a href="http://nlp.seas.harvard.edu/2018/04/03/attention.html">Harvard NLP</a></strong></p>

<h2 id="초록abstract">초록(Abstract)</h2>

<p>성능 좋은 변환(번역) 모델은 인코더와 디코더를 포함한 복잡한 recurrent 또는 convolutional 신경망에 기반을 두고 있다. 최고 성능을 내는 모델 역시 attention mechanism을 사용하여 인코더와 디코더를 연결한다.<br />
이 논문에서 recurrence와 convolution을 전부 제외하고 오직 attention mechanism에만 기반한 <strong>Transformer</strong>라는 간단한 모델을 제안한다. 두 기계번역 task 실험에서는 이 모델은 병렬화와 학습시간 감소와 더불어 최고 수준의 품질을 가진다는 것을 보여준다. 이 모델은 WMT 2014 영어$\rightarrow$독일어 번역 task에서 이전보다 2 높은 28.4 BLEU를 달성하였다. 여기서 이 모델은 8개의 GPU로 8일 동안 학습시켜 41.8점의 BLEU state-of-the-art 단일 모델이다.<br />
이 논문에서 <strong>Transformer</strong>는 크거나 한정된 학습 데이터를 가지고서도 성공적으로 다른 task들에 일반화될 수 있음을 보인다.</p>

<hr />

<h2 id="1-서론introduction">1. 서론(Introduction)</h2>

<p>RNN, LSTM, GRU 등은 sequence 모델링과 언어모델 등 변환 문제, 기계번역 등의 문제에서 뛰어난 성과를 보였다.<br />
Recurrent 모델은 보통 입력과 출력의 symbol position에 따라 계산을 수행한다. 계산 단계에서 위치를 적절히 맞추기 위해 이전 상태 $h_{t-1}$과 위치 $t$의 함수인 은닉상태 $h_t$를 생성한다. 이는 근본적으로 메모리 제한으로 인해 sequence가 길수록 병렬화를 힘들게 한다. 최근 들어 모델의 성능 자체는 비약적으로 상승했지만 위의 문제는 여전히 남아 있다.</p>

<p>Attention mechanism은 입력과 출력 sequence의 거리에 상관없이 의존성을 모델링함으로써 다양한 과제에서의 sequence 모델링과 변환 모델에서 매우 중요한 부분이 되었다. 그러나 거의 대부분의 경우 recurrent 네트워크와 함께 사용되고 있다.</p>

<p>이 논문에서는, <strong>Transformer</strong>라는, recurrence를 제거하고 입력-출력 간 전역 의존성을 학습할 수 있는 attention mechanism만을 사용한 모델 구조를 제안한다. <strong>Transformer</strong>는 병렬화를 비약적으로 달성하였으며 8개의 P100 GPU만으로 딱 12시간만을 학습하여 state-of-the-art 결과를 얻을 수 있게 한다.</p>

<hr />

<h2 id="2-배경background">2. 배경(Background)</h2>

<p>연속적 계산을 줄이려는 노력은 Extended Neural GPU, ByteNet, ConvS2S 등의 모델을 탄생시켰으나 이들은 전부 CNN을 기본 블록으로 사용한다. 이러한 모델들은 임의의 위치의 input-output 사이의 관련성을 파악하기 위해서는 거리에 따라(선형 또는 로그 비례) 계산량이 증가하며, 이는 장거리 의존성을 학습하기 어렵게 한다.<br />
Transformer는, 이를 상수 시간의 계산만으로 가능하게 하였다.</p>

<p>intra-attention으로도 불리는 Self-attention은 sequence의 representation을 계산하기 위한 단일 sequence의 다른 위치를 연관시키는 attention mechanism이다. Self-attention은 많은 과제들에서 사용되었으며 성공적이었다.</p>

<p>End-to-end 메모리 네트워크는 sequence-aligned recurrence 대신 recurrent attention mechanism에 기반하였으며 simple-language QA와 언어모델링 task 등에서 좋은 성과를 내었다.</p>

<p>그러나, Transformer는 RNN이나 convolution 없이 오직 attention에 전적으로 의존한 첫 번째 변환 모델이다. 앞으로 이 모델에 대한 설명이 이어질 것이다.</p>

<hr />

<h2 id="3-모델-구성model-architecture">3. 모델 구성(Model Architecture)</h2>

<p>Transformer는 크게 인코더와 디코더로 나뉘며, 인코더는 입력인 symbol representations $(x_1, …, x_n)$을 continuous representations $z = (z_1, …, z_n)$으로 매핑한다. $z$가 주어지면, 디코더는 한번에 한 원소씩 출력 sequence $(y_1, …, y_n)$를 생성한다.<br />
각 단계는 자동회귀(auto-regressive)이며, 다음 단계의 symbol을 생성할 때 이전 단계에서 생성된 symbol을 추가 입력으로 받는다.</p>

<p>Transformer는 인코더와 디코더 모두에서 쌓은 self-attention과 point-wise FC layer를 사용하며, 그 구성은 아래 그림에 나타나 있다.</p>

<center><img src="/public/img/2019-08-17-Attention Is All You Need/01.png" width="100%" alt="Transformer Architecture" /></center>

<h3 id="31-encoder-and-decoder-stacks">3.1. Encoder and Decoder Stacks</h3>

<p>인코더는 $N = 6$ 개의 동일한 레이어로 구성되며, 각 레이어는 아래 두 개의 sub-layer로 이루어져 있다.</p>

<ul>
  <li>multi-head self-attention mechanism</li>
  <li>simple, position-wise fully connected feed-forward network</li>
</ul>

<p>각 sub-layer의 출력값은 LayerNorm($x$ + Sublayer($x$))이고, Sublayer($x$)는 sub-layer 자체로 구현되는 함수이다. 이 residual connection을 용이하게 하기 위해, embedding layer를 포함한 모델의 모든 sub-layer는 $d_{model} = 512$차원의 출력값을 가진다.</p>

<p>디코더 역시 $N = 6$ 개의 동일한 레이어로 구성되지만, 각 레이어는 인코더의 것과 동일한 두 개의 sub-layer 외에 한 가지를 더 가진다.</p>

<ul>
  <li>encoder stack의 출력값에 multi-head attention을 수행하는 sub-layer</li>
</ul>

<p>인코더와 비슷하게 residual connection이 각 sub-layer의 정규화 layer 뒤에 있다. 그리고 디코더가 출력을 생성할 때 다음 출력에서 정보를 얻는 것을 방지하기 위해 <strong>masking</strong>을 사용한다. 이는 $i$번째 원소를 생성할 때는 $1 \sim i-1$번째 원소만 참조할 수 있도록 하는 것이다.</p>

<h3 id="32-attention">3.2. Attention</h3>

<p>Attention 함수는 <em>query + key-value</em> $\rightarrow$ <em>output</em> 으로의 변환을 수행한다. query, key, value, output은 모두 벡터이다. output은 value들의 가중합으로 계산되며, 그 가중치는 query와 연관된 key의 호환성 함수(compatibility function)에 의해 계산된다.</p>

<h4 id="321-scaled-dot-product-attention">3.2.1. Scaled Dot-Product Attention</h4>

<p>이 이름은 Attention을 계산하는데 dot-product를 쓰고, 그 결과에 scale 조정을 하기 때문에 이렇게 붙여졌다.</p>

<center><img src="/public/img/2019-08-17-Attention Is All You Need/02.png" width="100%" alt="Scaled Dot-Product Attention &amp; Multi-head Attention" /></center>

<p>입력은 $d_k$차원의 query와 key, $d_v$차원의 value로 구성된다. <br />
query와 모든 key의 내적(dot product)을 계산하고, 각각 $\sqrt{d_k}$로 나누고, value의 가중치를 얻기 위해 softmax 함수를 적용한다.</p>

<p>실제로는, query들에 대해 동시에 계산하기 위해 이를 행렬 $Q$로 묶는다. 모든 key와 value 역시 각각 행렬 $K$와 $V$로 표현된다. 이제 $Q, K, V$의 attention을 구하는 식은 다음과 같다.</p>

<script type="math/tex; mode=display">Attention(Q, K, V) = \text{softmax} \Big( \frac{QK^T}{\sqrt{d_k}} \Big) V</script>

<p>가장 널리 쓰이는 attention 함수는 다음 두 가지다:</p>

<ul>
  <li>Additive attention: 단일 hidden layer의 feed-forward 네트워크를 사용하여 호환성 함수를 계산한다. $d_k$가 작을 때 성능이 더 좋다.</li>
  <li>Dot-product attention: $d_k$가 더 클 때는 빠른 행렬곱 알고리즘에 힘입어 더 빠르고 더 공간 효율적이다.</li>
</ul>

<h4 id="322-multi-head-attention">3.2.2. Multi-Head Attention</h4>

<p>$d_{model}$차원 key, value, query로 단일 attention function을 쓰는 것보다 query, key, value를 각각 $d_k, d_k, d_v$차원으로 각각 다르게 $h$번 학습시키는 것이 낫다. 여기서 $h$번 학습시킨다는 것은 단지 반복을 한다는 것이 아니라, 각 sub-layer에 동일한 부분이 $h$개 존재한다는 뜻이다. 위 그림의 오른쪽을 보자.<br />
이렇게 각각 따로 계산된 $h$쌍의 $d_v$차원 출력은 이어붙인(concatenate) 후 한번 더 선형 함수에 통과시켜(projected) 최종 출력값이 된다.</p>

<p>식으로 나타내면 다음과 같다.</p>

<script type="math/tex; mode=display">\text{MultiHead}(Q, K, V) = \text{Concat}(head_1, ..., head_h)W^O, where \ head_i=\text{Attention}(QW_i^Q, KW_i^K, VW_i^V)</script>

<p>여기서 $ W_i^Q \in \mathbb{R}^{d_{model} \times d_k}, W_i^K \in \mathbb{R}^{d_{model} \times d_k}, W_i^V \in \mathbb{R}^{d_{model} \times d_v}, W^O \in \mathbb{R}^{hd_v \times d_{model}} $이며, 논문에서는 $h=8, d_k=d_v=d_{model}/h = 64$를 사용하였다.<br />
각 head의 차원이 줄었기 때문에 단일 head attention과 계산량은 비슷하다.</p>

<h4 id="323-applications-of-attention-in-our-model">3.2.3. Applications of Attention in our Model</h4>

<ul>
  <li>“encoder-decoder attention” layer에서, query는 이전 디코더 layer에서 오며 memory key와 value는 encoder의 출력에서 온다. 이는 디코더가 입력의 모든 위치(원소)를 고려할 수 있도록 한다.</li>
  <li>인코더는 self-attention layer를 포함한다. 여기서 모든 key, value, query는 같은 곳(인코더의 이전 layer의 출력)에서 온다. 따라서 인코더의 각 원소는 이전 layer의 모든 원소를 고려할 수 있다.</li>
  <li>이는 디코더에서도 비슷하다. 그러나 auto-regressive 속성을 보존하기 위해 디코더는 출력을 생성할 시 다음 출력을 고려해서는 안 된다. 즉 이전에 설명한 <strong>masking</strong>을 통해 이전 원소는 참조할 수 없도록 한다. 이 masking은 dot-product를 수행할 때 $-\infty$로 설정함으로써 masking out시킨다. 이렇게 설정되면 softmax를 통과할 때 0이 되므로 masking의 목적이 달성된다.</li>
</ul>

<h3 id="33-position-wise-feed-forward-networks">3.3. Position-wise Feed-Forward Networks</h3>

<p>인코더와 디코더의 각 layer는 FC feed-forward 네트워크를 포함하는데, 이는 각 위치마다 동일하게 적용되지만 각각 따로 적용된다. 이는 ReLU 활성함수와 2개의 선형변환을 포함한다. kernel size가 1인 CNN과 같다.</p>

<script type="math/tex; mode=display">\text{FFN}(x) = \max(0, xW_1 + b_1)W_2 + b_2</script>

<p>각 레이어에 이 부분은 독립적인 parameter를 사용한다. 논문에서는 $d_{model}=512, d_{ff} = 2048$을 사용했다.</p>

<h3 id="34-embeddings-and-softmax">3.4. Embeddings and Softmax</h3>

<p>다른 모델들과 비슷하게 embedding을 사용하였다. 이 모델에서는 2개의 embedding layer와 pre-softmax 선형변환 사이에 같은 weight 행렬을 사용했다. Embedding layer에는 $\sqrt{d_{model}}$을 곱한다.</p>

<h3 id="35-positional-encoding">3.5. Positional Encoding</h3>

<p>이 모델에는 recurrence도 convolution도 사용되지 않기 때문에 sequence에 있는 원소들의 위치에 대한 정보를 따로 넣어 주어야 한다. 그래서 인코더와 디코더 stack의 밑부분에 <strong>positional encodings</strong>를 입력 embedding에 추가하였다. 이는 embedding과 갈은 $d_{model}$차원을 가지며, 따라서 더할 수 있다. 모델에서 사용된 것은 사인/코사인 함수이다.</p>

<script type="math/tex; mode=display">\quad PE_{(pos, 2i)} = sin(pos/10000^{2i/d_{model}})</script>

<script type="math/tex; mode=display">\ PE_{(pos, 2i+1)} = cos(pos/10000^{2i/d_{model}})</script>

<p>$pos$는 위치(position)이고 $i$는 차원이다.</p>

<p>가능한 여러 함수 중 사인함수 버전을 선택한 이유는 학습 때보다 더 긴 sequence를 만나도 추정이 가능하기 때문이다.</p>

<hr />

<h2 id="4-왜-self-attention인가why-self-attention">4. 왜 Self-Attention인가(Why Self-Attention)</h2>

<p>$(x_1, …, x_n) \rightarrow (z_1, …, z_n)$에 self-attention이 적합한 이유는</p>

<ol>
  <li>layer 당 전체 계산량이 적고</li>
  <li>계산이 병렬화될 수 있다. 즉 병렬적으로 한번에 많은 계산을 할 수 있는데, recurrence의 경우 순차적으로 계산해야 하기 때문에 계산의 병렬화가 거의 불가능하다.</li>
  <li>장거리 의존성(long-range 또는 long-term dependency) 때문이다.</li>
</ol>

<p>장거리 의존성을 학습할 수 있는 중요 요인은 네트워크 상에서 횡단할 수 있는 경로의 길이인데, 길이가 짧을 때는 다 비슷하므로 최대 길이를 중점적으로 살펴보았다.</p>

<center><img src="/public/img/2019-08-17-Attention Is All You Need/03.png" width="100%" alt="Why Self-Attention" /></center>

<p>위 표에서 볼 수 있듯 장거리 의존성의 학습 속도(또는 능력)에서 self-attention이 가장 좋다.</p>

<hr />

<h2 id="5-학습training">5. 학습(Training)</h2>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Descrption</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>DataSet(German)</td>
      <td>WMT 2014 English-German dataset(4.5M쌍의 문장, 37000 vocab)</td>
    </tr>
    <tr>
      <td>DataSet(French)</td>
      <td>WMT 2014 English-French dataset(36M쌍의 문장, 32000 vocab)</td>
    </tr>
    <tr>
      <td>Batch size</td>
      <td>25000</td>
    </tr>
    <tr>
      <td>Hardware</td>
      <td>8개의 P100 GPU</td>
    </tr>
    <tr>
      <td>Schedule</td>
      <td>Base Model: 12시간=10만 step $\times$ 0.4초/step, Big Model: 36시간=30만 step</td>
    </tr>
    <tr>
      <td>Optimizer</td>
      <td>Adam($\beta_1=0.9, \beta_2=0.98, \epsilon=10^{-9} $)</td>
    </tr>
    <tr>
      <td>Learning Rate</td>
      <td>$lrate = d_{model}^{-0.5} \cdot \min ($step_num$^{-0.5}$, step_num $\cdot$ warmup_steps $^{-1.5}) $</td>
    </tr>
    <tr>
      <td>warmup_steps</td>
      <td>4000</td>
    </tr>
    <tr>
      <td>Regularization</td>
      <td>Residual Dropout($P_{drop} = 0.1$)</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="6-결과results">6. 결과(Results)</h2>

<center><img src="/public/img/2019-08-17-Attention Is All You Need/04.png" width="100%" alt="Result 1" /></center>

<center><img src="/public/img/2019-08-17-Attention Is All You Need/05.png" width="100%" alt="Result 2" /></center>

<p>Machine Translation, Model Variations, English Constituency Parsing에 대한 실험 결과이다. Base Model만 해도 충분히 최고 성능을 보여주며, 특히 Big Model의 경우 state-of-the-art를 상당한 수준으로 경신하는 성능을 보여 주었다.<br />
이외에 따로 요약이 필요하지는 않아 자세한 조건이나 성능, 설명은 생략하도록 하겠다. 필요하면 논문 참조하는 편이 낫다.</p>

<h3 id="결과-부록">결과: 부록</h3>

<p>원래는 부록에 있는 자료이지만 결과 섹션으로 가져왔다.</p>

<p>아래 그림에서는 <em>making</em> 이라는 단어가 <em>making…more difficult</em> 라는 구를 만드는 데 중요한 역할을 하는 것을 보여준다.</p>
<center><img src="/public/img/2019-08-17-Attention Is All You Need/06.png" width="100%" alt="Attention Visaulizations" /></center>

<p>여러 개의 attention을 시각화한 자료는 다음 두 그림에서 확인할 수 있다.</p>

<center><img src="/public/img/2019-08-17-Attention Is All You Need/07.png" width="100%" alt="Attention Head Visaulizations 1" /></center>

<center><img src="/public/img/2019-08-17-Attention Is All You Need/08.png" width="100%" alt="Attention Head Visaulizations 1" /></center>

<hr />

<h2 id="7-결론conclusion">7. 결론(Conclusion)</h2>

<p>(여러 번 나온 말이지만) <strong>Transformer</strong>는 recurrence와 convolution을 모두 제거한, 오직 attention에만 의존하는 새로운 종류의 모델이다. 이 모델은 계산량을 줄이고 병렬화를 적용해 학습 속도가 훨씬 빠를 뿐만 아니라 그 성능 또한 state-of-the-art를 달성하는 수준에 이르렀다.<br />
또한 이러한 attention에 기반한 모델은 다른 task들에 적용할 수도 있다. 비단 텍스트뿐만 아니라 이미지, 오디오나 비디오 등의 상대적으로 큰 입력-출력을 요하는 task들에 효과적으로 사용할 수 있을 것이다.</p>

<p>이 모델을 학습하고 평가한 코드는 <a href="https://github.com/tensorflow/tensor2tensor">여기</a>에서 찾아볼 수 있다.</p>

<hr />

<h2 id="refenrences">Refenrences</h2>

<p>논문 참조. 40개의 레퍼런스가 있다.</p>

<hr />


    </article>
    <div class="post-more">
      
      <a href="/Attention-Is-All-You-Need/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/Attention-Is-All-You-Need/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/Generating-Sequences-WIth-Recurrent-Neural-Networks/">
        Generating Sequences With Recurrent Neural Networks
      </a>
    </h1>

    <span class="post-date">15 Jul 2019</span>
     |
    
    <a href="/blog/tags/#paper-review" class="post-tag">Paper_Review</a>
    
    <a href="/blog/tags/#nlp" class="post-tag">NLP</a>
    
    

    <article>
      <hr />

<p>이 글에서는 2013년 8월(v1) Alex Graves가 발표한 Generating Sequences With Recurrent Neural Networks를 살펴보도록 한다.</p>

<p><a href="https://www.cs.toronto.edu/~graves/">연구자의 홈페이지</a>도 있다.</p>

<p>중요한 부분만 적을 예정이므로 전체가 궁금하면 원 논문을 찾아 읽어보면 된다.</p>

<hr />

<h1 id="generating-sequences-with-recurrent-neural-networks">Generating Sequences With Recurrent Neural Networks</h1>

<p>논문 링크: <strong><a href="https://arxiv.org/abs/1308.0850">Generating Sequences With Recurrent Neural Networks</a></strong></p>

<h2 id="초록abstract">초록(Abstract)</h2>

<p>이 논문은 LSTM(Long Short-term Memory) RNNs이 어떻게 넓은 범위의 구조를 가진 복잡한 시퀀스(sequences, 문장 등)를 만들 수 있는지(= 단순히 어느 시점에 하나의 부분만 예측하는 방법)를 보여준다. 이 접근법은 텍스트(이산값)와 손글씨(실수값)에 의해 보여질 것이다. 그리고 네트워크가 텍스트 문장에 대해 예측을 수행함으로써 손글씨 합성으로까지 확장한다. 이 결과 시스템은 다양한 스타일의 정말 실제 같은 필기체를 생성할 수 있다.</p>

<hr />

<h2 id="1-서론introduction">1. 서론(Introduction)</h2>

<p>RNNs(Recurrent Neural Networks)은 음악, 텍스트, 모션캡쳐 데이터 등과 같은 연속데이터를 생성하기 위해 사용되는 모델이다. RNN은 일반적으로 지금까지의 입력값과 모델 내부 parameter를 바탕으로 바로 다음 것이 무엇일지를 예측하는 모델이다.<br />
RNN은 많은 경우 그 예측이 애매하며 불확실하다(fuzzy). 그 이유는 항상 확정적이며 똑같은 결과만을 내놓는다면 생성되는 문장이나 음악은 항상 똑같을 것인데 우리는 그런 것을 원하지 않으며, 또한 확률적인(stochastic) 방법이 정확한(exact) 일치 방법에 비해 차원의 저주(the curse of dimensionality)를 피하기 적합하며 그로 인해 시퀀스 또는 다변수 데이터를 모델링하는 데 더 뛰어나다.</p>

<p>이론적으로는 충분히 큰 RNN은 어떤 복잡한 시퀀스(sequences)도 생성할 수 있어야 한다. 그러나 Vanilla RNN은 최근 몇 개의 입력값을 기억하며 이에 의존할 뿐 멀리 떨어진 이전 또는 장기적인 정보를 거의 기억하지 못한다.<br />
이를 많은 부분 해결한 것이 바로 LSTM이다. 이 역시 기본적으로는 이전 정보를 기억하는 RNN 구조를 따르지만 조금 더 복잡한 구조를 가지며 장기적(long-range) 정보를 저장하는 데 뛰어난 능력을 보인다.</p>

<p>이 논문에서는 다음과 같은 것들을 다룰 것이다.</p>

<ul>
  <li>Section 2: LSTM을 여럿 쌓을 ‘deep RNN’을 정의하고 어떻게 다음 단계를 예측하는 데 필요한 학습을 진행하며 시퀀스를 생성하는지 보여준다.</li>
  <li>Section 3: Penn Treebank와 Hutter Prize Wikipedia 데이터셋에 대해 예측을 수행하고 state-of-the-art 수준임을 보인다.</li>
  <li>Section 4: mixture density output layer를 사용하여 어떻게 실제 데이터에 적용할 수 있는지와 IAM Online Handwriting Database에 대한 실험 결과를 보인다.</li>
  <li>Section 5: 예측 네트워크를 짧은 주석에 기반하도록 하여 확장시켜서 어떻게 손글씨 합성을 시킬 수 있는지를 보인다.</li>
  <li>Section 6: 결론과 함께 추후 연구 방향을 제시한다.</li>
</ul>

<hr />

<h2 id="2-예측-네트워크prediction-network">2. 예측 네트워크(Prediction Network)</h2>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/01.png" width="100%" alt="Deep RNN Architecture" /></center>

<p>위 그림은 이 논문에서 사용된 기본 RNN 모델의 구조이다. 입력값 $x = (x_1, …, x_T)$은 $N$층에 걸쳐 쌓인 재귀적으로 연결된 hidden layers를 통과하며 $h^n = (h_1^n, …, h_T^n)$ 를 계산하고 최종적으로 $N$층을 다 통과하면 출력벡터 시퀀스 $y = (y_1, …, y_T)$를 얻는다. 각 출력벡버 $y_t$는 가능한 다음 입력값 $x_{t+1}$에 대한 예측분포 $P(x_{t+1} \vert y_t)$를 뜻한다. 초기값 $x_1$은 언제나 null 벡터이다.</p>

<p>입력과 모든 hidden layer, 그리고 모든 hidden layer와 출력과 ‘skip-connections’이 존재함을 기억하라. 이는 vanishing gradient 문제를 피해 깊은 신경망(DNN)을 학습시키기 용이하게 한다. $N=1$인 경우에 vanilla RNN과 같음을 확인할 수 있다.</p>

<p>Hidden layer의 각 활성값은 $t=1…T, n=2…N$ 동안 반복적으로 계산된다:</p>

<script type="math/tex; mode=display">h_t^1 = \mathcal{H}(W_{ih^1x_t} + W_{h^1h^1}h^1_{t-1} + b^1_h)</script>

<script type="math/tex; mode=display">h_t^n = \mathcal{H}(W_{ih^nx_t} + W_{h^{n-1}h^n}h^{n-1}_{t} + W_{h^nh^n}h^n_{t-1} + b^n_h)</script>

<p>$W$는 각 레이어의 가중치 행렬이다. 은닉 시퀀스가 주어졌을 때, 출력 시퀀스는</p>

<script type="math/tex; mode=display">\hat{y_t} = b_y + \sum^N_{n=1} W_{h^n y h_t^n}</script>

<script type="math/tex; mode=display">y_t = \mathcal{Y}(\hat{y_t})</script>

<p>$\mathcal{Y}$는 출력레이어 함수이다.</p>

<p>입력시퀀스 $x$에 대해 예측분포와 시퀀스 손실함수는</p>

<script type="math/tex; mode=display">Pr(x) = \prod_{t=1}^T Pr(x_{t+1} \vert y_t)</script>

<script type="math/tex; mode=display">\mathcal{L}(x) = -\prod_{t=1}^T \log Pr(x_{t+1} \vert y_t)</script>

<p>로 정의된다.</p>

<p><strong>LSTM</strong>의 구조에 대해서는 <a href="https://ratsgo.github.io/natural%20language%20processing/2017/03/09/rnnlstm/">다른 블로그</a>들에 자세히 잘 설명되어 있으니 참고하자.</p>

<hr />

<h2 id="3-문자-예측text-prediction">3. 문자 예측(Text Prediction)</h2>

<p>텍스트 데이터는 이산값이고, 이런 것들은 보통 ‘one-hot’ 방식으로 인코딩된다. 텍스트의 경우 단어(word) 수준으로 인코딩을 수행하게 되고, 이는 벡터의 크기가 단어 사전의 크기(보통 적어도 10만 이상)가 되는 문제가 발생한다.</p>

<p>최근에는 단어 수준 대신 문자 수준으로 예측을 수행하는 방법이 많이 고려되고 있다. 이 방법의 장점은</p>

<ul>
  <li>단어 수준 인코딩에 비해 성능이 별로 떨어지지 않으며</li>
  <li>벡터의 크기가 작고</li>
  <li>이전에 나타나지 안았던(unknown) 단어에 대한 대비가 필요 없어지며</li>
  <li>새로운 단어를 만들 가능성도 생긴다.</li>
</ul>

<p>따라서 이 논문에서는 문자 단위로 생성하는 모델을 고려할 것이다.</p>

<h3 id="31-penn-treebank-experiments">3.1. Penn Treebank Experiments</h3>

<p>이 데이터셋은 Wall Street Journal corpus의 일부로 네트워크의 예측능력보다는 시퀀스 생성능력에 초점을 두고 실험할 것이다.<br />
Penn Treebank 데이터셋은 100만 단어 정도의 작은 데이터셋이지만 언어 모델링 벤치마크에서 널리 사용된다. 93만 단어의 training set, 7만 4천 단어의 validation set, 8만 2천 단어의 test set을 포함한다. 단어는 1만 종류이며 나머지는 전부 unknown 처리되어 있다.</p>

<p>이 실험은 Penn corpus에 대해 단어 수준과 문자 수준의 LSTM 예측기의 성능을 비교하는 것이다. 두 경우 모두 1000개의 LSTM unit을 사용했고, 단어/문자 수준 벡터의 크기는 다르다(49 vs 10000, 가중치행렬의 크기는 4.3M vs 54M).</p>

<p>SGD(Stochastic Gradient Descent), learning rate 0.0001, momentum 0.99, LSTM derivates는 [-1, 1] 범위로 clip된다.</p>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/02.png" width="100%" alt="Penn Benchmark" /></center>

<p>위 실험의 결과를 두 가지로 요약하면</p>

<ul>
  <li>단어 수준 모델이 문자 수준 모델보다 약간 더 성능이 좋다는 것과</li>
  <li>LSTM은 Vanilla RNN보다 훨씬 빠르고 새 데이터에 최적화된다는 것이다.</li>
</ul>

<h3 id="32-wikipedia-experiments">3.2. Wikipedia Experiments</h3>

<p>2006년 Marcus Hutter, Jim Bowery, Matt Mahoney로부터 시작된 영문 위키피디아의 첫 1억(100M) 바이트의 데이터인 Wikipedia data는 다양한 단어와 문자를 포함한다. 아랍어나 중국어 등 비 라틴 알파벳 뿐만 아니라 메타데이터를 지정하는 XML 태그 등 그 종류가 꽤 방대하다.<br />
첫 96M 바이트는 training set, 나머지 4M 바이트는 validation으로 사용된다. 데이터는 205 one-byte 유니코드 기호를 사용한다.</p>

<p>여기서는 더 큰 모델을 사용했다. 700 LSTM unit을 포함하는 7층짜리 네터워크로 가중치행렬의 크기는 21.3M이다. momentum이 0.9인 것을 제외하면 다른 조건은 같다.</p>

<p>Wikipedia는 글의 주제와 같은 수천 단어 이상일 수 있는 넓은 범위(long-range) 의존성을 포함하기 때문에 LSTM의 내부 상태는 매번 100 sequence 만큼만을 리셋한다. 즉 gradient를 근사하는 것인데, 이는 넓은 범위 의존성을 최대한 잃지 않으면서 학습속도를 높이는 방법이다.<br />
아래 결과를 보면 Dynamic evaluation을 사용했을 때 성능이 더 좋게 나온다. 이는 위키피디아의 넓은 범위 일관성 때문인 것으로 보인다(예: 특정 단어들은 특정 글에서 더 빈번히 등장하며, 평가 중에 이에 맞출 수 있는 것이 더 유리하다).</p>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/03.png" width="70%" alt="Wikipedia Benchmark" /></center>

<p>논문에는 실제 위키피디아 페이지와, 예측 네트워크가 생성한 위키피디아 페이지를 보여주고 있는데 그 중 일부를 가져왔다.</p>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/06.png" width="100%" alt="Wikipedia Benchmark" /></center>

<p>보면 은근히 괜찮은 품질의 글을 생성해냈음을 볼 수 있다. 특히 봐줄 만한 이름들(Lochroom River, Mughal Ralvaldens, swalloped) 등의 모델이 직접 생성해낸 이름들이 눈의 띈다.</p>

<p>괄호나 따옴표를 여닫는 것은 언어 모델의 메모리에 명백히 이를 알려주는 지시자가 있는데, 이는 좁은 범위(short-range)의 문맥으로는 모델링될 수 없어서 중간 글자들만으로는 예측할 수 없기 때문이다. 위 샘플 결과는 괄호나 따옴표의 적절한 수를 지켰을 뿐만 아니라 nested XML tag 등도 잘 구현해 내었다.<br />
네터워크는 비 라틴 문자들, 키릴 문자나 한자, 아랍 문자 등을 생성했고, 이는 영어보다 더 기본적인 모델을 배운 것으로 보인다. 이 경우에도 봐줄 만한 이름들을 생성했다.</p>

<hr />

<h2 id="4-손글씨-예측handwriting-prediction">4. 손글씨 예측(Handwriting Prediction)</h2>

<p>예측 네트워크가 실수값 시퀀스(real-valued sequences)도 충분히 잘 생성할 수 있는지 확인하기 위해 <em>online</em> 손글씨 데이터에 이를 적용해 보았다(<em>online</em> 필기 데이터란 그냥 필기 이미지만 있는 <em>offline</em> 데이터와는 달리 펜으로 해당 필기를 할 때 어떤 궤적을 그렸는지에 대한 정보가 있는 것이다). IAM-OnDB 데이터셋을 사용하였다.<br />
IAM-OnDB 데이터셋은 221명의 사람이 Lancaster-Oslo-Bergen 말뭉치를 쓴 필기 데이터이다.</p>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/07.png" width="100%" alt="IAM-OnDB" /></center>

<h3 id="41-혼합밀도-출력값mixture-density-outputs">4.1 혼합밀도 출력값(Mixture Density Outputs)</h3>

<p><em>Mixture Density Outputs</em>의 아이디어는 혼합분포(mixture distribution)을 parameterise하기 위해 신경망의 출력값을 사용하는 것이다. 출력값의 부분집합은 혼합가중치(mixture weights)를 정의하기 위해, 남은 출력값은 독립적인 mixture components를 parameterise하도록 사용된다. Misture weight 출력값은 정규화, softmax 등을 거쳐 의미 있는 범위 안에 포함되도록 한다. 이는 Boltzmann machine이나 다른 무방향 모델과는 달리 density가 정규화되고 직접 미불되며 편향되지 않는 샘플을 고른다는 점에서 대비된다.</p>

<p>손글씨 실험을 위해, 기본적인 RNN 구조는 Section 2에서 변하지 않았다. 각 입력벡터 $x_t$는 이전 입력으로부터의 pen offset을 정의하는 실수쌍 $x_1, x_2$로 구성되며, 벡터가 stroke로 끝나면(다음 벡터가 기록되기 전에 펜이 보드에서 떨어지면) 1, 아니면 0의 값을 갖는 이진값 $x_3$로 구성된다.<br />
이변수 혼합 가우시안(A mixture of bivariate Gaussians)이 $x_1, x_2$를 베르누이 분포가 $x_3$을 예측한다.</p>

<p>각 출력벡터 $y_t$는 stroke로 끝날 확률 $e$, 평균 $\mu^j$, 표준편차 $\sigma^j$, 상관계수 $\rho^j$, $M$ mixture components에 대한 혼합가중치 $\pi^j$로 구성된다.</p>

<script type="math/tex; mode=display">x_t \in \mathbb{R} \times \mathbb{R} \times \{0, 1\}</script>

<script type="math/tex; mode=display">y_t = \Big( e_t, \{ \pi_t^j, \mu_t^j, \sigma_t^j, \rho_t^j \}_{j=1}^M \Big)</script>

<p>평균과 표준편차는 2차원 벡터이고 나머지는 스칼라이다. 벡터 $y_t$는 네트워크 출력값 $\hat{y}_t$로부터 얻어지며,</p>

<script type="math/tex; mode=display">\hat{y}_t = \Big( \hat{e}_t, \{ \hat{w}_t^j, \mu_t^j, \sigma_t^j, \rho_t^j \}_{j=1}^M \Big) = b_y + \sum_{n=1}^N W_{h^ny}h_t^n</script>

<p>이다.</p>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/08.png" width="100%" alt="Mixture Density" /></center>

<p>이 density map에서 두 종류의 예측을 볼 수 있다:</p>

<ul>
  <li>글자를 따라 존재하는 작은 점들(지금 써지고 있는 stroke를 예측)</li>
  <li>세 개의 큰 원(다음 stroke의 시작점이 되는, stroke의 끝을 예측)</li>
</ul>

<p>끝획(end-of-stroke)는 더 큰 분산을 갖는데 이는 화이트보드에서 펜이 떨어졌을 때 그 위치가 기록되지 않기 때문이며, 따라서 다음 stroke와의 거리가 커질 수 있다.</p>

<p>아래쪽 열지도는 갈은 sequence에서 misture component weights를 보여준다.</p>

<h3 id="42-실험experiments">4.2 실험(Experiments)</h3>

<p>네트워크는 RMSProp을 사용하였으며 가중치 업데이트 식은 다음과 갈다.</p>

<p><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/09.png" width="70%" alt="Equations" /></p>

<p>손글씨 예측 결과는 다음과 같다.</p>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/10.png" width="100%" alt="Handwriting Results" /></center>

<hr />

<h2 id="5-손글씨-합성handwriting-synthesis">5. 손글씨 합성(Handwriting Synthesis)</h2>

<p>손글씨 합성은 sequence가 매우 다른 길이를 가질 수 있고 그 사이의 alignment는 데이터가 생성되기 전까지 알려지지 않는다는 점에서 어렵다. 이는 각 글자가 필체, 크기, 펜 속도 등에 따라 매우 달라지기 때문이다.</p>

<p>연속적인 예측을 할 수 있는 한 신경망 모델은 RNN transducer이다. 그러나 이전 연구 결과들은 만족스럽지 못하다.</p>

<h3 id="51-합성-네트워크synthesis-network">5.1. 합성 네트워크(Synthesis Network)</h3>

<p>네트워크 구조는 다음과 같다.</p>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/11.png" width="100%" alt="Architecture" /></center>

<p>길이 $U$의 글자 sequence $c$가 주어지고 길이 $T$의 data sequence $x$가 주어졌을 때, 시간 $t(1\le t \le T)$에서 $c$로의 soft window $w_t$는 $K$ Gaussian 함수의 혼합에 의해 정의된다:</p>

<script type="math/tex; mode=display">\phi(t, u) = \sum_{k=1}^K \alpha_t^k \text{exp} \Big( - \beta_t^k (\kappa_t^k - u)^2 \Big)</script>

<script type="math/tex; mode=display">w_t = \sum_{u=1}^U \phi(t, u)c_u</script>

<p>$\phi(t, u)$는 시간 $t$에서 $c_u$의 window weight이고, $\kappa_t$는 window의 위치를 제어하며, $\beta_t$는 window의 너비를, $\alpha_t$는 혼합 내에서 window의 중요도를 제어한다.</p>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/12.png" width="100%" alt="Window" /></center>

<h3 id="52-실험experiments">5.2. 실험(Experiments)</h3>

<p>실험은 이전 section과 동일한 입력 데이터를 사용한다. IAM-OnDB는 이제 글자 sequence $c$를 정의한다.</p>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/13.png" width="100%" alt="Synthesis Results" /></center>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/14.png" width="100%" alt="Synthesis Results" /></center>

<h3 id="5355-samplingunbiased-biased-prime-sampling">5.3~5.5 Sampling(Unbiased, Biased, Prime Sampling)</h3>

<p>Bias를 다르게 하는 등의 변형을 거쳐 손글씨를 합성한 결과를 몇 개 가져왔다.</p>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/15.png" width="100%" alt="Synthesis Results" /></center>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/16.png" width="100%" alt="Synthesis Results" /></center>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/17.png" width="100%" alt="Synthesis Results" /></center>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/18.png" width="100%" alt="Synthesis Results" /></center>

<center><img src="/public/img/2019-07-15-Generating Sequences WIth Recurrent Neural Networks/19.png" width="100%" alt="Synthesis Results" /></center>

<h2 id="refenrences">Refenrences</h2>

<p>논문 참조. 33개의 레퍼런스가 있다.</p>

<hr />


    </article>
    <div class="post-more">
      
      <a href="/Generating-Sequences-WIth-Recurrent-Neural-Networks/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/Generating-Sequences-WIth-Recurrent-Neural-Networks/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/blog/page6">Older</a>
  
  
    
      <a class="pagination-item newer" href="/blog/page4">Newer</a>
    
  
</div>


  </div>
</div>

<label for="sidebar-checkbox" class="sidebar-toggle"></label>

<script>
  (function (document) {
    let toggle = document.querySelector('.sidebar-toggle');
    let sidebar = document.querySelector('#sidebar');
    let checkbox = document.querySelector('#sidebar-checkbox');

    document.addEventListener('click', function (e) {
      let target = e.target;

      if (target === toggle) {
        checkbox.checked = !checkbox.checked;
        e.preventDefault();
      } else if (checkbox.checked && !sidebar.contains(target)) {
        /* click outside the sidebar when sidebar is open */
        checkbox.checked = false;
      }
    }, false);
  })(document);
</script>

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    };
    i[r].l = 1 * new Date();
    a = s.createElement(o);
    m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

  ga('create', 'UA-00000000-1', 'auto');
  ga('send', 'pageview');
</script>


<!-- Naver Analytics -->	
<script type="text/javascript" src="//wcs.naver.net/wcslog.js"></script>
<script type="text/javascript">
  if(!wcs_add) var wcs_add = {};
    wcs_add["wa"] = "18cbce78e94161";
  wcs_do();
</script>

</body>

<script id="dsq-count-scr" src="//greeksharifa-github-io.disqus.com/count.js" async></script>

</html>
