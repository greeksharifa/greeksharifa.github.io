<!DOCTYPE html>
<html lang="en-us">
<head>
  <head>
  <!-- Description of Blog -->
  <meta name="description" content="Python, Machine & Deep Learning">
  <link rel="canonical" href="https://greeksharifa.github.io/">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Python, Machine & Deep Learning">
  <meta property="og:description" content="Python, Machine Learning & Deep Learning 설명서">
  <meta property="og:image" content="https://greeksharifa.github.io/public/img/icon-144x144.png">
  <meta property="og:url" content="https://greeksharifa.github.io/">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Python, Machine & Deep Learning">
  <meta name="twitter:description" content="Python, Machine Learning & Deep Learning 설명서">
  <meta name="twitter:image" content="https://greeksharifa.github.io/public/img/icon-144x144.png">
  <meta name="twitter:domain" content="https://greeksharifa.github.io/">

  <!-- link -->
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/main.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="icon-144x144" sizes="144x144" href="/public/img/icon-144x144.png">
  <link rel="shortcut icon" href="/public/img/icon_32x32.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"> </script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });
  </script>
  

  <!-- Ads -->
  <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
  </script>
</head>

  <!-- for Google AdSense-->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-9951774327887666",
    enable_page_level_ads: true
  });
</script>

  <style>blockquote {
    font-size: 1em;
    line-height: 1.4
  }</style>
  <link href='http://fonts.googleapis.com/css?family=Gill+Sans' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Consolas' rel='stylesheet' type='text/css'>
</head>
<body>

<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <div class="sidebar-personal-info">
      <div class="sidebar-personal-info-section">
        <a href="http://gravatar.com/3c2986ad7ac1f2230ea3596f44563328">
          <img src="/public/img/maple_tree.jpg" title="Cover Photo" alt="Maple tree" />
        </a>
      </div>
      <div class="sidebar-personal-info-section">
        <p><strong>Developer and Analyst</strong>, YW & YY.</p>
      </div>
      
      
      
      <div class="sidebar-personal-info-section">
        <p> Follow me:
        
        
        
        <a href="https://github.com/greeksharifa">
          <i class="fa fa-github" aria-hidden="true"></i>
        </a>
        
        |
        
        
        
        <a href="mailto:greeksharifa@gmail.com">
          <i class="fa fa-envelope" aria-hidden="true"></i>
        </a>
        
        
        
        </p>
      </div>
      
    </div>
  </div>

  <nav class="sidebar-nav">
    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/">
          Home
        </a>

        
      </span>

    
      
      
      

      

      <span class="foldable">
        <a class="sidebar-nav-item " href="/blog/">
          Blog
        </a>

        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/categories/">
                Categories
              </a>
          
        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/tags/">
                Tags
              </a>
          
        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/about/">
          About
        </a>

        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="http://greeksharifa.github.io/">
          Github Project
        </a>

        
      </span>

    

  </nav>

  <div class="sidebar-item">
    <p>
    &copy; 2020 YW & YY. This work is liscensed under <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a>.
    </p>
  </div>

  <div class="sidebar-item">
    <p>
    Powered by <a href="http://jekyllrb.com">jekyll</a> and <a href="http://greeksharifa.github.io">YW & YY</a>
    </p>
  </div>
</div>


<!-- Wrap is the content to shift when toggling the sidebar. We wrap the
     content to avoid any CSS collisions with our real content. -->
<div class="wrap">
  <div class="masthead">
    <div class="container">
      <h3 class="masthead-title" align="center">
        <a href="/" title="Home" title="YW & YY">
          <img class="masthead-logo" src="/public/img/logo.png"/>
        </a>
        <small>YW & YY's Python, Machine & Deep Learning</small>
        <!-- HTML elements for search -->
        <a href="/search/" id="search_icon">
          <img src="/public/img/search.png" width="25" height="25"
               align="right" style="margin-top:5px; margin-bottom:0;"
               onmouseover="this.style.opacity=0.7" onmouseout="this.style.opacity=0.5"
               alt="search">
        </a>
      </h3>
    </div>
  </div>

  <div class="container content">
    <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/LSTM1/">
        LSTM1
      </a>
    </h1>

    <span class="post-date">30 Jul 2018</span>
     |
    
    <a href="/blog/tags/#keras" class="post-tag">Keras</a>
    
    <a href="/blog/tags/#lstm" class="post-tag">LSTM</a>
    
    <a href="/blog/tags/#time-series" class="post-tag">Time Series</a>
    
    

    <article>
      <h2 id="basic-lstm-with-airplane-passengers-data">Basic LSTM with Airplane Passengers Data</h2>
<blockquote>
  <p>본 포스트는 시계열 데이터를 예측하는 가장 기본적인 LSTM에 대해 다룬다.<br />
코드는 “코딩셰프의 3분 딥러닝 케라스맛” (김성진 저)를 토대로 하였음을 밝힌다.</p>
</blockquote>

<h3 id="setting">Setting</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">path</span> <span class="o">=</span> <span class="s">"Your path"</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="n">sns</span>

<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">LSTM</span><span class="p">,</span> <span class="n">Dense</span>
<span class="kn">from</span> <span class="nn">keras</span> <span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">kerasapp</span> <span class="kn">import</span> <span class="n">skeras</span>
</code></pre></div></div>

<h3 id="데이터셋-준비">데이터셋 준비</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Dataset</span><span class="p">:</span>
    <span class="s">"""
    Arguments: D -- 시계열 단위 길이
    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">path</span> <span class="o">+</span> <span class="s">"/airplane.csv"</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
        <span class="n">data_dn</span> <span class="o">=</span> <span class="n">load_data</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">edit_data</span><span class="p">(</span><span class="n">data_dn</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>
        <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
          <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># 결과를 멤버 변수에 저장
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">X_train</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">X_test</span> <span class="o">=</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">y_train</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">y_test</span> <span class="o">=</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span>


<span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="n">path</span> <span class="o">+</span> <span class="s">"/airplane.csv"</span><span class="p">):</span>
    <span class="c1"># skipfooter: Number of lines at bottom of file to skip
</span>    <span class="c1"># 데이터 시트 중 승객 수에 해당하는 1번째 열만 로드
</span>    <span class="n">dataset</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">engine</span><span class="o">=</span><span class="s">'python'</span><span class="p">,</span> <span class="n">skipfooter</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># DataFrame에서 np.array로 바꿔줌: shape = (144, )
</span>    <span class="n">data</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Data Normalize
</span>    <span class="n">data_dn</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="mi">5</span>
    <span class="k">return</span> <span class="n">data_dn</span>


<span class="k">def</span> <span class="nf">edit_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="c1"># D개의 샘플 만큼의 시계열 데이터를 한 칸씩 옮겨 가면서
</span>    <span class="c1"># 시계열 벡터를 생성함
</span>    <span class="c1"># 레이블(y)은 D+1 샘플의 값임
</span>    <span class="n">X_l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y_l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="n">D</span><span class="p">,</span> <span class="s">"N should be larger than D, where N is len(data)"</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">D</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">X_l</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span><span class="o">+</span><span class="n">D</span><span class="p">])</span>
        <span class="n">y_l</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">D</span><span class="p">])</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">X_l</span><span class="p">)</span>    <span class="c1"># X.shape = (131, 12)
</span>    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>    <span class="c1"># X.shape = (131, 12, 1)
</span>    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_l</span><span class="p">)</span>    <span class="c1"># y.shape = (131, 1)
</span>    <span class="k">print</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span>
</code></pre></div></div>
<p>먼저 <strong>load_data</strong> 함수는 데이터를 불러온 뒤, 정규화를 실행한다.<br />
<strong>edit_data</strong> 함수는 feed할 데이터를 정제하는데, 한 칸 씩 옮겨가면서 데이터를 생성하게 된다.<br />
이를 바탕으로 <strong>Dataset</strong> 클래스에서 트레이닝셋과 테스트셋을 나누게 된다.</p>

<h3 id="model-compiling">Model Compiling</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">rnn_model</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">m_x</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>    <span class="c1"># shape = X.shape[1: ]
</span>    <span class="n">m_h</span> <span class="o">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">10</span><span class="p">)(</span><span class="n">m_x</span><span class="p">)</span>
    <span class="n">m_y</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">1</span><span class="p">)(</span><span class="n">m_h</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">(</span><span class="n">m_x</span><span class="p">,</span> <span class="n">m_y</span><span class="p">)</span>

    <span class="n">model</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s">"adam"</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s">"mean_squared_error"</span><span class="p">)</span>
    <span class="n">model</span><span class="p">.</span><span class="n">summary</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">model</span>
</code></pre></div></div>
<p>모델은 간단한 LSTM이다. shape은 X_train의 1개 example의 shape이다.</p>

<h3 id="종합">종합</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Machine</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">()</span>

        <span class="c1"># example 수 빼고 나머지를 shape 기준으로 설정
</span>        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span> <span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">rnn_model</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">400</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">data</span>
        <span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">X_train</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">X_test</span>
        <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">y_train</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">y_test</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">y</span>
        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">model</span>

        <span class="n">history</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">epochs</span><span class="p">,</span>
                            <span class="n">validation_data</span><span class="o">=</span><span class="p">[</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">skeras</span><span class="p">.</span><span class="n">plot_loss</span><span class="p">(</span><span class="n">history</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">"History of training"</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">prediction</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Loss: "</span><span class="p">,</span> <span class="n">model</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'Original'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">"Prediction"</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Validation Results"</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">prediction</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Loss: "</span><span class="p">,</span> <span class="n">model</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="n">prediction</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">y_test</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># 목표 결과와 예측 결과의 순서를 표시하는 칼럼: Sample
</span>        <span class="c1"># 0 ~ len(y_test)-1까지 2번 반복되는데,
</span>        <span class="c1"># 첫 번째는 목표 결과의 순서 / 두 번째는 예측 결과의 순서임
</span>        <span class="n">df</span><span class="p">[</span><span class="s">'Sample'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_test</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="c1"># 실제 목표 결과와 예측 결과를 순서대로 결합
</span>        <span class="n">df</span><span class="p">[</span><span class="s">'Normalized # of Passengers'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">y_test</span><span class="p">,</span> <span class="n">prediction</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># 정보 표시 (문자열)
</span>        <span class="n">df</span><span class="p">[</span><span class="s">'Type'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">'Original'</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_test</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s">'Prediction'</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">prediction</span><span class="p">)</span>

        <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="n">sns</span><span class="p">.</span><span class="n">barplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s">"Sample"</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s">"Normalized # of Passengers"</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s">"Type"</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">"Normalized # of Passengers"</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Training Data와 Validation Data를 합쳐서 시각화
</span>        <span class="n">prediction</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'Prediction'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">"Original"</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">"All Results"</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p>중간에 matplotlib과 seaborn을 이용하여 결과를 시각화하도록 설계한 것 외에는<br />
크게 특별한 것은 없는 코드이다.<br />
끝 부분에 새로운 데이터프레임을 생성하여 barplot을 그리는 것을 눈여겨 봐두면 좋다.<br />
결과 요약에 큰 도움이 되기 때문이다.</p>

<h3 id="run-code">Run Code</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="n">Machine</span><span class="p">()</span>
    <span class="n">machine</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>

<span class="c1"># Run Code
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>코드를 돌리면 다음과 같은 그래프들을 얻을 수 있다.</p>
<center><img src="/public/img/Deep_Learning/2018-07-30-LSTM1/05.PNG" width="60%" /></center>
<center><img src="/public/img/Deep_Learning/2018-07-30-LSTM1/01.PNG" width="50%" /></center>
<center><img src="/public/img/Deep_Learning/2018-07-30-LSTM1/02.PNG" width="50%" /></center>
<center><img src="/public/img/Deep_Learning/2018-07-30-LSTM1/03.PNG" width="50%" /></center>
<center><img src="/public/img/Deep_Learning/2018-07-30-LSTM1/04.PNG" width="50%" /></center>

    </article>
    <div class="post-more">
      
      <a href="/LSTM1/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/LSTM1/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/regex-usage-04-intermediate/">
        파이썬 정규표현식(re) 사용법 - 04. 그룹, 캡처
      </a>
    </h1>

    <span class="post-date">28 Jul 2018</span>
     |
    
    <a href="/blog/tags/#regex" class="post-tag">Regex</a>
    
    <a href="/blog/tags/#re" class="post-tag">re</a>
    
    

    <article>
      <hr />

<p><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/20/regex-usage-01-basic/">파이썬 정규표현식(re) 사용법 - 01. Basic</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/21/regex-usage-02-basic/">파이썬 정규표현식(re) 사용법 - 02. 문자, 경계, flags</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/22/regex-usage-03-basic/">파이썬 정규표현식(re) 사용법 - 03. OR, 반복</a><br />
<strong><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/28/regex-usage-04-intermediate/">파이썬 정규표현식(re) 사용법 - 04. 그룹, 캡처</a></strong><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/04/regex-usage-05-intermediate/">파이썬 정규표현식(re) 사용법 - 05. 주석, 치환, 분리</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/05/regex-usage-06-advanced/">파이썬 정규표현식(re) 사용법 - 06. 치환 함수, 양방탐색, 조건문</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/06/regex-usage-07-example/">파이썬 정규표현식(re) 사용법 - 07. 예제(숫자)</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/06/regex-usage-08-example/">파이썬 정규표현식(re) 사용법 - 08. 예제(단어, 행)</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/24/regex-usage-09-other-functions/">파이썬 정규표현식(re) 사용법 - 09. 기타 기능</a></p>

<hr />

<p>이 글에서는 정규표현식 중급 기술과 python library인 <code class="highlighter-rouge">re</code> 패키지 사용법에 대해서 설명한다.</p>

<p>본 글에서 정규표현식은 <code class="highlighter-rouge">regex</code>와 같이, 일반 문자열은 ‘regex’와 같이 표시하도록 한다.</p>

<p>파이썬 버전은 3.6을 기준으로 하나, 3.x 버전이면 (아마) 동일하게 쓸 수 있다.<br />
2.7 버전은 한글을 포함한 비 알파벳 문자 처리가 다르다.</p>

<hr />

<h2 id="정규표현식의-중급-그룹-캡처---">정규표현식의 중급: 그룹, 캡처 = ( )</h2>

<p>소괄호 <code class="highlighter-rouge">( )</code>에는 중요한 기능이 두 가지 있다. 그룹화와 캡처인데, 정규식의 여러 문자를 그룹으로 묶어주는 것과 정규식의 일부분에 해당하는 문자열에만 관심이 있을 때 그 부분을 따로 빼서 캡처하는 기능이다.<br />
여담으로 그룹화는 기초 과정이지만 캡처와 더불어 중급 과정에 넣었다.</p>

<h3 id="그룹화">그룹화</h3>

<p>그룹화는 말 그대로 그룹으로 묶어주는 것이다. 지금까지의 글에서는 정규식 메타문자들의 효력은 대개 한 문자에만 적용이 되었다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'12+'</span><span class="p">,</span> <span class="s">'12 1212 1222'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['12', '12', '12', '1222']
</code></pre></div></div>
<p>‘1212’와 같은 문자열을 찾고 싶었는데, ‘12’ 혹은 ‘1222’만 찾아진다. 즉 메타문자 <code class="highlighter-rouge">+</code>는 <code class="highlighter-rouge">2</code>에만 적용이 된 것이다. 이를 <code class="highlighter-rouge">12</code> 모두에 적용시키려면 소괄호 <code class="highlighter-rouge">( )</code>로 그룹화시켜주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="s">'(12)+'</span><span class="p">,</span> <span class="s">'1212'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'(12)+'</span><span class="p">,</span> <span class="s">'1212'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'(12)+'</span><span class="p">,</span> <span class="s">'1212'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s">'(12)+'</span><span class="p">,</span> <span class="s">'1212'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(0, 4), match='1212'&gt;
&lt;_sre.SRE_Match object; span=(0, 4), match='1212'&gt;
['12']
&lt;_sre.SRE_Match object; span=(0, 4), match='1212'&gt;
</code></pre></div></div>
<p>정규식은 항상 최대로 일치시키는 쪽으로 문자열은 탐색하기 때문에, ‘12’가 아닌 ‘1212’를 잘 찾았다. 그런데 한 가지 이상한 결과는 <strong>re.findall</strong> 결과이다.</p>

<p>다른 예시를 한번 보자.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'A(12)+B'</span><span class="p">,</span> <span class="s">'A12B'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'A(12)+B'</span><span class="p">,</span> <span class="s">'A1212B'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'A(12)+B'</span><span class="p">,</span> <span class="s">'A121212B'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'A(12)+B'</span><span class="p">,</span> <span class="s">'A12121212B'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['12']
['12']
['12']
['12']
</code></pre></div></div>
<p>‘A’와 ‘B’를 통해 문자열 전체가 정규식과 일치된 것을 확인할 수 있으나, ‘12’가 몇 개인지에 관계없이 딱 ‘12’만 일치되어 결과로 반환되었다. 이는 괄호가 가진 다른 기능인 캡처 때문이다.</p>

<h3 id="캡처">캡처</h3>

<p>캡처란 원하는 부분만을 추출하고 싶을 때 사용하는 것이다. 예를 들어 ‘yyyy-mm-dd’와 같이 날짜를 나타내는 문자열 중 월, 일을 각각 따로 빼서 쓰고 싶다고 하자.<br />
그러면 따로 빼고 싶은 부분인 ‘mm’과 ‘dd’ 부분에만 소괄호의 캡처 기능을 사용하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'\d{4}-(\d\d)-(\d\d)'</span><span class="p">,</span> <span class="s">'2028-07-28'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'\d{4}-(\d\d)-(\d\d)'</span><span class="p">,</span> <span class="s">'1999/05/21 2018-07-28 2018-06-31 2019.01.01'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[('07', '28')]
[('07', '28'), ('06', '31')]
</code></pre></div></div>
<p>월과 일에 해당하는 부분만 따로 빠졌음을 알 수 있다. 그리고 날짜 형식이 맞지 않는 경우에는 아예 캡처되지 않았음을 확인할 수 있다.</p>

<p>여기서 한 가지 문제점은, 6월 31일은 존재하지 않는 날짜란 점이다. 위의 정규식은 숫자로만 처리를 했기 때문에 ‘9999-99-99’도 일치된다는 문제가 있다. 이러한 문제를 해결하는 방법은 함수를 정규식에 쓰는 것인데, 이 방법에 대해서는 <a href="https://greeksharifa.github.io/references/2018/07/13/it-will-update-soon/">나중</a>에 알아보도록 한다.</p>

<h3 id="matchobjgroups">matchObj.groups()</h3>

<p>여러분은 <a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/20/regex-usage-01-basic/">첫 번째 글</a>에서 다음 예시를 보았을 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'match'</span><span class="p">,</span> <span class="s">"'matchObj' is a good name, but 'm' is convenient."</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">start</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">span</span><span class="p">())</span>
<span class="c1"># matchObj를 오랜만에 가져와 보았다. 캡처를 잘 쓰기 위해서는 matchObj가 필요하다.
</span></code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(1, 6), match='match'&gt;
match
1
6
(1, 6)
</code></pre></div></div>

<p>이제 정규식을 캡처를 포함한 식으로 바꿔보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'match'</span><span class="p">,</span> <span class="s">"'matchObj' is a good name, but 'm' is convenient."</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">groups</span><span class="p">())</span>

<span class="k">print</span><span class="p">(</span><span class="s">'# ---------------------------------------------------------------- #'</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'\d{4}-(\d?\d)-(\d?\d)'</span><span class="p">,</span> <span class="s">'1868-12-10'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">groups</span><span class="p">())</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(1, 6), match='match'&gt;
match
()
# ---------------------------------------------------------------- #
&lt;_sre.SRE_Match object; span=(0, 10), match='1868-12-10'&gt;
1868-12-10
('12', '10')
</code></pre></div></div>
<p>matchObj의 <strong>group</strong> 메서드는 정규식 전체의 일치부를 찾는다. 반면에 <strong>groups</strong> 메서드는 명시적으로 캡처(<code class="highlighter-rouge">( )</code>로 감싼 부분)한 부분을 반환한다.</p>

<p>위의 matchObj는 캡처 구문이 없기 때문에 <strong>groups</strong> 결과가 빈 튜플이 되는 것이다.<br />
반면 m의 경우 월과 일에 해당하는 부분을 반환하였다.</p>

<p><strong>group</strong>과 <strong>groups</strong>의 사용법을 좀 더 보도록 하자.</p>

<p><img src="\public\img\정규표현식(re)\2018-07-20-regex-usage-04-intermediate\01_group.PNG" alt="01" /></p>

<p><img src="\public\img\정규표현식(re)\2018-07-20-regex-usage-04-intermediate\02_groups.PNG" width="75%" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'\d{4}-(\d?\d)-(\d?\d)'</span><span class="p">,</span> <span class="s">'1868-12-10'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'m:'</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'m.group():'</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'m.group({}): {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>

<span class="k">print</span><span class="p">(</span><span class="s">'m.groups():'</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">groups</span><span class="p">())</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m: &lt;_sre.SRE_Match object; span=(0, 10), match='1868-12-10'&gt;
m.group(): 1868-12-10
m.group(0): 1868-12-10
m.group(1): 12
m.group(2): 10
m.groups(): ('12', '10')
</code></pre></div></div>
<p>결과를 보면 대략 사용법을 알 수 있을 것이다.</p>

<ol>
  <li>group(i)는 i번째 소괄호에 명시적으로 캡처된 부분만을 반환한다.</li>
  <li>group(0)은 전체 일치부를 반환하며, group()과 효과가 같다.</li>
  <li>groups()는 명시적으로 캡처된 모든 부분 문자열을 반환한다.</li>
</ol>

<p>i번째 캡처된 부분은, i번째 여는 괄호와 대응된다고 생각하면 된다. 캡처를 중첩해서 사용하는 경우<code class="highlighter-rouge">((12)+)</code>, 첫 번째 캡처는 바깥쪽 소괄호이다.</p>

<p>주의할 점은 group(0)이 0번째 캡처를 의미하는 것이 아니라 전체 일치부를 반환한다는 것이다.</p>

<hr />

<h3 id="비-캡처-그룹">비 캡처 그룹</h3>

<p>그룹화를 위해 소괄호를 반드시 써야 하는데, 굳이 캡처하고 싶지는 않을 때가 있다. 예를 들어 다음과 같이 쓴다고 하자.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'((ab)+), ((123)+) is repetitive\.'</span><span class="p">,</span> <span class="s">'Hmm... ababab, 123123 is repetitive.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># don't want
</span><span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> 
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="c1"># don't want
</span></code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ababab, 123123 is repetitive.
ababab
ab
123123
123
</code></pre></div></div>
<p>캡처 기능을 사용할 때 위의 ‘ababab’, ‘123123’을 얻고 싶을 뿐 ‘ab’나 ‘123’을 얻고 싶지는 않을 때가 있다. 그러나 소괄호는 기본적으로 캡처 기능을 갖고 있기 때문에 group(2)에는 ‘123123’ 대신 ‘ab’가 들어가 있다.<br />
이는 원하는 결과가 아닐 때가 많다. 그래서 정규표현식은 비 캡처 기능을 지원한다.</p>

<p>비 캡처 그룹은 <code class="highlighter-rouge">(?:&lt;regex&gt;)</code>와 같이 사용한다. 위의 예시를 다시 써 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'((?:ab)+), ((?:123)+) is repetitive\.'</span><span class="p">,</span> <span class="s">'Hmm... ababab, 123123 is repetitive.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ababab, 123123 is repetitive.
ababab
123123
</code></pre></div></div>
<p>예상대로 동작하였다.</p>

<p>비 캡처 그룹의 장점은 캡처 그룹의 번호를 이상하게 만들지 않게 할 수 있다는 것과, 쓸데없는 캡처 그룹을 <strong>group</strong>의 반환값에 집어넣지 않게 되므로 성능상의 이점이 있다.<br />
그러나 성능 향상은 보통 상황이라면 체감하기 어려울 정도이긴 하다.</p>

<p>참고로 <a href="">모드 변경자</a>나 비 캡처 그룹처럼 여는 소괄호 뒤에 <code class="highlighter-rouge">?</code>가 있으면, <a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/22/regex-usage-03-basic/#--0%ED%9A%8C-%EB%98%90%EB%8A%94-1%ED%9A%8C-%EB%B0%98%EB%B3%B5">0회 또는 1회 반복</a>이나 기타 다른 의미가 아닌 특별한 기능을 하는 토큰이 된다. 앞으로 이러한 토큰들을 여럿 볼 수 있을 것이다.</p>

<h4 id="모드-변경자가-있는-그룹">모드 변경자가 있는 그룹</h4>

<p><a href="">여기</a>에서 (?s)와 같은 모드 변경자를 본 적이 있을 것이다.</p>

<p>이러한 모드 변경자는 소괄호를 쓰긴 하지만 캡처 그룹으로 작동하지 않는다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'case sensitive(?i) irrelevant'</span><span class="p">,</span> <span class="s">'case sensitive IrreLEVant'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case sensitive IrreLEVant
Traceback (most recent call last):
  File "&lt;input&gt;", line 3, in &lt;module&gt;
IndexError: no such group
</code></pre></div></div>

<hr />

<h3 id="-숫자-앞서-일치된-문자열을-다시-비교">\ (숫자): 앞서 일치된 문자열을 다시 비교</h3>

<p>앞뒤가 똑같은 세 글자 단어를 찾는다고 해보자. 이를 위해서는 조금 전 살펴본 캡처가 꼭 필요하다.</p>

<p>i번째 캡처된 문자열은 <strong>group(i)</strong> 메서드를 통해 접근할 수 있다고 하였다. 그런데 그건 matchObj을 얻은 후의 얘기고, 정규식 내에서는 다른 방법을 쓴다. 바로 <code class="highlighter-rouge">\(숫자)</code>이다. 예를 들면 <code class="highlighter-rouge">\1</code>, <code class="highlighter-rouge">\2</code>, …이다.<br />
이를 재참조부라 한다.</p>

<p>아마 그럴 리는 없겠지만 재참조부가 10개 이상인 경우 그냥 두 자리 수를 쓰면 된다. <code class="highlighter-rouge">\10</code>, <code class="highlighter-rouge">\11</code>, …</p>

<p><code class="highlighter-rouge">\b</code>와 마찬가지로 <code class="highlighter-rouge">\1</code>과 같은 문법을 쓸 때에는 앞에 <strong>r prefix</strong>를 붙여 주어야 한다.</p>

<p>우선 예시를 보자. 단어 경계는 정규식이 더 복잡해 보이므로 일부러 넣지 않았다. 분리된 단어만을 보고 싶다면, <code class="highlighter-rouge">\b</code>를 넣으면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">r'(\w)\w\1'</span><span class="p">,</span> <span class="s">'토마토 ABC aba xyxy '</span><span class="p">).</span><span class="n">group</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">r'(\w)\w\1'</span><span class="p">,</span> <span class="s">'토마토 ABC aba xyxy '</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>토마토
['토', 'a', 'x']
</code></pre></div></div>

<p>첫 번째 결과는 원하는 결과이다. 그러나 <strong>search</strong>는 하나밖에 찾지 못하므로 완벽한 답은 아니다.<br />
두 번째 결과는 원하는 결과가 아닐 것이다. 이는 <code class="highlighter-rouge">( )</code>가 들어가면 앞에서 말했듯 캡처 그룹만을 반환하기 때문이다.</p>

<p>전체를 참조하려면 여러 방법이 있지만, 세 가지를 소개한다.</p>

<p>첫 번째는 <strong>search</strong>로 하나를 찾은 다음 남은 문자열로 다시 <strong>search</strong>를 하는 것이다. 그러나 이는 괜한 코딩량이 늘어난다.</p>

<p>두 번째는 캡처를 하나 더 만드는 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">match_list</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">r'((\w)\w\2)'</span><span class="p">,</span> <span class="s">'토마토 ABC aba xyxy '</span><span class="p">)</span>

<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">match_list</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>토마토
aba
xyx
</code></pre></div></div>
<p>재참조부가 <code class="highlighter-rouge">\1</code>이 아니라 <code class="highlighter-rouge">\2</code>인 이유는, 여는 소괄호(opening parenthesis)의 순서를 잘 살펴보라. 바깥쪽 소괄호인, 전체를 감싸는 소괄호가 첫 번째 캡처 부분이다. 따라서 안쪽 <code class="highlighter-rouge">(\w)</code>가 <code class="highlighter-rouge">\2</code>에 대응된다.</p>

<p>그러나 이 방법은 나쁘지 않지만, <strong>findall</strong>로 찾기 때문에 위치를 찾아주지는 않는다는 단점이 있다.<br />
일치부의 시작/끝 위치까지 알고 싶을 때에는 <strong>finditer</strong>을 이용한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj_iter</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">finditer</span><span class="p">(</span><span class="s">r'((\w)\w\2)'</span><span class="p">,</span> <span class="s">'토마토 ABC aba xyxy '</span><span class="p">)</span>

<span class="k">for</span> <span class="n">matchObj</span> <span class="ow">in</span> <span class="n">matchObj_iter</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'string: {}, </span><span class="se">\t</span><span class="s"> start/end position={}, </span><span class="se">\t</span><span class="s"> 반복 부분: {}'</span><span class="p">.</span>
          <span class="nb">format</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">matchObj</span><span class="p">.</span><span class="n">span</span><span class="p">(),</span> <span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>string: 토마토, 	 start/end position=(0, 3), 	 반복 부분: 토
string: aba, 	 start/end position=(8, 11), 	 반복 부분: a
string: xyx, 	 start/end position=(12, 15), 	 반복 부분: x
</code></pre></div></div>

<p>참고로, 이러한 <code class="highlighter-rouge">\1</code>, <code class="highlighter-rouge">\2</code>, … 들은 비 명명 그룹이라고도 한다. 그 이유는, 바로 다음에 설명할 명명 그룹 때문이다.</p>

<h3 id="명명-그룹">명명 그룹</h3>

<p><code class="highlighter-rouge">\1</code>, <code class="highlighter-rouge">\2</code>, …는 간편하긴 하지만, 그다지 눈에 잘 들어오지는 않는다. 코딩할 때 변수명을 ‘a’, ‘b’ 같은 것으로 지어 놓으면 남이 알아보기 힘든 것과 갈다.</p>

<p>많은 프로그래밍 언어의 정규표현식은 명명 그룹 기능을 지원한다.<br />
언어마다 쓰는 방법이 다르지만, 파이썬 기준으로는 <code class="highlighter-rouge">(?P&lt;name&gt;regex)</code> 형식으로 쓴다.</p>

<p>앞 절의 내용을 이해했으면 어려운 내용이 아니다.</p>

<p>예시를 하나 보자.<br />
‘2018-07-28 2018.07.28’처럼, 형식만 다른 똑같은 날짜가 있는지를 확인하는 상황을 생각하자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span>
    <span class="s">r'(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d\d)-(?P&lt;day&gt;\d\d) (?P=year)\.(?P=month)\.(?P=day)'</span><span class="p">,</span>
    <span class="s">'2018-07-28 2018.07.28'</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">groups</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2018-07-28 2018.07.28
('2018', '07', '28')
2018
</code></pre></div></div>

<p>명명 그룹의 재참조는 <code class="highlighter-rouge">(?P=name)</code> 형식으로 쓰면 된다.</p>

<p>사실 명명 그룹과 비 명명 그룹을 섞어 쓸 수는 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span>
    <span class="s">r'(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d\d)-(?P&lt;day&gt;\d\d) (?P=year)\.\2\.\3'</span><span class="p">,</span>
    <span class="s">'2018-07-28 2018.07.28'</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2018-07-28 2018.07.28
</code></pre></div></div>
<p>하지만 기껏 가독성 높이려고 명명 그룹을 썼는데 저렇게 쓰면 가독성이 더 나빠진다. 지양하도록 하자.</p>

<p>한 가지 주의할 점은 <code class="highlighter-rouge">name</code> 부분은 <code class="highlighter-rouge">\w</code>에 일치되는 문자들로만 구성해야 한다. 그렇지 않으면 ‘invalid group name’이라는 메시지를 볼 수 있을 것이다.</p>

<hr />

<h3 id="반복-부분의-캡처">반복 부분의 캡처</h3>

<p><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/28/regex-usage-04-intermediate/#%EA%B7%B8%EB%A3%B9%ED%99%94">이 글의 앞부분</a>에서 <code class="highlighter-rouge">12</code>를 반복시키려고 <code class="highlighter-rouge">(12)+</code> 정규식을 썼는데 원치 않는 결과가 나온 것을 보았을 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'A(12)+B'</span><span class="p">,</span> <span class="s">'A121212B'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['12']
</code></pre></div></div>

<p>위의 예시처럼 문자가 한 종류(12)로 정해져 있으면 그냥 전체에다 캡처 그룹을 하나 더 만드는 것으로 해결 가능하지만, 정해진 것이 아닌 문자 집합 같은 것이라면 꽤 어려워진다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">r'\b(\d\d)+\b'</span><span class="p">,</span> <span class="s">'1, 25, 301, 4000, 55555'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['25', '00']
</code></pre></div></div>

<p>위의 예시는 길이가 짝수인 정수를 찾고 싶은 것이다.<br />
그러나 ‘4000’ 대신 ‘00’을 찾고 싶은 사람은 별로 없을 것 같다.</p>

<p>이를 캡처 그룹으로 한번에 묶어내는 우아한 방법은 없지만, 다른 괜찮은 해결 방법은 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj_iter</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">finditer</span><span class="p">(</span><span class="s">r'\b(\d\d)+\b'</span><span class="p">,</span> <span class="s">'1, 25, 301, 4000, 55555'</span><span class="p">)</span>

<span class="k">for</span> <span class="n">matchObj</span> <span class="ow">in</span> <span class="n">matchObj_iter</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>25
4000
</code></pre></div></div>

<p>stackoverflow에서 찾은 답변 중에는 패턴을 expand하거나 일치하는 부분만 잘라낸 다음 추가 처리를 하라는 답변이 있었는데, 그런 것보다는 위의 방법이 더 깔끔한 것 같다.</p>

<hr />

<p><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/04/regex-usage-05-intermediate/">다음 글</a>에서는 주석, 치환, 컴파일 등을 살펴보도록 한다.</p>

    </article>
    <div class="post-more">
      
      <a href="/regex-usage-04-intermediate/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/regex-usage-04-intermediate/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/Text_Generation/">
        Text_Generation
      </a>
    </h1>

    <span class="post-date">28 Jul 2018</span>
     |
    
    <a href="/blog/tags/#keras" class="post-tag">Keras</a>
    
    <a href="/blog/tags/#lstm" class="post-tag">LSTM</a>
    
    <a href="/blog/tags/#text" class="post-tag">Text</a>
    
    <a href="/blog/tags/#generation" class="post-tag">Generation</a>
    
    

    <article>
      <h2 id="text-generation-with-lstm">Text Generation with LSTM</h2>

<blockquote>
  <p>본 포스트는 https://github.com/keras-team/keras/blob/master/examples/lstm_text_generation.py<br />
의 코드를 전부를 이용한 것이며, 코드의 해석과 사용 방법을 설명하는 데에<br />
주안점을 둔 것임을 밝힌다.</p>
</blockquote>

<h3 id="setting">Setting</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">keras.callbacks</span> <span class="kn">import</span> <span class="n">LambdaCallback</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Sequential</span>
<span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Activation</span>
<span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">LSTM</span>
<span class="kn">from</span> <span class="nn">keras.optimizers</span> <span class="kn">import</span> <span class="n">RMSprop</span>
<span class="kn">from</span> <span class="nn">keras.utils.data_utils</span> <span class="kn">import</span> <span class="n">get_file</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">load_model</span>
</code></pre></div></div>
<p>참고로 새로운 텍스트를 Feed할 때에는 Corpus의 크기가 적어도 10만 문자는 되어야 하며<br />
100만에 달하는 것이 가장 이상적이라고 본문에 적혀있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">path</span> <span class="o">=</span> <span class="n">get_file</span><span class="p">(</span><span class="s">'nietzsche.txt'</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s">'https://s3.amazonaws.com/text-datasets/nietzsche.txt'</span><span class="p">)</span>
<span class="k">with</span> <span class="n">io</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">lower</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s">'corpus length:'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
<span class="n">corpus</span> <span class="n">length</span><span class="p">:</span> <span class="mi">600893</span>
</code></pre></div></div>
<p>영어 버전의 니체의 글을 이용할 것인데, 이 txt파일엔 약 60만개의 문자가 담겨 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 사용된 문자 수: 57개임
</span><span class="n">chars</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">text</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'total chars:'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">))</span>
<span class="n">total</span> <span class="n">chars</span><span class="p">:</span> <span class="mi">57</span>

<span class="c1"># 각각의 문자에 대해 위치 인자를 부여함: 0~56
</span><span class="n">char_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chars</span><span class="p">))</span>
<span class="n">indices_char</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chars</span><span class="p">))</span>
</code></pre></div></div>
<p>영어 알파벳 26개를 포함하여 이 글에는 총 57개의 문자가 사용되었는데,<br />
이를 하나의 리스트로 만들어 놓은 것이 chars이다. set(text)를 통해 중복을 제거하였다.</p>

<p>아래 <strong>char_indices</strong>와 <strong>indices_char</strong>은 방금 만든 chars의 element와 그 위치인자를<br />
딕셔너리의 형태로 정리한 것이다. 이는 이후에 Word Matrix에 대해 <strong>one-hot인코딩</strong>을<br />
할 때 편리하게 사용된다. 아래는 그 일 부를 나열한 것이다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s">' '</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'!'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'"'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="preprocessing">Preprocessing</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">maxlen</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">step</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">sentences</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">next_chars</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="n">maxlen</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
    <span class="n">sentences</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">maxlen</span><span class="p">])</span>
    <span class="n">next_chars</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">maxlen</span><span class="p">])</span>

<span class="k">print</span><span class="p">(</span><span class="s">'nb sequences:'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">))</span>
<span class="n">nb</span> <span class="n">sequences</span><span class="p">:</span> <span class="mi">200285</span>
<span class="k">print</span><span class="p">(</span><span class="n">sentences</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
<span class="p">[</span><span class="s">'preface</span><span class="se">\n\n\n</span><span class="s">supposing that truth is a woma'</span><span class="p">,</span>
<span class="s">'face</span><span class="se">\n\n\n</span><span class="s">supposing that truth is a woman--'</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">next_chars</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
<span class="p">[</span><span class="s">'n'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">,</span> <span class="s">'t'</span><span class="p">,</span> <span class="s">'h'</span><span class="p">,</span> <span class="s">'?'</span><span class="p">]</span>
</code></pre></div></div>

<p>이제부터는 LSTM의 Input형식에 맞게 데이터를 정제하는 작업이다.<br />
60만개의 문자를 단 한 번에 feed하는 것은 Sequential 데이터에 있어서는 아무 의미가<br />
없기 때문에 여기서는 40개씩 분리를 해줄 것이다. 이를 한 문장이라고 생각하면 편하다.<br />
(<strong>maxlen=40</strong>)<br />
sentences와 nex_chars란 리스트를 채워나갈 것인데,<br />
for loop를 보면, range(0, len(text)- maxlen, step)이라 되어 있다.<br />
이를 숫자로 풀어 보면, range(0, 60만-40, 3)이다.<br />
i가 0부터 시작하므로,<br />
text[0:40]을 sentences에 넣어주고, text[40]을 next_chars에 넣어준다.<br />
다음 반복 때에는 text[3: 43]을 sentences에 넣어주고, text[43]을 next_chars에 넣어준다.<br />
이렇게 형성된 sentences의 길이는 60만을 3으로 나눈 20만이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Vectorization
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">),</span> <span class="n">maxlen</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nb">bool</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">200285</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">57</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">200285</span><span class="p">,</span> <span class="mi">57</span><span class="p">)</span>
</code></pre></div></div>
<p>이제 feed할 Word Matrix를 만들 때가 되었다.<br />
np.zeros를 통해 initialize를 시켜주는데, 그 shape은 위에 보는 것과 같이<br />
200285개의 example을 두고, x의 경우 행은 40, 열은 57이다.<br />
40은 maxlen을, 57은 chars의 길이를 의미한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sentences</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sentence</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">char_indices</span><span class="p">[</span><span class="n">char</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">char_indices</span><span class="p">[</span><span class="n">next_chars</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># 예시: x[3]을 보라
</span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">[[</span> <span class="bp">True</span> <span class="bp">False</span> <span class="bp">False</span> <span class="p">...</span> <span class="bp">False</span> <span class="bp">False</span> <span class="bp">False</span><span class="p">]</span>
 <span class="p">[</span><span class="bp">False</span> <span class="bp">False</span> <span class="bp">False</span> <span class="p">...</span> <span class="bp">False</span> <span class="bp">False</span> <span class="bp">False</span><span class="p">]</span>
 <span class="p">[</span><span class="bp">False</span> <span class="bp">False</span> <span class="bp">False</span> <span class="p">...</span> <span class="bp">False</span> <span class="bp">False</span> <span class="bp">False</span><span class="p">]</span>
 <span class="p">...</span>
 <span class="p">[</span><span class="bp">False</span> <span class="bp">False</span> <span class="bp">False</span> <span class="p">...</span> <span class="bp">False</span> <span class="bp">False</span> <span class="bp">False</span><span class="p">]</span>
 <span class="p">[</span><span class="bp">False</span>  <span class="bp">True</span> <span class="bp">False</span> <span class="p">...</span> <span class="bp">False</span> <span class="bp">False</span> <span class="bp">False</span><span class="p">]</span>
 <span class="p">[</span><span class="bp">False</span> <span class="bp">False</span> <span class="bp">False</span> <span class="p">...</span> <span class="bp">False</span> <span class="bp">False</span> <span class="bp">False</span><span class="p">]]</span>
</code></pre></div></div>
<p>위에서 만든 x, y 넘파이 배열은 현재 0, 즉 False로 채워져 있다.<br />
sentences 리스트에 담겨 있는 각 문장에서 등장하는 ‘문자’의 위치에 1을 배정한다.<br />
(True로 바꿔준다.)<br />
즉 20285, 40, 57의 shape을 갖고 있는 x에서 (1, 40, 57)은 한 문장 내에서 등장하는<br />
40개의 문자를 57개의 총 문자를 기준으로 <strong>one-hot 인코딩</strong>을 한 셈이다.<br />
y의 경우는 문장 단위가 아니라 각 문자 단위로 인코딩을 해준다.</p>

<h3 id="building-model">Building Model</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Build the model: a single LSTM
</span><span class="n">model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
<span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LSTM</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="n">maxlen</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">))))</span>
<span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)))</span>  <span class="c1"># 최종 아웃풋은 길이 57의 벡터
</span><span class="n">model</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Activation</span><span class="p">(</span><span class="s">'softmax'</span><span class="p">))</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">RMSprop</span><span class="p">(</span><span class="n">lr</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">model</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s">'categorical_crossentropy'</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="sampling-function">Sampling Function</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="s">"""
    :param preds: 확률 값을 담은 np.array
    :param temperature: exp 승수의 분모
    :return:
    """</span>
    <span class="c1"># helper function to sample an index from a probability array
</span>    <span class="n">preds</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">preds</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="s">'float64'</span><span class="p">)</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span> <span class="o">/</span> <span class="n">temperature</span>
    <span class="n">exp_preds</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="n">exp_preds</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">exp_preds</span><span class="p">)</span>
    <span class="n">probas</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">multinomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">probas</span><span class="p">)</span>
</code></pre></div></div>

<p>이 사용자 함수는 처음 보기엔 구조가 복잡해보인다.<br />
다음 함수를 설명한 후에 그 구조를 설명하도록 하겠다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">on_epoch_end</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">logs</span><span class="p">):</span>
    <span class="s">"""
    LambdaCallback의 인자에 전달할 것임
    각 epoch 끝에 발동하는 함수임. Generated Text를 반환한다.
    """</span>
    <span class="k">print</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'----- Generating text after Epoch: %d'</span> <span class="o">%</span> <span class="n">epoch</span><span class="p">)</span>

    <span class="c1"># 60만개의 전체 text에서 랜덤하게 번호를 하나 뽑아 start_index를 설정
</span>    <span class="n">start_index</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="n">maxlen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">diversity</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">]:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'----- diversity:'</span><span class="p">,</span> <span class="n">diversity</span><span class="p">)</span>

        <span class="c1"># 빈 문자열을 만들고
</span>        <span class="n">generated</span> <span class="o">=</span> <span class="s">''</span>
        <span class="c1"># maxlen의 길이를 가진 text를 start_index부터 추출하여 sentence에 집어 넣는다.
</span>        <span class="n">sentence</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">maxlen</span><span class="p">]</span>
        <span class="n">generated</span> <span class="o">+=</span> <span class="n">sentence</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'----- Generating with seed: "'</span> <span class="o">+</span> <span class="n">sentence</span> <span class="o">+</span> <span class="s">'"'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">generated</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">400</span><span class="p">):</span>
            <span class="c1"># x_pred: Word Matrix
</span>            <span class="c1"># x_pred.shape: (1, 40, 57) 가로는 행은 문자열 길이,
</span>            <span class="c1"># 열은 57개의 기본 문자 종류
</span>            <span class="n">x_pred</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)))</span>

            <span class="c1"># 위와 마찬가지로 발견된 문자에 대해 one-hot 인코딩을 해준다.
</span>            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sentence</span><span class="p">):</span>
                <span class="n">x_pred</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">char_indices</span><span class="p">[</span><span class="n">char</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="c1"># x_pred를 Input으로 넣고 model이 이를 predict한 것을 preds라 한다.
</span>            <span class="c1"># 왜 [0]으로 인덱싱 했는지는 모르겠다. 안해도 똑같은 넘파이 배열이다.
</span>            <span class="c1"># preds.shape: (57, 1)
</span>            <span class="c1"># 이 preds는 다음에 생성될 문자를 결정하는 확률값을 담은 배열이다.
</span>            <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x_pred</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># 이 preds를 바탕으로 sample함수를 돌려 next_index와 next_char을 얻는다.
</span>            <span class="c1"># 이 next_index는 0 ~ len(char)-1 중 하나의 숫자를 반환함
</span>            <span class="c1"># 이 next_char은 위 next_index에 해당하는 문자이다.
</span>            <span class="n">next_index</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">diversity</span><span class="p">)</span>
            <span class="n">next_char</span> <span class="o">=</span> <span class="n">indices_char</span><span class="p">[</span><span class="n">next_index</span><span class="p">]</span>

            <span class="c1"># 이렇게 얻은 next_char은 generated의 다음 문자로 채택되어 추가된다.
</span>            <span class="c1"># 1개의 문자가 늘어나는 셈
</span>            <span class="c1"># 문장 역시 늘어나야 할 것이다.
</span>            <span class="n">generated</span> <span class="o">+=</span> <span class="n">next_char</span>
            <span class="c1"># sentence의 길이는 계속해서 maxlen으로 유지하고 제일 앞에 한 글자를 빼고
</span>            <span class="c1"># 뒤에 하나를 추가한다.
</span>            <span class="c1"># loop를 돌면서 sentence는 계속해서 뒤로 하나씩 밀리게 된다.
</span>            <span class="c1"># (context: 기준이 변경되는 것)
</span>            <span class="c1"># 이렇게 400개의 문자를 추가하고 나서 위로 올라가서
</span>            <span class="c1"># 총 diversity의 갯수(4개)만큼 반환한다.
</span>            <span class="c1"># 총 4개의 글이 반환되는 셈이다.
</span>            <span class="n">sentence</span> <span class="o">=</span> <span class="n">sentence</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">next_char</span>

            <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">next_char</span><span class="p">)</span>
            <span class="n">sys</span><span class="p">.</span><span class="n">stdout</span><span class="p">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">print</span><span class="p">()</span>
</code></pre></div></div>
<p>이 함수는 주석으로 대부분의 설명을 대체하겠다.<br />
결과적으로 이 함수는 LambdaCallback의 on_epoch_end의 인자로 그대로 전달된다.<br />
일단 위의 sample함수에 대해 설명을 하자면,<br />
리턴하는 값이 <strong>np.argmax(probas)</strong>인데, 여기서 마지막 preds는</p>

<p><script type="math/tex">preds = \frac{( e^{preds} )}{\sum e^{preds}}</script>
<script type="math/tex">= \frac{e^{\frac{log(preds)}{temperature}}}{\sum e^{\frac{log(preds)}{temperature}}}</script></p>

<p>softmax함수에서 그 확률을 구하는 과정이라고 생각하면 된다.<br />
그리고 이 preds는 np.random.multinomial(1, preds, 1)에 인자로 삽입되는데,<br />
이 preds가 이후 on_epoch_end함수에서 (57, 1)의 shape으로 만들어져 형성되기 때문에,<br />
np.random.multinomial 메서드는 57개의 확률 값을 기준으로 다항 분포 추출을 하게 된다.<br />
return 값으로는 그 중 가장 큰 index를 반환하게 된다.<br />
즉, 다음에 올 문자로 가장 높은 문자를 확률 값에 근거하여 생성하는 것이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">print_callback</span> <span class="o">=</span> <span class="n">LambdaCallback</span><span class="p">(</span><span class="n">on_epoch_end</span><span class="o">=</span><span class="n">on_epoch_end</span><span class="p">)</span>
</code></pre></div></div>

<p>Callback은 트레이닝 과정에서 given stages에 적용될 수 있다.<br />
트레이닝 중 내부의 state나 statistics를 확인할 수 있는 것이다.<br />
사용을 위해서는 Sequential이나 Model 클래스의 fit 메서드에 list of callbacks을<br />
전달해야 한다. 그러면 그 callback 방법은 트레이닝의 각 단계에서 called될 것이다.</p>

<h3 id="results">Results</h3>
<p>모델은 다음과 같이 fit한다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">model</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="n">print_callback</span><span class="p">])</span>
</code></pre></div></div>
<p>그러면 자동으로 학습이 됨과 동시에 각 epoch마다 text를 생성할 것이다.</p>

<p>다음은 모델 저장과 로드 코드이다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">niet</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="s">'Path/Nietzsche.h5'</span><span class="p">)</span>
<span class="n">niet</span> <span class="o">=</span> <span class="n">load_model</span><span class="p">(</span><span class="s">'Path/Nietzsche.h5'</span><span class="p">)</span>
</code></pre></div></div>

    </article>
    <div class="post-more">
      
      <a href="/Text_Generation/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/Text_Generation/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/regex-usage-03-basic/">
        파이썬 정규표현식(re) 사용법 - 03. OR, 반복
      </a>
    </h1>

    <span class="post-date">22 Jul 2018</span>
     |
    
    <a href="/blog/tags/#regex" class="post-tag">Regex</a>
    
    <a href="/blog/tags/#re" class="post-tag">re</a>
    
    

    <article>
      <hr />

<p><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/20/regex-usage-01-basic/">파이썬 정규표현식(re) 사용법 - 01. Basic</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/21/regex-usage-02-basic/">파이썬 정규표현식(re) 사용법 - 02. 문자, 경계, flags</a><br />
<strong><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/22/regex-usage-03-basic/">파이썬 정규표현식(re) 사용법 - 03. OR, 반복</a></strong><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/28/regex-usage-04-intermediate/">파이썬 정규표현식(re) 사용법 - 04. 그룹, 캡처</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/04/regex-usage-05-intermediate/">파이썬 정규표현식(re) 사용법 - 05. 주석, 치환, 분리</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/05/regex-usage-06-advanced/">파이썬 정규표현식(re) 사용법 - 06. 치환 함수, 양방탐색, 조건문</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/06/regex-usage-07-example/">파이썬 정규표현식(re) 사용법 - 07. 예제(숫자)</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/06/regex-usage-08-example/">파이썬 정규표현식(re) 사용법 - 08. 예제(단어, 행)</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/24/regex-usage-09-other-functions/">파이썬 정규표현식(re) 사용법 - 09. 기타 기능</a></p>

<hr />

<p>이 글에서는 정규표현식 기초와 python library인 <code class="highlighter-rouge">re</code> 패키지 사용법에 대해서 설명한다.</p>

<p>본 글에서 정규표현식은 <code class="highlighter-rouge">regex</code>와 같이, 일반 문자열은 ‘regex’와 같이 표시하도록 한다.</p>

<hr />

<h2 id="정규표현식의-기초-or-반복">정규표현식의 기초: OR, 반복</h2>

<h3 id="--다자택일"><code class="highlighter-rouge">|</code> : 다자택일</h3>

<p>단어 ‘one’, ‘two’, ‘three’ 중 하나에 대응하고 싶다면 <code class="highlighter-rouge">|</code>를 쓰면 된다(백슬래시 또는 원화로 되어 있는 <code class="highlighter-rouge">\</code> 키의 shift 버전이다).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'one|two|three'</span><span class="p">,</span> <span class="s">'one four two three zero'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['one', 'two', 'three']
</code></pre></div></div>

<p>작동 과정을 살펴보자.</p>

<ol>
  <li>맨 앞에서 바로 ‘one’이 일치된다.</li>
  <li>공백 한 개는 <code class="highlighter-rouge">o</code>, <code class="highlighter-rouge">t</code> 어느 것에도 일치되지 않으므로 건너뛴다. ‘f’도 마찬가지이다.</li>
  <li>‘four’ 의 ‘o’에 도달했다. <code class="highlighter-rouge">o</code>는 일치되기 때문에, ‘u’에 <code class="highlighter-rouge">n</code>을 일치시켜본다. 물론 아니다.</li>
  <li>계속 넘어가서 ‘two’의 ‘t’에 도달했다. ‘t’는 <code class="highlighter-rouge">t</code>에 일치된다.</li>
  <li>‘w’에서는 <code class="highlighter-rouge">w</code>와 <code class="highlighter-rouge">h</code> 중 일치되는 것을 찾는다. 현재 <code class="highlighter-rouge">tw</code>까지 일치되었다.</li>
  <li>‘o’까지 일치되어 ‘two`를 찾았다.</li>
  <li>이와 비슷한 과정을 반복하여 ‘three’까지 찾고 종료한다.</li>
</ol>

<p>일반적으로 <code class="highlighter-rouge">|</code>로 나열한 단어들의 순서가 중요하지는 않다. 하지만 중요한 순간이 있다.<br />
다음 예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'one|oneself|onerous'</span><span class="p">,</span> <span class="s">'oneself is the one thing.'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['one', 'one']
</code></pre></div></div>

<p>‘oneself’가 있음에도 <code class="highlighter-rouge">oneself</code>에 일치되지 않았다. 그 이유는 이미 ‘one’을 찾아버렸고, 정규식은 overlapping된 부분을 또 찾지 않기 때문에, ‘one’을 찾고 나서 남은 문자열은 ‘self is the one thing.’이다. 따라서 남은 문자열에서는 더 이상 <code class="highlighter-rouge">oneself</code>를 찾을 수 없는 것이다.</p>

<p>이 문제의 해결 방법은 두 가지다. 물론 더 있을 수도 있다.</p>

<ol>
  <li>당연하게도 더 긴 <code class="highlighter-rouge">oneself</code>를 <code class="highlighter-rouge">one</code> 앞에다 두면 해결된다.</li>
  <li>아니면 단어 경계를 활용한다. <code class="highlighter-rouge">\bone\b|\boneself\b</code>로 쓰면 된다.</li>
</ol>

<h3 id="--0회-이상-반복">* : 0회 이상 반복</h3>

<p>어떤 문자나 기호 뒤에 *(asterisk)를 붙이면 그 문자가 일치되는 만큼 일치된다. 예를 들어 <code class="highlighter-rouge">a*</code>의 경우 ‘a’나 ‘aaa’ 혹은 ‘‘(빈 문자열)과도 일치된다.</p>

<p>예시를 보자.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="s">'a*'</span><span class="p">,</span> <span class="s">''</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="s">'a*'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'a*'</span><span class="p">,</span> <span class="s">'aaaa'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s">'a*'</span><span class="p">,</span> <span class="s">'aaaaaa'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'a*'</span><span class="p">,</span> <span class="s">'aaabaaa aa  '</span><span class="p">))</span>

<span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'&lt;p&gt;.*&lt;/p&gt;'</span><span class="p">,</span> <span class="s">'&lt;p&gt; Lorem ipsum... is boring. &lt;/p&gt;'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(0, 0), match=''&gt;
&lt;_sre.SRE_Match object; span=(0, 1), match='a'&gt;
&lt;_sre.SRE_Match object; span=(0, 4), match='aaaa'&gt;
&lt;_sre.SRE_Match object; span=(0, 6), match='aaaaaa'&gt;
['aaa', '', 'aaa', '', 'aa', '', '', '']
&lt;_sre.SRE_Match object; span=(0, 34), match='&lt;p&gt; Lorem ipsum... is boring. &lt;/p&gt;'&gt;
</code></pre></div></div>

<p>여섯 번째 결과의 경우, 파이썬 버전에 따라 <strong>None</strong>이 반환될 수도 있다.</p>

<p>그런데 한 가지 이상한 결과가 보인다. 다섯 번째 실행문이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'a*'</span><span class="p">,</span> <span class="s">'aaabaaa aa  '</span><span class="p">))</span>
<span class="c1"># ['aaa', '', 'aaa', '', 'aa', '', '', '']
</span></code></pre></div></div>

<p>빈 문자열이 이상하리만큼 많이 매칭되었다. 굉장히 비직관적인 결과이지만, 빈 문자열에도 일치된다는 것을 생각했을 때 아예 틀린 것은 분명히 아니다.<br />
매칭되는 빈 문자열들은 a가 아닌 다른 문자들과의 경계에서 발생한다고 생각하면 될 듯하다. 하지만, 아마 대부분 이것은 원하는 결과가 아닐 것이기 때문에, ‘a’ 덩어리를 찾고 싶다면 다음 메타문자를 보자.</p>

<h3 id="--1회-이상-반복">+ : 1회 이상 반복</h3>

<p><code class="highlighter-rouge">*</code>과 비슷하지만 무조건 한 번이라도 등장해야 한다. 위와 거의 같은 예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="s">'a+'</span><span class="p">,</span> <span class="s">''</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="s">'a+'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'a+'</span><span class="p">,</span> <span class="s">'aaaa'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s">'a+'</span><span class="p">,</span> <span class="s">'aaaaaa'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'a+'</span><span class="p">,</span> <span class="s">'aaabaaa aa  '</span><span class="p">))</span>

<span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'&lt;p&gt;.+&lt;/p&gt;'</span><span class="p">,</span> <span class="s">'&lt;p&gt; Lorem ipsum... is boring. &lt;/p&gt;'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>None
&lt;_sre.SRE_Match object; span=(0, 1), match='a'&gt;
&lt;_sre.SRE_Match object; span=(0, 4), match='aaaa'&gt;
&lt;_sre.SRE_Match object; span=(0, 6), match='aaaaaa'&gt;
['aaa', 'aaa', 'aa']
&lt;_sre.SRE_Match object; span=(0, 34), match='&lt;p&gt; Lorem ipsum... is boring. &lt;/p&gt;'&gt;
</code></pre></div></div>

<p>아마 이것이 여러분이 원하는 ‘a’ 덩어리를 찾은 결과일 것이다.<br />
빈 문자열이 일치되지 않은 것을 기억하자.</p>

<h3 id="n-m--지정-횟수만큼-반복">{n, m} : 지정 횟수만큼 반복</h3>

<p>중괄호는 지정한 횟수만큼 정규식을 반복시키는 것이다. 이 쓰임으로 중괄호를 쓸 때 쓰는 방법은 세 가지가 있다.</p>

<ol>
  <li>{n} : 정확히 n회만큼 반복</li>
  <li>{n, m} : n회 이상 m회 이하 반복</li>
  <li>{n, } : n회 이상 반복. 무한히 일치될 수 있다.</li>
</ol>

<p>물론 n은 자연수, m은 n보다 큰 정수이다.
그리 어렵지 않으므로 바로 예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'a{3}'</span><span class="p">,</span> <span class="s">'aaaaa'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'a{3}'</span><span class="p">,</span> <span class="s">'aaaaaaaa'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'a{2,4}'</span><span class="p">,</span> <span class="s">'a aa aaa aaaa aaaaa'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'a{2,}'</span><span class="p">,</span> <span class="s">'a aa aaa aaaa aaaaa'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(0, 3), match='aaa'&gt;
['aaa', 'aaa']
['aa', 'aaa', 'aaaa', 'aaaa']
['aa', 'aaa', 'aaaa', 'aaaaa']
</code></pre></div></div>

<p>예상과는 조금 다른 결과일지도 모르겠다. 오직 ‘aaa’만을 찾고 싶을 때 <code class="highlighter-rouge">a{3}</code>처럼 쓰면 ‘aaaaa’의 일부분인 ‘aaa’에도 일치될 수 있다. 따라서 정확히 ‘aaa’만을 찾으려면 <code class="highlighter-rouge">\baaa\b</code>처럼 단어 경계를 활용하는 쪽이 좋다.</p>

<p>참고로 <code class="highlighter-rouge">{0, }</code>은 <code class="highlighter-rouge">*</code>과 같고, <code class="highlighter-rouge">{1,}</code>은 <code class="highlighter-rouge">+</code>와 같다.</p>

<p><img src="\public\img\정규표현식(re)\2018-07-20-regex-usage-03-basic\01.{0,1,}.PNG" alt="01" /></p>

<h3 id="--0회-또는-1회-반복">? : 0회 또는 1회 반복</h3>

<p>이 메타문자도 어렵지는 않을 것이라 생각된다. <code class="highlighter-rouge">?</code>는 <code class="highlighter-rouge">{0,1}</code>과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'ab?a'</span><span class="p">,</span> <span class="s">'aa aba aaaa'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['aa', 'aba', 'aa', 'aa']
</code></pre></div></div>

<p>정규표현식은 항상 최대한 많은 부분을 일치시키려 한다는 것을 기억하자.</p>

<p>참고로, 앞에서 말한 반복 메타문자들(<code class="highlighter-rouge">*</code>, <code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">{n, m}</code>, <code class="highlighter-rouge">?</code> 등)을 정량자 또는 수량자라고 부른다.</p>

<hr />

<h3 id="advanced-탐욕-정량자-vs-나태-정량자">Advanced: 탐욕 정량자 vs 나태 정량자</h3>

<p>그리고 이런 정량자(수량자)들은 한 가지 중요한 특성이 있다.<br />
일단 전체 문자열이 매치가 되도록 노력하고, 그 선을 지키는 선에서 일치되는 부분에는 최대한 많이 일치시키려고 한다. 즉 기본적으로 모든 정량자들은 탐욕적이며, 가능한 많은 문자열에 매치되려고 한다.</p>

<p>말이 복잡한데, 예시를 보면서 천천히 설명하도록 하겠다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1번 예시
</span><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'&lt;p&gt;.*&lt;/p&gt;'</span><span class="p">,</span> <span class="s">'&lt;p&gt; Lorem ipsum... is boring. &lt;/p&gt;'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>

<span class="k">print</span><span class="p">(</span><span class="s">'# ---------------------------------------------------------------- #'</span><span class="p">)</span>

<span class="c1"># 2번 예시
</span><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'&lt;p&gt;.*&lt;/p&gt;'</span><span class="p">,</span> <span class="s">'''
&lt;p&gt; part 1 &lt;/p&gt; part 2 &lt;/p&gt;
&lt;p&gt; part 3 &lt;/p&gt; part 4 &lt;/p&gt;
'''</span><span class="p">,</span> <span class="n">re</span><span class="p">.</span><span class="n">DOTALL</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>

<span class="k">print</span><span class="p">(</span><span class="s">'# ---------------------------------------------------------------- #'</span><span class="p">)</span>

<span class="c1"># 3번 예시
</span><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'&lt;p&gt;.*?&lt;/p&gt;'</span><span class="p">,</span> <span class="s">'''
&lt;p&gt; part 1 &lt;/p&gt; part 2 &lt;/p&gt;
&lt;p&gt; part 3 &lt;/p&gt; part 4 &lt;/p&gt;
'''</span><span class="p">,</span> <span class="n">re</span><span class="p">.</span><span class="n">DOTALL</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">.</span><span class="n">group</span><span class="p">())</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt; Lorem ipsum... is boring. &lt;/p&gt;
# ---------------------------------------------------------------- #
&lt;p&gt; part 1 &lt;/p&gt; part 2 &lt;/p&gt;
&lt;p&gt; part 3 &lt;/p&gt; part 4 &lt;/p&gt;
# ---------------------------------------------------------------- #
&lt;p&gt; part 1 &lt;/p&gt;
</code></pre></div></div>

<p><strong>전체 문자열이 매치가 되도록 노력한다.</strong></p>

<ul>
  <li>여러분은 조금 위에서 Lorem ipsum 예시를 보았을 것이다. 바로 위의 1번 예시는 이를 변형한 것이다.<br />
사실 마침표 <code class="highlighter-rouge">.</code>는 모든 문자에 일치되기 때문에, ‘&lt;/p&gt;‘에 해당하는 부분도 마침표에 일치될 수 있다. 만약에 이 부분까지 <code class="highlighter-rouge">.</code>에 일치시켜 버린다면, <code class="highlighter-rouge">.*</code> 부분이 ‘&lt;p&gt;’ 뒤쪽의 모든 문자를 집어삼켜 버리고, 따라서 정규식의 남은 패턴인 <code class="highlighter-rouge">&lt;/p&gt;</code> 부분은 대조해볼 문자열이 남아있지 않으므로 실패해야 한다고 생각할 수 있다.</li>
  <li>그러나, 정규식의 정량자들은 <strong>역행(backtracking)</strong>을 할 줄 안다. 이 말은, <code class="highlighter-rouge">*</code>나 <code class="highlighter-rouge">+</code> 등은 탐욕적이기는 하지만, 전체 문자열에 일치되는 가능성마저 없애버리지는 않는다는 말과 갈다.
    <ol>
      <li>우선 <code class="highlighter-rouge">.*</code>가 모든 문자열을 집어삼켜 ‘&lt;/p&gt;‘까지 해치웠다. 그러나, 정규식 패턴에는 <code class="highlighter-rouge">&lt;/p&gt;</code>가 남아있기 때문에, <code class="highlighter-rouge">.*</code>는 자신이 집어삼킨 문자열을 하나 뱉어내고, 남은 정규식 패턴 <code class="highlighter-rouge">&lt;/p&gt;</code>에 대조해보라고 한다.</li>
      <li>마지막 문자 하나인 ‘&gt;‘는 매치되지 않기 때문에, <code class="highlighter-rouge">.*</code>는 문자를 하나 더 뱉어낸다. 이제 ‘p&gt;‘와 남은 정규식 패턴 <code class="highlighter-rouge">&lt;/p&gt;</code>를 비교해보라고 시킨다.</li>
      <li>역시 일치되지 않으므로, 이와 같은 과정을 정규식 패턴과 뱉어낸 문자열이 일치될 때까지 혹은 모든 문자를 뱉어낼 때까지 반복하게 된다.</li>
      <li>Lorem ipsum 예시의 경우 4개의 문자를 뱉어내면 일치된다. 따라서 모든 문자열이 정규식 패턴과 일치되고, 전체 문자열이 결과로 반환된다.</li>
      <li><code class="highlighter-rouge">.*</code>가 먹어치웠던 문자열을 살펴보면 그 경계가 끝까지 갔다가 반대 방향으로 후퇴하는 것처럼 보인다. 그래서 이름이 <strong>역행</strong>이다.</li>
    </ol>
  </li>
  <li>이는 2번 예시를 보아도 알 수 있다. <code class="highlighter-rouge">.*</code>가 최대로 일치시키려고 하기 때문에, ‘part 1’이나 ‘part 2’까지 일치되는 것이 아닌 최대로 일치되는 부분인 ‘part 4’까지 일치시키는 것을 볼 수 있다.</li>
</ul>

<p><strong>3번 예시는 <em>나태 정량자</em>를 보여준다. 나태 정량자는 별다른 것은 없고, 단지 정량자 바로 뒤에 <code class="highlighter-rouge">?</code>를 붙여주기만 하면 된다. 그러면 탐욕적 정량자였던 <code class="highlighter-rouge">*</code>는 최대로 일치시키는 대신 문자열은 가장 적게 먹어치우면서 일치되도록 하는 방법을 찾는다. 그래서 딱 ‘part 1’까지만 일치되고, 나머지 문자열은 버려진다.</strong></p>

<ul>
  <li><code class="highlighter-rouge">+?</code>, <code class="highlighter-rouge">{3, 5}?</code>, <code class="highlighter-rouge">??</code> 등도 가능하다.</li>
  <li>사실 나태 정량자도 역행을 한다. 그러나 역행이 꼭 뒤로 가는 것을 의미하는 것이 아닌, 각 정량자가 선호하는 방향과 반대 방향으로 갈 때 역행이라고 한다. 따라서 나태 정량자는 우선 최소로 일치하는 부분을 찾은 뒤(빈 문자열), 문자열이 일치될 때까지 역행(문자열 방향으로는 뒤쪽)한다.</li>
</ul>

<p>그래서 탐욕 정량자와 나태 정량자의 차이는, 유력 대조부를 제일 긴 것을 우선적으로 찾느냐, 제일 짧은 것을 우선적으로 찾느냐의 차이이다.<br />
그리고 결과적으로 탐욕 정량자와 나태 정량자의 일치부가 같아지는 때도 있다. 다만 이때는 검색 순서만이 다를 뿐이다.</p>

<p>역행에 관해서는 <a href="https://greeksharifa.github.io/references/2018/07/13/it-will-update-soon/">나중</a>에 조금 더 자세히 다루도록 하겠다.</p>

<hr />

<h3 id="응용-문제">응용 문제</h3>

<p>문제 1: 1~8자리 10진수에 일치하는 정규표현식을 작성하라.</p>

<details>
    <summary>문제 1 정답보기</summary>
    <p>r'\b\d{1,8}\b'</p>
</details>

<p><br /></p>

<p>문제 2: 4자리 또는 8자리 16진수에 일치하는 정규표현식을 작성하라. 16진수는 0~9, a~f를 사용한다. 예시는 abcd1992, 7fffffff, 2dfa9a00이다.
윈도우 오류에서 ‘0xC1900101’ 비슷한 에러를 많이 봤을 것이다.</p>

<details>
    <summary>문제 2 정답보기</summary>
    <p>r'\b[0-9a-f]{4}\b|\b[0-9a-f]{8}\b'</p>
</details>

<p><br /></p>

<p>문제 3: 1.2이나 3.72e3, 1.002e-12 같은 수를 부동소수점 수 또는 과학적 표기법으로 표기한 수라고 한다. 이와 같은 수에 일치하는 정규표현식을 작성하라.</p>

<details>
    <summary>문제 3 정답보기</summary>
    <p>r'\b\d*\.\d+(e\d+)?'</p>
</details>

<p><br /></p>

<p>파이썬 버전 3.6 기준으로, <code class="highlighter-rouge">\b</code>를 쓰려면 <strong>r prefix</strong>를 붙여 주어야 한다고 했었다.</p>

<hr />

<p>문제 3의 정답에 아직 설명하지 않은 소괄호 <code class="highlighter-rouge">( )</code>가 있다. 이는 <a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/28/regex-usage-04-intermediate/">다음 글</a>에서 설명한다.</p>


    </article>
    <div class="post-more">
      
      <a href="/regex-usage-03-basic/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/regex-usage-03-basic/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/regex-usage-02-basic/">
        파이썬 정규표현식(re) 사용법 - 02. 문자, 경계, flags
      </a>
    </h1>

    <span class="post-date">21 Jul 2018</span>
     |
    
    <a href="/blog/tags/#regex" class="post-tag">Regex</a>
    
    <a href="/blog/tags/#re" class="post-tag">re</a>
    
    

    <article>
      <hr />

<p><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/20/regex-usage-01-basic/">파이썬 정규표현식(re) 사용법 - 01. Basic</a><br />
<strong><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/21/regex-usage-02-basic/">파이썬 정규표현식(re) 사용법 - 02. 문자, 경계, flags</a></strong><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/22/regex-usage-03-basic/">파이썬 정규표현식(re) 사용법 - 03. OR, 반복</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/28/regex-usage-04-intermediate/">파이썬 정규표현식(re) 사용법 - 04. 그룹, 캡처</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/04/regex-usage-05-intermediate/">파이썬 정규표현식(re) 사용법 - 05. 주석, 치환, 분리</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/05/regex-usage-06-advanced/">파이썬 정규표현식(re) 사용법 - 06. 치환 함수, 양방탐색, 조건문</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/06/regex-usage-07-example/">파이썬 정규표현식(re) 사용법 - 07. 예제(숫자)</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/06/regex-usage-08-example/">파이썬 정규표현식(re) 사용법 - 08. 예제(단어, 행)</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/24/regex-usage-09-other-functions/">파이썬 정규표현식(re) 사용법 - 09. 기타 기능</a></p>

<hr />

<p>이 글에서는 정규표현식 기초와 python library인 <code class="highlighter-rouge">re</code> 패키지 사용법에 대해서 설명한다.</p>

<p>본 글에서 정규표현식은 <code class="highlighter-rouge">regex</code>와 같이, 일반 문자열은 ‘regex’와 같이 표시하도록 한다.</p>

<p>파이썬 버전은 3.6을 기준으로 하나, 3.x 버전이면 (아마) 동일하게 쓸 수 있다.<br />
2.7 버전은 한글을 포함한 비 알파벳 문자 처리가 다르다.</p>

<hr />

<h2 id="특수문자">특수문자</h2>

<h3 id="메타문자">메타문자</h3>

<p>메타문자에 대해서는 <a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/20/regex-usage-01-basic/#%EB%A9%94%ED%83%80%EB%AC%B8%EC%9E%90">이전 글</a>에서 설명했다.</p>

<h3 id="비인쇄-문자">비인쇄 문자</h3>

<p>벨<code class="highlighter-rouge">\a</code>, 이스케이프<code class="highlighter-rouge">\e</code>, 폼 피드<code class="highlighter-rouge">\f</code>, 라인 피드(개행문자)<code class="highlighter-rouge">\n</code>, 캐리지 리턴<code class="highlighter-rouge">\r</code>, 가로 탭<code class="highlighter-rouge">\t</code>, 세로 탭<code class="highlighter-rouge">\v</code>는 다음 두 가지 방식으로 쓸 수 있다.</p>
<blockquote>
  <p>\a \e \f \n \r \t \v<br />
\x07 \x1B \f \n \r \t \v</p>
</blockquote>

<p>정규표현식을 쓰면서 다른 것들은 거의 볼 일이 없을 것이지만, <code class="highlighter-rouge">\t</code>와 <code class="highlighter-rouge">\n</code>은 알아두는 것이 좋다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s"> '</span><span class="p">,</span> <span class="s">'a</span><span class="se">\t</span><span class="s">b</span><span class="se">\t</span><span class="s">c</span><span class="se">\t</span><span class="s"> </span><span class="se">\t</span><span class="s"> d'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['\t ', '\t ']
</code></pre></div></div>

<p>탭 문자와 공백 문자가 붙어 있는 것은 2개임을 확인할 수 있다.</p>

<h3 id="이스케이프-">이스케이프 <code class="highlighter-rouge">\</code></h3>

<p>이스케이프 문자 <code class="highlighter-rouge">\</code>는 메타문자를 일반 리터럴 문자로 취급하게끔 해 준다.<br />
예를 들어 여는 괄호 <code class="highlighter-rouge">[</code>는 메타 문자지만, <code class="highlighter-rouge">\[</code>와 같이 처리하면 리터럴 문자인 일반 대괄호 문자 ‘[‘와 매칭될 수 있게 된다.</p>

<p>하지만, 일반 영수 문자(알파벳 또는 숫자)를 이스케이프 처리하면 에러가 나거나 혹은 전혀 다른 의미의 정규식 토큰이 생성된다.<br />
예를 들어 파이썬에서 <code class="highlighter-rouge">\1</code>의 경우에는 캡처한 문자열 중 첫번째를 재사용한다는 의미(나중에 자세히 설명할 것이다)가 되어 버린다. 따라서 <code class="highlighter-rouge">\</code>를 남용하면 안 된다.</p>

<hr />

<script data-ad-client="ca-pub-9951774327887666" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<h2 id="--대괄호여러-문자-중-하나와-일치">[ ] 대괄호:여러 문자 중 하나와 일치</h2>

<p>대괄호 <code class="highlighter-rouge">[</code>와 <code class="highlighter-rouge">]</code> 사이에 원하는 문자를 여러 개 넣으면, 문자열이 넣은 문자 중 하나와 일치하면 매칭이 이루어진다. 즉 OR 개념이라고 할 수 있다.<br />
여기서 중요한 것은 <code class="highlighter-rouge">[ ]</code> 안에 얼마나 많은 문자 종류가 있는지에 상관없이 딱 한 문자와 일치된다는 것이다.</p>

<p>예를 들어 정규식 표현이 <code class="highlighter-rouge">[abc]</code>이고 문자열이 ‘a’이면 <strong>re.match</strong>는 매칭되었다고 할 것이다.<br />
문자열이 ‘b’이거나 ‘c’이어도 매칭이 된다. 다만 문자열이 ‘d’이거나 ‘가나다’ 같은 것이면 매칭이 되지 않는다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s">"You[;']re studying re module[.,]"</span><span class="p">,</span> \
                        <span class="s">'You;re studying re module,'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(0, 26), match='You;re studying re module,'&gt;
</code></pre></div></div>

<p>사용자의 오타를 잡기에 괜찮은 기능이다.</p>

<p>대괄호 <code class="highlighter-rouge">[ ]</code>에는 다른 기능이 더 있다. 이전 글에서 <a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/20/regex-usage-01-basic/#semi-%EB%A9%94%ED%83%80%EB%AC%B8%EC%9E%90">semi-메타문자</a>를 설명했었는데, 문자 <code class="highlighter-rouge">-</code>는 대괄호 안에서는 메타문자 역할을 한다.</p>

<p>하이픈 <code class="highlighter-rouge">-</code>는 범위를 형성한다. 예를 들어 <code class="highlighter-rouge">[a-z]</code>는 알파벳 소문자 중 하나이기만 하면 매칭이 된다. 또 <code class="highlighter-rouge">[A-Z]</code>, <code class="highlighter-rouge">[0-9]</code>는 각각 알파벳 대문자와 숫자 하나에 매칭된다.<br />
물론 위의 경우뿐만 아니라 넓은 범위도 가능하다. <code class="highlighter-rouge">[가-힣]</code>의 경우는 한글 한 글자에 일치된다.<br />
<code class="highlighter-rouge">[A-z]</code>는 영문 대소문자와 몇 개의 특수문자를 포함한다. 하지만 여러분이 잘 모르는 문자까지 포함될 수 있으므로 영문자는 <code class="highlighter-rouge">[A-Za-z]</code>와 같이 쓰기를 권한다.</p>

<p>참고로, 대괄호 안에서는 메타문자 역할을 하는 것은 오직 <code class="highlighter-rouge">\</code>, <code class="highlighter-rouge">^</code>, <code class="highlighter-rouge">-</code>, <code class="highlighter-rouge">]</code> 4개뿐이다. 즉, 이전에 메타문자라고 설명했었던 <code class="highlighter-rouge">.</code>, <code class="highlighter-rouge">*</code>, <code class="highlighter-rouge">+</code> 등은 대괄호 안에서는 그냥 문자 ‘.’, ‘*’, ‘+’ 하나에 매칭된다.<br />
그러나 헷갈릴 소지가 다분하기 때문에 원래 메타문자인 문자들은 그냥 대괄호 안에서도 <code class="highlighter-rouge">\</code> 이스케이프 처리하는 것이 편할 것이다.<br />
물론 IDE가 좋다면 redundant escape character라는 경고를 띄워 줄지도 모른다.</p>

<p>캐릿(caret)<code class="highlighter-rouge">^</code> 문자가 여는 대괄호 바로 뒤에 있으면 문자가 반전된다. 바로 예시를 보도록 하자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'Why [a-z]o serious\?'</span><span class="p">,</span> <span class="s">'Why so serious?'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
<span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'Why [^0-9]o serious\?'</span><span class="p">,</span> <span class="s">'Why so serious?'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(0, 15), match='Why so serious?'&gt;
&lt;_sre.SRE_Match object; span=(0, 15), match='Why so serious?'&gt;
</code></pre></div></div>

<p><code class="highlighter-rouge">[a-z]</code>는 영문 소문자 하나(‘s’)와 일치되므로 매칭 결과가 반환되었다.<br />
<code class="highlighter-rouge">[^0-9]</code>는 숫자를 제외한 문자 하나에 일치되므로, ‘s’는 숫자가 아니기에 매칭이 되었다.</p>

<p><code class="highlighter-rouge">[z-a]</code>와 같이 거꾸로 쓰는 것은 불가능하다.</p>

<p>대괄호 안의 <code class="highlighter-rouge">-</code>는 또 다른 기능이 있다. 바로 진짜 빼기(마이너스), 즉 차집합 연산이다.<br />
대괄호 한 쌍을 집합으로 보면 차집합이란 말이 이해가 될 것이다. <code class="highlighter-rouge">[a-z-[g-z]]</code>의 경우 a-f와 같은 의미이다.<br />
또 &amp;&amp;를 안에 쓰면 C언어 문법의 and 기능처럼 교집합을 의미한다고 한다.<br />
하지만 필자가 글을 쓰는 시점에서 이 문법이 유효한지는 확인되지 않았다. 파이썬 버전에 따라 다를 수도 있고, 지원하지 않는 기능일 수도 있다.</p>

<hr />

<h2 id="-마침표-모든-문자와-일치">. 마침표: 모든 문자와 일치</h2>

<p>개행문자를 제외한 모든 문자와 일치하는 정규표현식은 마침표 <code class="highlighter-rouge">.</code> 이다. 정말로 모든 문자와 일치되기 때문에 별다른 설명은 필요 없을 것 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'r..n[.]'</span><span class="p">,</span> <span class="s">'ryan. ruin rain round. reign'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['ryan.']
</code></pre></div></div>

<p>대괄호 <code class="highlighter-rouge">[ ]</code> 안에서는 <code class="highlighter-rouge">.</code>가 메타문자로 동작하지 않는다고 하였다. 따라서 일치되는 문자열은 ‘ryan’ 하나뿐이다.</p>

<h3 id="마침표는-개행-문자와-일치-옵션">마침표는 개행 문자와 일치 옵션</h3>

<p>파이썬 re 패키지의 많은 함수들은 다음과 같은 인자들을 받는다고 <a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/20/regex-usage-01-basic/#rematchpattern-string-flags">이전 글</a>에서 설명했었다.</p>

<blockquote>
  <p>re.match(pattern, string, flags)</p>
</blockquote>

<p>여기서 flags는 다음과 같은 종류들이 있다.</p>

<table>
  <thead>
    <tr>
      <th>syntax</th>
      <th>long syntax</th>
      <th style="text-align: center">inline flag</th>
      <th>meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>re.I</td>
      <td>re.IGNORECASE</td>
      <td style="text-align: center">(?i)</td>
      <td>대소문자 구분 없이 일치</td>
    </tr>
    <tr>
      <td>re.M</td>
      <td>re.MULTILINE</td>
      <td style="text-align: center">(?m)</td>
      <td>^와 $는 개행문자 위치에서 일치</td>
    </tr>
    <tr>
      <td>re.S</td>
      <td>re.DOTALL</td>
      <td style="text-align: center">(?s)</td>
      <td>마침표는 개행문자와 일치</td>
    </tr>
    <tr>
      <td>re.A</td>
      <td>re.ASCII</td>
      <td style="text-align: center">(?a)</td>
      <td>{\w, \W, \b, \B}는 ascii에만 일치</td>
    </tr>
    <tr>
      <td>re.U</td>
      <td>re.UNICODE</td>
      <td style="text-align: center">(?u)</td>
      <td>{\w, \W, \b, \B}는 Unicode에 일치</td>
    </tr>
    <tr>
      <td>re.L</td>
      <td>re.LOCALE</td>
      <td style="text-align: center">(?L)</td>
      <td>{\w, \W, \b, \B}는 locale dependent</td>
    </tr>
    <tr>
      <td>re.X</td>
      <td>re.VERBOSE</td>
      <td style="text-align: center">(?x)</td>
      <td>정규표현식에 주석을 달 수 있음</td>
    </tr>
  </tbody>
</table>

<p>우선 다른 것들은 나중에 살펴보고, 마침표 옵션만을 보자.</p>

<table>
  <thead>
    <tr>
      <th>syntax</th>
      <th>long syntax</th>
      <th>meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>re.S</td>
      <td>re.DOTALL</td>
      <td>마침표는 개행문자와 일치</td>
    </tr>
  </tbody>
</table>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'a..'</span><span class="p">,</span> <span class="s">'abc a  a</span><span class="se">\n</span><span class="s">a'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'a..'</span><span class="p">,</span> <span class="s">'abc a  a</span><span class="se">\n</span><span class="s">a'</span><span class="p">,</span> <span class="n">re</span><span class="p">.</span><span class="n">S</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'a..'</span><span class="p">,</span> <span class="s">'abc a  a</span><span class="se">\n</span><span class="s">a'</span><span class="p">,</span> <span class="n">re</span><span class="p">.</span><span class="n">DOTALL</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['abc', 'a  ']
['abc', 'a  ', 'a\na']
['abc', 'a  ', 'a\na']
</code></pre></div></div>

<p>개행 문자도 마침표에 일치되는지를 설정할 수 있음을 확인하였다.<br />
문자열을 행 단위로 처리하거나 아니면 전체 문자열을 대상으로 처리할 수 있다는 것에 이 옵션의 존재 의의가 있다.</p>

<h4 id="모드-변경자">모드 변경자</h4>

<p>아니면 다른 방법도 있다. 정규표현식 내에서 사용할 수도 있다.<br />
문자열 앞에 <code class="highlighter-rouge">(?s)</code> 토큰을 넣으면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'(?s)a..'</span><span class="p">,</span> <span class="s">'abc a  a</span><span class="se">\n</span><span class="s">a'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['abc', 'a  ', 'a\na']
</code></pre></div></div>

<p>모드 변경자는 여러 개를 중첩하여 사용할 수도 있다.<br />
또한 일부분에만 사용하고 싶으면 <code class="highlighter-rouge">(?s&lt;regex&gt;)</code>처럼 모드 변경자의 소괄호 안에 집어넣으면 된다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'(?is)a..'</span><span class="p">,</span> <span class="s">'Abc'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'(?is:a..) and abc is good'</span><span class="p">,</span>
<span class="s">'''
Abc and abc is good.
abc and Abc is good. 
'''</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['Abc']
['Abc and abc is good']
</code></pre></div></div>
<p>두 번째 <strong>findall</strong>에서 문장을 한 개만 찾은 것을 유의하라.</p>

<hr />

<h2 id="문자-집합-w-w-d-d-s-s-b-b">문자 집합: \w \W, \d \D, \s \S, \b \B</h2>

<h3 id="w-w-단어-문자-비-단어-문자">\w, \W: 단어 문자, 비 단어 문자</h3>

<p><code class="highlighter-rouge">\w</code>는 단어 문자 1개와 일치된다. 단어 문자는 영문 대소문자, 숫자 0-9, 언더바 ‘_’ 를 포함한다.<br />
한글 등 알파벳 이외의 단어는 파이썬 버전에 따라 다른데, Unicode를 기본으로 사용하는 파이썬 3이라면 아마 <code class="highlighter-rouge">\w</code>의 범위에 한글도 포함될 것이다. 여러분이 스스로 확인해 봐야 할 것이다.</p>

<p><code class="highlighter-rouge">\W</code>는 단어 문자 이외의 문자 1개에 일치된다. 즉 공백 문자, 특수 문자 등에 일치된다고 보면 된다.<br />
<code class="highlighter-rouge">\w</code>와 정확히 반대의 역할을 한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'\w\w\w'</span><span class="p">,</span> <span class="s">'a_가'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
<span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'\w\W\w'</span><span class="p">,</span> <span class="s">'a (9_a a'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(0, 3), match='a_가'&gt;
['a a']
</code></pre></div></div>
<p>첫 번째 출력 결과의 경우 단어 3개를 나타내는 정규표현식에 ‘a_가’가 매칭되었다.
두 번째 출력 결과는 잘 보면<br />
1) 비 단어 문자<br />
2) 단어 문자<br />
3) 비 단어 문자<br />
순으로 되어 있는데, 그런 결과는 ‘a a’ 하나뿐이다.</p>

<h3 id="d-d-숫자-문자-비-숫자-문자">\d, \D: 숫자 문자, 비 숫자 문자</h3>

<p><code class="highlighter-rouge">\d</code>는 숫자 문자 1개에 일치된다. 마찬가지로 <code class="highlighter-rouge">\D</code>는 비 숫자 문자 1개에 일치된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="s">'\d\d'</span><span class="p">,</span> <span class="s">'12abc34'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
<span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'\d\d\D\D'</span><span class="p">,</span> <span class="s">'11aa11c1'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(0, 2), match='12'&gt;
['11aa']
</code></pre></div></div>
<p>첫 번째 출력 결과는 매칭되는 문자열은 두 군데로 ‘12’와 ‘34’이다. 하지만 <strong>re.search</strong>는 제일 처음 하나만 찾아내기 때문에 하나만 반환하였다.
두 번째 출력 결과는 숫자 2개에 비 숫자 문자 2개가 붙어 있는 문자열 ‘11aa’를 잘 찾아 주었다.</p>

<h3 id="s-s-공백-문자-비-공백-문자">\s, \S: 공백 문자, 비 공백 문자</h3>

<p><code class="highlighter-rouge">\s</code>는 공백 문자(빈칸 ‘ ‘, 탭 ‘\t’, 개행 ‘\n’) 1개에 일치된다. 마찬가지로 <code class="highlighter-rouge">\S</code>는 <code class="highlighter-rouge">\s</code>의 반대 역할이다. 즉, 공백 문자 이외의 모든 문자 1개에 일치된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span>
    <span class="s">'Oh\smy\sgod\s\S'</span><span class="p">,</span>
    <span class="s">'''Oh my</span><span class="se">\t</span><span class="s">god
!'''</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(0, 11), match='Oh my\tgod\n!'&gt;
</code></pre></div></div>

<h3 id="b-b-단어-경계-비-단어-경계">\b, \B: 단어 경계, 비 단어 경계</h3>

<p>단어 경계 <code class="highlighter-rouge">\b</code> 는, 문자 하나와 일치되는 것이 아니라 정말로 단어 경계와 일치된다. 단어 문자와 비 단어 문자 사이와 매칭된다고 보면 된다.</p>

<p>비 단어 경계 <code class="highlighter-rouge">\B</code> 는 마찬가지로 반대의 역할을 수행한다. 즉, 단어 문자와 단어 문자 사이 혹은 비 단어 문자와 비 단어 문자 사이와 일치된다.</p>

<p>다른 말로는, <code class="highlighter-rouge">\b</code>는 <code class="highlighter-rouge">\w</code>에 일치되는 한 문자와 <code class="highlighter-rouge">\W</code>에 일치되는 한 문자 사이에서 일치되고, <code class="highlighter-rouge">\B</code>는 <code class="highlighter-rouge">\w</code>에 일치되는 두 문자 사이 또는 <code class="highlighter-rouge">\W</code>에 일치되는 두 문자 사이에서 일치된다.</p>

<p>한 가지 주의할 점으로는 <code class="highlighter-rouge">\b</code>나 <code class="highlighter-rouge">\B</code>를 사용하기 위해서는 정규표현식 앞에 <code class="highlighter-rouge">r</code> prefix를 붙여줘야 한다는 것이다.<br />
예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matchObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">r'\w\b\W\B'</span><span class="p">,</span> <span class="s">'ab  c d  == = e= =f'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">matchObj</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['b ', 'd ', 'e=']
</code></pre></div></div>
<p>위의 예시는<br />
1) 단어 문자<br />
2) 단어 경계<br />
3) 비 단어 문자<br />
4) 비 단어 경계</p>

<p>순으로 되어 있는 문자열을 찾는다. 위의 조건을 만족시키려면 단어 문자 + 비 단어 문자 + 비 단어 문자 조합을 찾아야 한다. 그리고 실제로 매칭되는 문자열은 단어 문자 + 비 단어 문자이다.<br />
(주: 여기서 2) 단어 경계는 쓸모가 없다. 이유는 여러분이 알아서 생각하면 된다.)</p>

<h4 id="응용-문제">응용 문제</h4>

<p>문제 1: ‘line’과는 일치하지만, ‘outline’나 ‘linear’ 등과는 일치하지 않는 정규표현식을 작성하라. 즉, 정확히 ‘line’ 단어와만 일치해야 한다.</p>
<details>
    <summary>문제 1 정답보기</summary>
    <p>\bline\b</p>
</details>

<p><br /></p>

<p>문제 2: ‘stacatto’에는 일치하지만, ‘cat’이나 ‘catch’, ‘copycat’ 등과는 일치하지 않는 정규표현식을 작성하라.</p>
<details>
    <summary>문제 2 정답보기</summary>
    <p>\Bcat\B</p>
</details>

<p><br /></p>

<p><code class="highlighter-rouge">\b</code>는 단어 경계로, 다음에 일치된다.</p>

<ol>
  <li>첫 문자가 단어 문자인 경우, 첫 문자 앞에서</li>
  <li>인접한 두 문자 중 하나만 단어 문자인 경우, 그 사이에서</li>
  <li>끝 문자가 단어 문자인 경우, 끝 문자 뒤에서</li>
</ol>

<p>즉 문자열의 맨 앞과 맨 끝은 비 단어인 것으로 처리된다.</p>

<p><code class="highlighter-rouge">\B</code>는 비 단어 경계로, 다음에 일치된다.</p>

<ol>
  <li>첫 문자가 비 단어 문자인 경우, 첫 문자 앞에서</li>
  <li>두 단어 문자 사이 또는 두 비 단어 문자 사이에서</li>
  <li>끝 문자가 비 단어 문자인 경우, 끝 문자 뒤에서</li>
  <li>빈 문자열에서</li>
</ol>

<p>(헷갈리는) 예시를 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">r'\b'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">r'\B'</span><span class="p">,</span> <span class="s">'a'</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">r'\b'</span><span class="p">,</span> <span class="s">'a aa'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">r'\B'</span><span class="p">,</span> <span class="s">'a aa'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['', '']
[]
['', '', '', '']
['']
</code></pre></div></div>

<p>각각 어디에서 일치된 것인지 이해해 보기 바란다.</p>

<h3 id="옵션-r-prefix">옵션: r prefix</h3>

<p>원래 r prefix란 이스케이프 문자 <code class="highlighter-rouge">\</code>를 이스케이프 처리 문자가 아닌 일반 리터럴 문자로 인식하게끔 하는 역할을 한다. <a href="https://stackoverflow.com/questions/2241600/python-regex-r-prefix">영문 설명</a>을 가져오면 아래와 같다.</p>

<blockquote>
  <p>When an “r” or “R” prefix is present, a character following a backslash is included in the string without change, and all backslashes are left in the string. For example, the string literal r”\n” consists of two characters: a backslash and a lowercase “n”. String quotes can be escaped with a backslash, but the backslash remains in the string; for example, r”"” is a valid string literal consisting of two characters: a backslash and a double quote; r”" is not a valid string literal (even a raw string cannot end in an odd number of backslashes). Specifically, a raw string cannot end in a single backslash (since the backslash would escape the following quote character). Note also that a single backslash followed by a newline is interpreted as those two characters as part of the string, not as a line continuation.</p>
</blockquote>

<p>해석하면,</p>
<blockquote>
  <p>“r”이나 “R” 접두사가 있으면, \ 뒤에 있는 문자는 문자열에 변화 없이 그대로 남아 있게 되고, 모든 \ 또한 문자열에 남아 있게 된다. 예를 들어, 리터럴 문자열 r”\n”은 \와 소문자 n 2개의 문자로 구성된다. 따옴표 문자열 역시 \가 있으면 이스케이프 처리될 수 있지만, \는 여전히 문자열에 남아 있게 된다. 예를 들어 r”\"”의 경우 \와 “ 두 개로 구성된 유효한 문자열이다. r”\“는 유효하지 않다(raw string은 홀수 개의 \로 끝날 수 없다). 특별히, raw string은 한 개의 \로 끝날 수 없다(\는 다음에 오는, 즉 문자열의 끝을 알리는 따옴표를 이스케이프 처리하므로). newline이 다음에 오는 한 개의 \는 문자열의 일부로서 두 개의 문자로 취급되지, 개행으로 처리되지 않는다.</p>
</blockquote>

<p>예시를 보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; r'\'
SyntaxError: EOL while scanning string literal
&gt;&gt;&gt; r'\''
"\\'"
&gt;&gt;&gt; '\'
SyntaxError: EOL while scanning string literal
&gt;&gt;&gt; '\''
"'"
&gt;&gt;&gt; 
&gt;&gt;&gt; r'\\'
'\\\\'
&gt;&gt;&gt; '\\'
'\\'
&gt;&gt;&gt; print r'\\'
\\
&gt;&gt;&gt; print r'\'
SyntaxError: EOL while scanning string literal
&gt;&gt;&gt; print '\\'
\
</code></pre></div></div>

<h3 id="unicodelocale-dependent-옵션">Unicode/Locale dependent 옵션</h3>

<p>파이썬3은 기본적으로 한글도 “단어 문자”에 포함되기 때문에 쓸 일이 있을지는 모르지만, 이 옵션들도 소개해 본다.</p>

<table>
  <thead>
    <tr>
      <th>syntax</th>
      <th>long syntax</th>
      <th style="text-align: center">inline flag</th>
      <th>meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>re.A</td>
      <td>re.ASCII</td>
      <td style="text-align: center">(?a)</td>
      <td>{\w, \W, \b, \B}는 ascii에만 일치</td>
    </tr>
    <tr>
      <td>re.U</td>
      <td>re.UNICODE</td>
      <td style="text-align: center">(?u)</td>
      <td>{\w, \W, \b, \B}는 Unicode에 일치</td>
    </tr>
    <tr>
      <td>re.L</td>
      <td>re.LOCALE</td>
      <td style="text-align: center">(?L)</td>
      <td>{\w, \W, \b, \B}는 locale dependent</td>
    </tr>
  </tbody>
</table>

<p>파이썬3은 기본적으로 Unicode를 기준으로 처리되기 때문에 <code class="highlighter-rouge">re.U</code>는 쓸모가 없다. 그러나 호환성을 위해 아직까지는 살아 있는 옵션이다.<br />
아스키에만 일치하는 옵션을 쓰고 싶으면 <code class="highlighter-rouge">re.ASCII</code> 옵션을 사용하면 된다.</p>

<p>조금 더 자세한 설명은 <a href="https://docs.python.org/3/library/re.html#module-contents">여기</a>를 참조하라.</p>

<p>다른 flags 사용법과 똑같으므로 생략하도록 하겠다.</p>

<hr />

<h2 id="--a-z-문자열-전체-또는-행의-시작이나-끝의-대상을-대조"><code class="highlighter-rouge">^</code>, $, \A, \Z: 문자열 전체 또는 행의 시작이나 끝의 대상을 대조</h2>

<p><code class="highlighter-rouge">\A</code>는 문자열 시작을, <code class="highlighter-rouge">\Z</code>는 문자열 끝과 일치된다.</p>

<p>이들은 일명 앵커라고 부르는데, 문자와 일치되는 것이 아니라 정규식 패턴을 특정 위치에 고정시켜서 그 위치에 일치시키는 역할을 한다.</p>

<p><code class="highlighter-rouge">^</code>와 <code class="highlighter-rouge">$</code>는 기본적으로 행 시작과 행 끝에 일치된다.</p>

<p>여기서 행은 문자열의 시작과 개행문자 사이, 개행문자와 개행문자 사이, 개행문자와 문자열의 끝 사이 부분이다. 문자열에 개행문자가 없으면 전체 문자열이 한 개의 행이 된다.</p>

<p><code class="highlighter-rouge">^</code>와 <code class="highlighter-rouge">$</code>는 일반적으로 <code class="highlighter-rouge">\A</code>와 <code class="highlighter-rouge">\Z</code> 앵커와 효과가 같다. 다른 경우는 옵션을 설정하는 경우인데, re.MULTILINE 옵션을 설정하면 <code class="highlighter-rouge">^</code>와 <code class="highlighter-rouge">$</code>는 문자열 전체의 시작/끝이 아닌 행의 시작/끝에서 일치된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'\Aryan\d\Z'</span><span class="p">,</span> <span class="s">'ryan1'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'^ryan\d$'</span><span class="p">,</span> <span class="s">'ryan1'</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'\A ryan\d\s\Z'</span><span class="p">,</span> <span class="s">' ryan1 </span><span class="se">\n</span><span class="s"> ryan2 </span><span class="se">\n</span><span class="s"> rain1 </span><span class="se">\n</span><span class="s"> ryan3 '</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'^ ryan\d\s$'</span><span class="p">,</span> <span class="s">' ryan1 </span><span class="se">\n</span><span class="s"> ryan2 </span><span class="se">\n</span><span class="s"> rain1 </span><span class="se">\n</span><span class="s"> ryan3 '</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'^ ryan\d\s$'</span><span class="p">,</span> <span class="s">' ryan1 </span><span class="se">\n</span><span class="s"> ryan2 </span><span class="se">\n</span><span class="s"> rain1 </span><span class="se">\n</span><span class="s"> ryan3 '</span><span class="p">,</span> <span class="n">re</span><span class="p">.</span><span class="n">M</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'^ ryan\d\s$'</span><span class="p">,</span> <span class="s">' ryan1 </span><span class="se">\n</span><span class="s"> ryan2 </span><span class="se">\n</span><span class="s"> rain1 </span><span class="se">\n</span><span class="s"> ryan3 '</span><span class="p">,</span> <span class="n">re</span><span class="p">.</span><span class="n">MULTILINE</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['ryan1']
['ryan1']
[]
[]
[' ryan1 ', ' ryan2 ', ' ryan3 ']
[' ryan1 ', ' ryan2 ', ' ryan3 ']
</code></pre></div></div>

<p>Java, .NET 등에서는 <code class="highlighter-rouge">\z</code> 옵션이 있지만, 파이썬에는 bad escape 에러를 보게 되므로 사용하지 말자.</p>

<p>응용으로, 빈 문자열 혹은 빈 행을 검사할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s">'\A\Z'</span><span class="p">,</span> <span class="s">''</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s">'\A\Z'</span><span class="p">,</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s">'^$'</span><span class="p">,</span> <span class="s">''</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s">'^$'</span><span class="p">,</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'^$'</span><span class="p">,</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">,</span> <span class="n">re</span><span class="p">.</span><span class="n">M</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;_sre.SRE_Match object; span=(0, 0), match=''&gt;
None
&lt;_sre.SRE_Match object; span=(0, 0), match=''&gt;
None
['', '']
</code></pre></div></div>

<p><code class="highlighter-rouge">^</code>, <code class="highlighter-rouge">$</code>도 마침표 <code class="highlighter-rouge">.</code>처럼 옵션을 인라인으로 설정할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'(?m)^$'</span><span class="p">,</span> <span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['', '']
</code></pre></div></div>

<p>참고로, 옵션을 여러 개 쓰려면 <code class="highlighter-rouge">|</code>로 OR 연산을 시켜주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'^ ryan\d\s$'</span><span class="p">,</span> <span class="s">' ryan1 </span><span class="se">\n</span><span class="s"> Ryan2 </span><span class="se">\n</span><span class="s"> rain1 </span><span class="se">\n</span><span class="s"> RYAN3 '</span><span class="p">,</span> <span class="n">re</span><span class="p">.</span><span class="n">M</span> <span class="o">|</span> <span class="n">re</span><span class="p">.</span><span class="n">IGNORECASE</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[' ryan1 ', ' Ryan2 ', ' RYAN3 ']
</code></pre></div></div>

<p>위의 예시처럼 full-name과 약자를 같이 써도 되지만, 가독성을 생각한다면 굳이 그렇게 할 이유는 없다.</p>

<h2 id="유니코드-번호">유니코드 번호</h2>

<p>한 글자 일치와 사용법은 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'</span><span class="se">\u18ff</span><span class="s">\d'</span><span class="p">,</span> <span class="s">'0᣿1頶᣿2䅄ሲ᣿3456'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['\u18ff1', '\u18ff2', '\u18ff3']
</code></pre></div></div>

<p>참고로 ‘\u18ff’는 ‘᣿’이다.</p>

<hr />

<p><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/22/regex-usage-03-basic/">다음 글</a>에서는 다자택일(OR), 반복 등을 다루도록 하겠다.</p>

    </article>
    <div class="post-more">
      
      <a href="/regex-usage-02-basic/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/regex-usage-02-basic/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/blog/page15">Older</a>
  
  
    
      <a class="pagination-item newer" href="/blog/page13">Newer</a>
    
  
</div>


  </div>
</div>

<label for="sidebar-checkbox" class="sidebar-toggle"></label>

<script>
  (function (document) {
    let toggle = document.querySelector('.sidebar-toggle');
    let sidebar = document.querySelector('#sidebar');
    let checkbox = document.querySelector('#sidebar-checkbox');

    document.addEventListener('click', function (e) {
      let target = e.target;

      if (target === toggle) {
        checkbox.checked = !checkbox.checked;
        e.preventDefault();
      } else if (checkbox.checked && !sidebar.contains(target)) {
        /* click outside the sidebar when sidebar is open */
        checkbox.checked = false;
      }
    }, false);
  })(document);
</script>

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    };
    i[r].l = 1 * new Date();
    a = s.createElement(o);
    m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

  ga('create', 'UA-00000000-1', 'auto');
  ga('send', 'pageview');
</script>


<!-- Naver Analytics -->	
<script type="text/javascript" src="//wcs.naver.net/wcslog.js"></script>
<script type="text/javascript">
  if(!wcs_add) var wcs_add = {};
    wcs_add["wa"] = "18cbce78e94161";
  wcs_do();
</script>

</body>

<script id="dsq-count-scr" src="//greeksharifa-github-io.disqus.com/count.js" async></script>

</html>
