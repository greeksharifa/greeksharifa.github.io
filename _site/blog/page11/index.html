<!DOCTYPE html>
<html lang="en-us">
<head>
  <head>
  <!-- Description of Blog -->
  <meta name="description" content="Python, Machine & Deep Learning">
  <link rel="canonical" href="https://greeksharifa.github.io/">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Python, Machine & Deep Learning">
  <meta property="og:description" content="Python, Machine Learning & Deep Learning 설명서">
  <meta property="og:image" content="https://greeksharifa.github.io/public/img/icon-144x144.png">
  <meta property="og:url" content="https://greeksharifa.github.io/">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Python, Machine & Deep Learning">
  <meta name="twitter:description" content="Python, Machine Learning & Deep Learning 설명서">
  <meta name="twitter:image" content="https://greeksharifa.github.io/public/img/icon-144x144.png">
  <meta name="twitter:domain" content="https://greeksharifa.github.io/">

  <!-- link -->
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/main.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="icon-144x144" sizes="144x144" href="/public/img/icon-144x144.png">
  <link rel="shortcut icon" href="/public/img/icon_32x32.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"> </script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });
  </script>
  

  <!-- Ads -->
  <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
  </script>
</head>

  <!-- for Google AdSense-->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-9951774327887666",
    enable_page_level_ads: true
  });
</script>

  <style>blockquote {
    font-size: 1em;
    line-height: 1.4
  }</style>
  <link href='http://fonts.googleapis.com/css?family=Gill+Sans' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Consolas' rel='stylesheet' type='text/css'>
</head>
<body>

<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <div class="sidebar-personal-info">
      <div class="sidebar-personal-info-section">
        <a href="http://gravatar.com/3c2986ad7ac1f2230ea3596f44563328">
          <img src="/public/img/maple_tree.jpg" title="Cover Photo" alt="Maple tree" />
        </a>
      </div>
      <div class="sidebar-personal-info-section">
        <p><strong>Developer and Analyst</strong>, YW & YY.</p>
      </div>
      
      
      
      <div class="sidebar-personal-info-section">
        <p> Follow me:
        
        
        
        <a href="https://github.com/greeksharifa">
          <i class="fa fa-github" aria-hidden="true"></i>
        </a>
        
        |
        
        
        
        <a href="mailto:greeksharifa@gmail.com">
          <i class="fa fa-envelope" aria-hidden="true"></i>
        </a>
        
        
        
        </p>
      </div>
      
    </div>
  </div>

  <nav class="sidebar-nav">
    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/">
          Home
        </a>

        
      </span>

    
      
      
      

      

      <span class="foldable">
        <a class="sidebar-nav-item " href="/blog/">
          Blog
        </a>

        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/categories/">
                Categories
              </a>
          
        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/tags/">
                Tags
              </a>
          
        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/about/">
          About
        </a>

        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="http://greeksharifa.github.io/">
          Github Project
        </a>

        
      </span>

    

  </nav>

  <div class="sidebar-item">
    <p>
    &copy; 2020 YW & YY. This work is liscensed under <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a>.
    </p>
  </div>

  <div class="sidebar-item">
    <p>
    Powered by <a href="http://jekyllrb.com">jekyll</a> and <a href="http://greeksharifa.github.io">YW & YY</a>
    </p>
  </div>
</div>


<!-- Wrap is the content to shift when toggling the sidebar. We wrap the
     content to avoid any CSS collisions with our real content. -->
<div class="wrap">
  <div class="masthead">
    <div class="container">
      <h3 class="masthead-title" align="center">
        <a href="/" title="Home" title="YW & YY">
          <img class="masthead-logo" src="/public/img/logo.png"/>
        </a>
        <small>YW & YY's Python, Machine & Deep Learning</small>
        <!-- HTML elements for search -->
        <a href="/search/" id="search_icon">
          <img src="/public/img/search.png" width="25" height="25"
               align="right" style="margin-top:5px; margin-bottom:0;"
               onmouseover="this.style.opacity=0.7" onmouseout="this.style.opacity=0.5"
               alt="search">
        </a>
      </h3>
    </div>
  </div>

  <div class="container content">
    <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/paper_review/2018/09/10/RNN-Encoder-Decoder/">
        RNN Encoder-Decoder
      </a>
    </h1>

    <span class="post-date">10 Sep 2018</span>
     |
    
    <a href="/blog/tags/#rnn" class="post-tag">RNN</a>
    
    <a href="/blog/tags/#paper-review" class="post-tag">Paper_Review</a>
    
    

    <article>
      <h3 id="learning-phrase-representations-using-rnn-encoder-decoder-for-statistical-machine-translation">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</h3>
<blockquote>
  <p>본 글은 Kyunghyun Cho, Bart van Merrienboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, Yoshua Bengio가 2014년에 Publish한 위 논문을 리뷰한 것이다.</p>
</blockquote>

<p><strong>Abstract</strong><br />
Encoder의 역할은 a sequence of symbols를 고정된 길이의 vector representation으로 나타내는 것이고, Decoder의 역할은 그 representation을 다시 sequence of symbols로 나타내는 것이다.</p>

<p>두 모델은 jointly train되는데, 그 목적은 source sequence가 주어졌을 때,<br />
target sequence가 나타날 조건부 확률을 최대화하는 것이다.<br />
= (Maximize the conditional probability of a target sequence given a source sequence.)</p>

<p><strong>Introduction</strong><br />
본 논문은 SMT(Statistical Machine Translation)의 영역에서 모델을 분석하는 것을 주요 목적으로 하고 있다.</p>

<p>연구자들은 memor capacity와 학습 효율을 향상시키기 위해 다소 복잡한(sophiscated) Hidden Unit을 사용하였으며, 영어를 프랑스어로 번역하는 과정을 통해 그 성능을 평가하였다.</p>

<p>본 논문에서 제안한 RNN Encoder의 경우 phrase table에서 언어학적 규칙(regularities)을 잡아내는 역할을 수행하였으며 이는 사실 전반적인 번역 성능의 향상을 꾀하는 과정의 일부로 평가된다. Decoder의 경우 phrase의 continuous space representation을 학습하는데, 이는 phrase의 의미론적(semantic)이고 통사론적(syntactic) 구조를 저장하는 역할을 수행한다.</p>

<p><strong>RNN Encoder-Decoder</strong><br />
기본적인 RNN은 sequence에서 다음 symbol을 예측하는 방향으로 학습됨으로써 sequence의 확률 분포를 학습한다.<br />
이 때 시간t에 대한 output은 $ p(x_t | x_{t-1}, …, x_1) $와 같은 조건부 확률로 표현된다.<br />
따라서 sequence <strong>x</strong>의 확률은 아래와 같이 표현할 수 있다.</p>

<script type="math/tex; mode=display">p(x) = \prod_{t=1}^T p(x_t | x_{t-1}, ..., x_1)</script>

<p>(위 $p(x)$의 x는 <strong>x</strong> vector이며, 위와 같은 식으로 표현되는 이유는 곱셈정리에 의한 것임)<br />
이전의 symbol들에 근거하여 다음 symbol을 예측한다고 볼 수 있다.</p>

<p>본 논문에서 제안하는 RNN Encoder-Decoder 모델은 다소 새로운 구조를 갖고 있다. Encoder는 input sequence <strong>x</strong>의 원소 symbol들을 연속적으로 읽어 들인다.<br />
(reads each symbol of an input sequence <strong>x</strong> sequentially)</p>

<p>이 과정 속에서 시간 t의 hidden state는 아래와 같이 업데이트 된다.</p>

<script type="math/tex; mode=display">% <![CDATA[
h_{<t>} = f(h_{<t-1>}, x_t) %]]></script>

<p>즉, 이전 hidden state와 시간t의 새로운 input $x_t$에 의해 업데이트 되는 것이다.<br />
모든 reading이 끝나고 나서 나면 RNN의 hidden state는 모든 input sequence에 대한 summary <strong>c</strong>이다.</p>

<center><img src="/public/img/Paper_Review/2018-09-10-RNN-Encoder-Decoder/r1.jpg" width="50%" /></center>

<p>Decoder는 주어진 hidden state $h_{<t-1>}$을 바탕으로  
다음 symbol $ y_{<t>} $를 예측함으로써 output sequence를 생성하도록 학습된다.</t></t-1></p>

<p>다만 여기서 주목할 점은, 기본 RNN과 달리 새로운 hidden state는 summary <strong>c</strong>와<br />
이전 output symbol $ y_{t-1} $에도 conditioned 되어 있다는 것이다.<br />
즉 아래와 같이 표현될 수 있다.</p>

<script type="math/tex; mode=display">% <![CDATA[
h_{<t>} = f(h_{<t-1>}, y_{t-1}, c) %]]></script>

<p>다음 symbol의 조건부 확률 분포는 아래와 같이 나타낼 수 있다.</p>

<script type="math/tex; mode=display">% <![CDATA[
P(y_t | y_{t-1}, ..., y_1, c) = g(h_{<t>}, y_{t-1}, c) %]]></script>

<p>정리하자면, RNN Encoder-Decoder의 두 성분은 아래의 조건부 로그 가능도를 최대화하도록 결합하여 학습된다.</p>

<script type="math/tex; mode=display">\max_{\theta} {1 \over N} \sum_{n=1}^N log p_{\theta} (y_n|x_n)</script>

<p>여기서 $\theta$는 모델 parameter의 집합을 의미하며,<br />
$y_n$은 output sequence를 $x_n$은 input sequence를 의미한다.</p>

<p>이렇게 학습된 RNN Encoder-Decoder는 크게 2가지 방법으로 활용될 수 있다.</p>
<ol>
  <li>주어진 input sequence에 대해 새로운 target sequence를 생성할 수 있다.</li>
  <li>input &amp; output sequences 쌍의 적합성을 평가할 수 있다. (Score)</li>
</ol>

<p>2.3절인 <em>Hidden Unit that Adatively Remembers and Forgets</em>부분은 LSTM Unit의 기본 형식을 따르고 있기 때문에 식에 대한 리뷰는 생략하겠다. 다만 사용된 용어만을 살펴 보면 아래과 같다.</p>

<p>Reset Gate $r_j$, Update Gate $z_j$, Proposed Unit $h_j^{t}$</p>

<p>효과에 대해 설명하자면,</p>
<ol>
  <li>Reset Gate가 0에 가까워질 때, 시간 t의 <strong>Candidate hidden state</strong>는 이전 hidden state를 잊고(ignore, forget) 시간 t의 현재 input x로 Reset하게 된다.</li>
  <li>Updated Gate는 이전(시간 t-1) hidden state의 정보가 얼마나 현재(시간 t) hidden state에 영향을 줄 것인가를 결정한다. 이를 통해 lont-term 정보를 효과적으로 보존(rembember)한다.</li>
  <li>각각의 hidden unit은 Reset/Update Gate를 각각 갖고 있기 때문에, different time scales에 나타나는 종속성(dependencies)를 포착(capture)하는 법을 학습하게 된다. short-term dependencies를 포착하는 법을 학습한 unit들의 Reset Gate는 자주 활성화 될 것이며, long-term dependencies를 포착하는 법을 학습한 unit들의 Update Gate는 자주 활성화될 것이다.</li>
</ol>

<p><strong>Statistical Machine Translation: SMT</strong><br />
앞에서도 설명하였듯이 SMT의 기본 목표는 주어진 source sentence에 대하여 translation을 찾는 것이고, 식으로 표현하자면 아래와 같다.</p>

<script type="math/tex; mode=display">p(f|e) \propto p(e|f) * p(f)</script>

<p>일단 Phrase Pairs를 평가하는 측면에서 본 모델을 살펴보도록 하겠다.<br />
RNN Encoder-Decoder를 학습시킬 때, 기존 말뭉치들에서 각각의 phrase pair들의 출현 빈도는 고려하지 않는다.<br />
그 이유는 2가지로 풀이 된다.</p>
<ol>
  <li>계산량 감소를 위해서이다.</li>
  <li>본 모델이 단순히 출현빈도 Rank에 영향을 받지 않게 하기 위함이다.</li>
</ol>

<p>사실 phrase 속에 존재하는 translation probability는 이미 원래 corpus의 phrase pairs의 출현 빈도를 반영한다. 모델이 학습 과정 속에서 이러한 출현 빈도에 따른 어떤 규칙을 학습하는 것이 아니라, 언어학적 규칙(linguistic regularities)을 학습하도록 하는 것이 핵심이라고 할 수 있다.<br />
(learning the manifold of plausible translations)</p>

<p><strong>Experiments</strong><br />
대규모의 데이터가 구축되었지만 실제 학습을 위해서 본 논문의 저자는 source &amp; target vocab을 가장 자주 등장한 15,000개의 단어로 한정하였다. 이는 전체 데이터셋의 93%를 커버한다고 밝혔다.</p>

<p>학습과정에 대한 자세한 사항은 논문을 참조하기 바란다.</p>

<p><strong>Conclusion</strong><br />
결과적으로 RNN Encoder-Decoder는 phrase pairs 내에 있는 언어학적 규칙을 포착하고, 적절하게 구성된 target phrases 또한 제안하는 데에도 좋은 성능을 보이는 것으로 확인되었다.</p>

<p><strong>Structure of Encoder</strong><br />
source phrase X와 Y의 형태는 아래와 같다.</p>

<script type="math/tex; mode=display">X = (x_1, x_2, ... , x_N), Y = (y_1, y_2, ... , y_N)</script>

<p>X.shape = (N, K), Y.shape = (N, K)</p>

<p>물론 여기서 각 세로 벡터는 one-hot vector이다.<br />
source phrase의 각 단어는 500차원의 벡터로 임베딩된다.<br />
Encoder의 Hidden state는 1000개의 unit을 갖고 있다.<br />
(시간 t의 hidden state $h_{<t-1>}$의 shape = (1000, 1))</t-1></p>

<p>위 hidden state가 계산되는 과정을 살펴보면,</p>
<ol>
  <li>Reset Gate<br />
<script type="math/tex">% <![CDATA[
r = \sigma(W_r e(x_t) + U_r h_{<t-1>}) %]]></script></li>
</ol>

<p>(1000, 1) = (1000, 500) X (500, 1) + (1000, 1000) X (1000, 1)</p>

<ol>
  <li>Update Gate<br />
<script type="math/tex">% <![CDATA[
z = \sigma(W_z e(x_t) + U_z h_{<t-1>}) %]]></script></li>
</ol>

<p>shape은 위와 같다.</p>

<ol>
  <li>Candidate<br />
<script type="math/tex">% <![CDATA[
\tilde{h}^{<t>} = tanh(W e(x_t) + U(r \odot h_{<t-1>} )) %]]></script></li>
</ol>

<p>(1000, 1) = (1000, 500)X(500, 1) + (1000, 1000)X(1000, 1)$\odot$(1000, 1)</p>

<ol>
  <li>
    <p>Hidden State<br />
<script type="math/tex">% <![CDATA[
h^{<t>} = z h^{<t-1>} + (1-z) \tilde{h}^{<t>} %]]></script></p>
  </li>
  <li>
    <p>Representatino of the source phrase: 농축된 정보<br />
<script type="math/tex">% <![CDATA[
c = tanh(V h^{<t>}) %]]></script></p>
  </li>
</ol>

<p><strong>Structure of Decoder</strong><br />
Soon to be updated</p>


    </article>
    <div class="post-more">
      
      <a href="/paper_review/2018/09/10/RNN-Encoder-Decoder/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/paper_review/2018/09/10/RNN-Encoder-Decoder/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/paper_review/2018/09/07/Vehicle-Color-Recognition/">
        Vehicle Color Recognition
      </a>
    </h1>

    <span class="post-date">07 Sep 2018</span>
     |
    
    <a href="/blog/tags/#cnn" class="post-tag">CNN</a>
    
    <a href="/blog/tags/#paper-review" class="post-tag">Paper_Review</a>
    
    

    <article>
      <h3 id="vehicle-color-recognition-using-cnn">Vehicle Color Recognition using CNN</h3>
<blockquote>
  <p>본 글은 Reza Fuad Rachmadi, I Ketut Eddy Purnama가 2018년에 Publish한 위 논문을 리뷰한 것이다.</p>
</blockquote>

<p><strong>Introduction</strong><br />
본 논문의 목표는 Color Distribution에 기반하여 CNN을 통해 색깔을 classify하는 것이다. RGB의 경우 정확히 분포로 분류할 수 없기 때문에 CIE Lab과 HSV로 변환 후 분석에 들어가도록 하였다. 데이터셋은 Vehicle(자동차)로 정하였다. (p1)</p>

<p>Color Detection이 쉽지 않은 이유는 여러가지가 있지만 대표적인 예로, 날씨의 변화, 영상/이미지의 품질 차이, 문양/패턴의 차이 등을 들 수 있다.<br />
또한 이와 더불어 명백한 단색을 제외하고는 사람에 따라 색깔 인식 내지는 분류를 하는 방식이 다르기 때문이다.<br />
이렇기 때문에 사실 그 물체의 어떤 부분을 확인하여 색깔 구분의 핵심으로 삼는지가 굉장히 중요한 방법이다. 예를 들어 ‘차’의 색깔을 구분한다고 할 때, 타이어의 색깔로 구분을 짓는 사람은 별로 없을 것이다. 그보다는 차체의 보닛을 중심으로 색깔을 구분할 것이다.<br />
이 때문에 Region Selection 역시 색깔 구분에 있어 핵심적인 역할을 수행한다.</p>

<p><strong>CNN Architecture</strong><br />
구조는 일반적인 CNN에서 특별히 변화된 부분이 없다. 사실 Alexnet과 거의 유사한 형태를 지녔고, 마지막에 많은 수의 Parameter를 포함하는 Fully Connected Layer를 삽입하였기 때문에, 학습에 시간이 조금 소요될 것으로 예상되었다.</p>

<p><strong>Results and Discusssion</strong><br />
결과는 나쁘지 않은 수준이다. 이 논문의 경우 특별히 다른 방법을 적용하였다기 보다는 기본 CNN을 적용하여 8개의 단색에 대해 Classification을 수행하였기 때문에, 기본적인 구조로도 충분한 결과를 얻은 것으로 보인다.<br />
다만 Gray와 Green 색깔 구분에 있어 약간의 어려움을 겪었고 (정확도가 대략 10% 가까이 떨어짐), Gray와 White 색깔 구분 역시도 약간의 어려움을 겪은 것으로 결과가 나타났다.<br />
이는 사실상 색깔이란 것이 이산형으로 보기 어려운 구분 방식을 따르기 때문으로 풀이된다.<br />
논문은 구분 논리에 대해 자세히 설명하고 있지는 않지만, 첫 번째 CNN Layer가 low-level feature를 추출한다는 설명을 제공하고 있다. 이는 다른 Object Detection과 크게 다르지 않은 논리이다.<br />
이후 Lyaer들은 차량의 전면 부분의 이미지를 추출하여 Color Detection의 핵심적인 부분으로 삼고 있는 것을 확인할 수 있었으며, 이는 사람의 인식 방법과 유사함을 알 수 있다.</p>

<p><strong>추가적 논의</strong><br />
이 부분은 논문에 게재된 내용이 아니고, 필자가 다른 작은 프로젝트를 수행하면서 다른 접근법에 대해 생각해보다가 이해한 내용을 덧붙인 것이다.</p>

<p>Superpixel이란 개념이 있다. Segmentation에 있어 상당히 많이 사용되는 개념인데, 유사한 pixel 값들을 하나의 평균 값으로 묶어서 표현하는 것이다.<br />
Segment의 수에 따라 마치 blur처리를 한 듯한 느낌이 들기도 한다.</p>

<p>이를 구현하는 방법은 여럿 있겠지만 skimage라는 파이썬 패키지가 매우 유용하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">image_path</span> <span class="o">=</span> <span class="s">'~/target.jpg'</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">load_img</span><span class="p">(</span><span class="n">image_path</span><span class="p">,</span> <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">))</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">img_to_array</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">/</span><span class="mf">255.</span>

<span class="c1"># n_segments: 몇 개의 구역으로 나누고 싶은가?
</span><span class="n">labels</span> <span class="o">=</span> <span class="n">segmentation</span><span class="p">.</span><span class="n">slic</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">compactness</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">regions</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="n">input_img</span> <span class="o">=</span> <span class="n">color</span><span class="p">.</span><span class="n">label2rgb</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">'avg'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">input_img</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>
<p>위와 같은 코드를 이미지에 적용하면 Superpixel을 구현할 수 있다. 이렇게 유사한 Pixel들을 묶어 색깔의 다양성을 줄이고 나면, 색깔 판별에 좀 더 도움이 될 것으로 판단하였다.</p>

<p>이후에 색깔을 추출해 내는 방법은 크게 2가지가 있을 것으로 생각된다.<br />
먼저 이후에 CNN을 적용하여 위 논문과 유사한 방식으로 색깔을 하나 판별해 내는 것인데, 이 역시 괜찮은 성능을 보이는 것으로 확인되었다.<br />
그런데 만약 색깔이 여러개라면? 단색이 아니라, 줄무늬 내지는 물방울 문양을 가진 옷을 판별해야 하다면?<br />
이 때는 Superpixel화 된 이미지 데이터에 Kmeans Clustering을 적용하여 유사한 색깔들을 소수의 군집으로 묶고, 이 중 높은 빈도수를 보이는 색깔들을 중심 색깔들로 추출할 수 있을 것이다.</p>

<p>아래 블로그에서 예시를 찾을 수 있었다.<br />
https://technology.condenast.com/story/handbag-brand-and-color-detection</p>


    </article>
    <div class="post-more">
      
      <a href="/paper_review/2018/09/07/Vehicle-Color-Recognition/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/paper_review/2018/09/07/Vehicle-Color-Recognition/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/paper_review/2018/09/07/GRU/">
        GRU
      </a>
    </h1>

    <span class="post-date">07 Sep 2018</span>
     |
    
    <a href="/blog/tags/#sequence-modeling" class="post-tag">Sequence_Modeling</a>
    
    <a href="/blog/tags/#rnn" class="post-tag">RNN</a>
    
    <a href="/blog/tags/#paper-review" class="post-tag">Paper_Review</a>
    
    

    <article>
      <h3 id="empirical-evaluation-of-gated-recurrent-nn-on-sequence-modeling">Empirical Evaluation of Gated Recurrent NN on Sequence Modeling</h3>
<blockquote>
  <p>본 글은 Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, Yoshua Bengio가 2014년에 publish한 Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling을 리뷰한 것이다.</p>
</blockquote>

<p><strong>Background</strong><br />
RNN은 전통적인 feedforward NN의 확장판으로 이해할 수 있다. 가장 큰 특징 중 하나는 이 네크워크는 variable-length sequence input을 처리할 수 있다는 것이다.(p1)<br />
본 논문은 LSTM과 GRU의 비교를 main purpose로 두고 있다.<br />
그 이유는 LSTM이 효과적이기는 하나 상대적으로 복잡한 구조를 갖고 있기도 하고,<br />
제안된 GRU가 구조가 조금 더 단순함에도 불구하고 일부 경우에서 더 나은 성능을 보였기 때문이다.</p>

<p><strong>Long Short-Term Memory Unit</strong></p>
<blockquote>
  <p>LSTM Unit의 구조는 아래와 같다.</p>
</blockquote>

<center><img src="/public/img/Paper_Review/2018-09-07-GRU/G1.png" width="50%" /></center>

<p>시간 t에 대하여 j번 째 LSTM Unit은 아래와 같은 구조를 가진다.</p>

<p>Candidate $ \tilde{c} $에 대하여<br />
<script type="math/tex">\tilde{c}_t^j = tanh(W_c * x_t + U_c * h_{t-1})^j</script></p>

<p>Memory Cell $c$에 대하여<br />
<script type="math/tex">c_t^j = f_t^j * c_{t-1}^j + i_{t}^j * \tilde{c}_t^j</script></p>

<p>Output Gate $o$에 대하여<br />
<script type="math/tex">{o}_t^j = \sigma(W_o * x_t + U_o * h_{t-1} + V_o * c_t)^j</script></p>

<p>Output $h$에 대하여<br />
<script type="math/tex">h_t^j = o_t^j * tanh(c_t^j)</script></p>

<p>LSTM 구조의 핵심은 총 3개의 Gate(Input Gate, Forget Gate, Output Gate)를 통해 저장될 정보를 적절히 컨트롤한다는 것이다.<br />
<strong>Forget Gat</strong>의 경우 $ c_{t-1}^j $ (과거 정보)를 버릴 것인지 말 것인지를 결정하고,<br />
<strong>Input Gate</strong>의 경우 시간 t의 candidate로 업데이트를 할 것인지 말 것인지를 결정하게 된다.<br />
최종적으로 <strong>Output Gate</strong> $ o_{t}^j $는 hyperbolic tangent activation function을 통과한 $ c_t^j $와 곱해져 <strong>Output</strong> $ h_t^j $를 형성하게 된다.</p>

<p><strong>Gated Recurrent Unit</strong></p>
<blockquote>
  <p>GRU Unit의 구조는 아래와 같다.</p>
</blockquote>

<center><img src="/public/img/Paper_Review/2018-09-07-GRU/G2.png" width="50%" /></center>

<p>시간 t에 대하여 j번 째 GRU Unit은 아래와 같은 구조를 가진다.</p>

<p>Reset Gate $r$에 대하여<br />
<script type="math/tex">{r}_t^j = \sigma(W_r * x_t + U_r * h_{t-1})^j</script></p>

<p>Candidate $ \tilde{h} $에 대하여<br />
<script type="math/tex">\tilde{h}_t^j = tanh(W * x_t + U * (r_t \odot h_{t-1})^j</script></p>

<p><strong>Reset Gate</strong>는 과거의 Activation value ($ h_{t-1} $)이 새로운 후보 $\tilde{h}_{t}$에 영향을 줄 것인지 말 것인지를 결정하는 관문의 역할을 한다.</p>

<p>만약 위의 Reset Gate이 0에 가까울 경우, 바로 위의 식의 오른쪽 부분이 0이 됨으로써, 
자연스럽게 과거의 값 ($h_{t-1}$)을 잊게 해준다. (Forget) 참고로 식의 오른쪽 편의 $\odot$은 Elementwise Multiplication을 뜻한다.</p>

<p>자 이제 <strong>Candidate</strong>이 준비되었다.</p>

<p>Memory Cell $c$에 대하여<br />
<script type="math/tex">c_t^j = f_t^j * c_{t-1}^j + i_{t}^j * \tilde{c}_t^j</script></p>

<p>Update Gate $z$에 대하여<br />
<script type="math/tex">{z}_t^j = \sigma(W_z * x_t + U_z * h_{t-1})^j</script></p>

<p>이 <strong>Update Gate</strong>는 얼마나 새로운 값으로 업데이트하고 싶은지를 결정하게 되는데, 이 말은 아래 식에서 이 <strong>Update Gate</strong>의 값이 0에 가까울 경우 (sigmoid를 통과하였으므로) <strong>Candidate</strong>의 영향력은 0가 되는 것이고, 이전 Activation $h_{t-1}$이 그대로 살아남는 것을 의미한다.</p>

<p>Output $h$에 대하여<br />
<script type="math/tex">h_t^j = (1- z_t^j) * h_{t-1}^j + z_t^j * \tilde{h}_t)^j</script></p>

<p><strong>Discussion</strong><br />
LSTM과 GRU가 기존의 traditional한 구조와 가장 차별화되는 포인트는 아래와 같다.<br />
1) 각각의 Unit은 여러 단계에 걸친 input stream에 있어 구체적인 feature의 존재를 지속적으로 기억하는 데에 있어 좋은 성능을 발휘한다.<br />
즉, 긴 길이의 Sequence를 Input으로 받는다 하더라도 초기의 정보에 대해 큰 소실 없이 저장이 가능하다는 뜻이다.</p>

<p>2) 일종의 Shortcut path를 만들어 오차가 vanish하지 않고 적절하게 역전파될 수 있도록 한다.</p>

<p><strong>Experiments and Results</strong></p>
<blockquote>
  <p>Sequence Modeling은 여러 sequences에 대한 확률 분포를 학습하는 것을 목적으로 한다.</p>
</blockquote>

<p>즉, training sequences에 대하여 아래와 같은 model의 log-likelihood를 최대화하는 것을 목적으로 한다.</p>

<script type="math/tex; mode=display">\underset{x}{\mathrm{max}} \frac{1}{N} \sum_{n=1}^{N} \sum_{n=1}^{T_n} logp(x_t^n | x_1^n, ..., x_(t-1)^n; \theta )</script>

<p>여기서 $\theta$는 model parameters를 뜻한다.</p>

<p>결과만을 요약하자면, GRU와 LSTM이 traditional tanh-RNN를 능가하는 것은 명확하게 확인되었지만, GRU와 LSTM의 비교우위를 판별하기 위해서는 추가적인 연구가 필요하다고 확인되었다.<br />
(비록 GRU과 하나의 데이터셋을 제외하고는 근소하게 LSTM를 능가했지만)</p>

<p>*데이터셋은 polyphonic music data와 raw speech signal data를 사용하였다.</p>


    </article>
    <div class="post-more">
      
      <a href="/paper_review/2018/09/07/GRU/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/paper_review/2018/09/07/GRU/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/24/regex-usage-09-other-functions/">
        파이썬 정규표현식(re) 사용법 - 09. 기타 기능
      </a>
    </h1>

    <span class="post-date">24 Aug 2018</span>
     |
    
    <a href="/blog/tags/#regex" class="post-tag">Regex</a>
    
    <a href="/blog/tags/#re" class="post-tag">re</a>
    
    

    <article>
      <hr />

<p><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/20/regex-usage-01-basic/">파이썬 정규표현식(re) 사용법 - 01. Basic</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/21/regex-usage-02-basic/">파이썬 정규표현식(re) 사용법 - 02. 문자, 경계, flags</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/22/regex-usage-03-basic/">파이썬 정규표현식(re) 사용법 - 03. OR, 반복</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/28/regex-usage-04-intermediate/">파이썬 정규표현식(re) 사용법 - 04. 그룹, 캡처</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/04/regex-usage-05-intermediate/">파이썬 정규표현식(re) 사용법 - 05. 주석, 치환, 분리</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/05/regex-usage-06-advanced/">파이썬 정규표현식(re) 사용법 - 06. 치환 함수, 양방탐색, 조건문</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/06/regex-usage-07-example/">파이썬 정규표현식(re) 사용법 - 07. 예제(숫자)</a><br />
<a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/06/regex-usage-08-example/">파이썬 정규표현식(re) 사용법 - 08. 예제(단어, 행)</a><br />
<strong><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/24/regex-usage-09-other-functions/">파이썬 정규표현식(re) 사용법 - 09. 기타 기능</a></strong></p>

<hr />

<p>이 글에서는 <strong>re</strong> 패키지에 포함된, 지금까지의 글에서 다루지 않았던 함수와 속성 등을 다루도록 하겠다.</p>

<p>본 글에서 정규표현식은 <code class="highlighter-rouge">regex</code>와 같이, 일반 문자열은 ‘regex’와 같이 표시하도록 한다.</p>

<p>파이썬 버전은 3.6을 기준으로 하나, 3.x 버전이면 (아마) 동일하게 쓸 수 있다.<br />
2.7 버전은 한글을 포함한 비 알파벳 문자 처리가 다르다.</p>

<hr />

<h2 id="함수">함수</h2>

<h3 id="reescapestring">re.escape(string)</h3>

<p><strong>re.escape</strong> 함수는 문자열을 입력받으면 특수문자들을 이스케이프 처리시켜 준다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pattern</span> <span class="o">=</span> <span class="s">r'((\d)\2{4,})'</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">escape</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\(\(\\d\)\\2\{4\,\}\)
</code></pre></div></div>

<h3 id="repurge">re.purge()</h3>

<p>사실 설명하지 않은 것이 있는데, <strong>re</strong> 패키지는 <strong>re.compile</strong>로 만들어 놓은 객체들을 cache에 저장해 둔다. 최대 100개까지라고 알려져 있으며, 그 수를 넘어갈 경우 초기화된다고 한다.<br />
물론 여러분은 아마 한 프로그램 내에서 100개 이상의 다른 정규식을 쓸 일은 없으니 크게 신경 쓸 필요는 없다.</p>

<p><strong>re.purge</strong> 함수는 이 cache를 초기화하는 함수이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">re</span><span class="p">.</span><span class="n">purge</span><span class="p">()</span>
</code></pre></div></div>
<p>결과</p>

<p>결과는 아무것도 출력되지 않는다.</p>

<hr />

<h2 id="속성">속성</h2>

<h3 id="reregexflag">re.RegexFlag</h3>

<p><a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/21/regex-usage-02-basic/#%EB%A7%88%EC%B9%A8%ED%91%9C%EB%8A%94-%EA%B0%9C%ED%96%89-%EB%AC%B8%EC%9E%90%EC%99%80-%EC%9D%BC%EC%B9%98-%EC%98%B5%EC%85%98">이전 글</a>에서 flags를 설명했었는데, 이 flag들이 어떤 것이 있는지 알려주는 객체가 re 안에 내장되어 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">re</span><span class="p">.</span><span class="n">RegexFlag</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RegexFlag.ASCII
RegexFlag.IGNORECASE
RegexFlag.LOCALE
RegexFlag.UNICODE
RegexFlag.MULTILINE
RegexFlag.DOTALL
RegexFlag.VERBOSE
RegexFlag.TEMPLATE
RegexFlag.DEBUG
</code></pre></div></div>

<hr />

<h3 id="retemplate">re.TEMPLATE</h3>

<p>아마 쓸 일이 없을 듯하므로 설명은 생략한다. (?)</p>

<p>다만 이런 것이 있다는 것만 소개한다.</p>

<hr />

<h3 id="redebug">re.DEBUG</h3>

<p>reObj를 출력하면 컴파일한 정규식을 그대로 출력하던 것을 기억할 것이다. <strong>re.debug</strong>는 일종의 디버깅 모드로서, 정규식의 대략적인 구조를 알 수 있다.<br />
말 그대로 디버깅용으로 쓰면 될 듯하다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="s">'\d{3,6}'</span><span class="p">,</span> <span class="n">re</span><span class="p">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="s">'AS 123123 ars'</span><span class="p">))</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MAX_REPEAT 3 6
  IN
    CATEGORY CATEGORY_DIGIT
re.compile('\\d{3,6}', re.DEBUG)
['123123']
</code></pre></div></div>

<p>reObj의 사용법은 기본 compile된 객체와 완전히 같다.</p>

<hr />

<h3 id="reerror">re.error</h3>

<p><strong>re.error</strong>는 compile 함수에 전달된 문자열이 유효하지 않은 정규식일 때 발생하는 에러 타입이다. try-except 구문으로 처리하면 된다. 자세한 사용법은 아래 예시로만 보여도 충분할 듯 하다.</p>

<p>참고로 아래 코드의 phi는 원주율을 소수점 1만 자리까지 저장한 문자열이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">regex_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">r'((\d)\2{4,})'</span><span class="p">,</span>
    <span class="s">r'((\d)\1{4,})'</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">regex</span> <span class="ow">in</span> <span class="n">regex_list</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">reObj</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reObj</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="n">phi</span><span class="p">))))</span>
    <span class="k">except</span> <span class="n">re</span><span class="p">.</span><span class="n">error</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"&lt;Invalid regular expression %s&gt;"</span> <span class="o">%</span> <span class="n">regex</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'done'</span><span class="p">)</span>
</code></pre></div></div>
<p>결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['999999']
done
&lt;Invalid regular expression ((\d)\1{4,})&gt;
done
</code></pre></div></div>

<p>무엇이 유효하지 않은지는 <em>연습문제로 남겨두도록 하겠다.</em></p>

<p>조금 더 자세한 사용법은 <a href="https://docs.python.org/3/library/re.html#re.error">여기</a>를 참조한다.</p>

<hr />

<p>이것으로 정규표현식에 대한 글을 마치도록 한다.<br />
조금 더 복잡한 예제를 정리해 두면 좋겠지만, 그때그때 맞게 쓰는 것이 더 나을 것 같아서 굳이 따로 정리할 필요는 없을 것 같다.</p>

    </article>
    <div class="post-more">
      
      <a href="/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/24/regex-usage-09-other-functions/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/08/24/regex-usage-09-other-functions/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/github/2018/08/19/github-usage-08-conflict/">
        GitHub 사용법 - 08. Conflict
      </a>
    </h1>

    <span class="post-date">19 Aug 2018</span>
     |
    
    <a href="/blog/tags/#github" class="post-tag">GitHub</a>
    
    <a href="/blog/tags/#usage" class="post-tag">usage</a>
    
    

    <article>
      <p><strong><em>주의: 이 글을 읽는 여러분이, 만약 git을 많이 써 봐서 익숙한 것이 아니라면, 반드시 손으로 직접 따라 칠 것을 권한다. 눈으로만 보면 100% 잊어버린다.</em></strong></p>

<p><a href="https://greeksharifa.github.io/github/2018/08/15/github-usage-07-diff-add-commit-gitignore-intermediate/">저번 글</a>에서 작업하던 것을 이어서 한다. 저번 글에서는 <code class="highlighter-rouge">diff</code>, <code class="highlighter-rouge">add</code>, <code class="highlighter-rouge">commit</code>, <code class="highlighter-rouge">.gitignore</code>에 대해서 알아보았다.</p>

<hr />

<h2 id="conflict">Conflict</h2>

<p>Conflict는 이름 그대로 충돌인데, 다음의 경우일 때 conflict가 생긴다.</p>

<blockquote>
  <p>같은 파일의 같은 부분을 동시에 두 곳(이상)에서 수정했을 때</p>
</blockquote>

<p>이런 경우는 보통 여러 사람의 분업이 명확하게 이루어지지 않아 코드의 같은 부분을 수정할 때 일어난다.<br />
물론 1인 팀에서도 코드 관리를 잘못하여, 혹은 여러 컴퓨터에서 작업하게 될 때 이러한 실수가 일어나기도 한다.</p>

<p>Conflict의 발생 및 해결 순서는 다음과 같다.</p>

<ol>
  <li>동시에 같은 파일의 같은 부분을 수정하고, merge 혹은 push를 할 때 일어난다. 이는 같은 파일을 수정했다 하더라도 명확히 다른 부분이 수정되었다면 git이 알아서 병합 과정을 처리해준다는 뜻이다.
    <ul>
      <li>충돌이 일어났다면, git은 병합 과정을 진행하지 않고 충돌 상태를 그대로 둔다. 알아서 처리하는 대신 사용자가 충돌을 살펴보고 원하는 코드만 남길 때까지 기다린다.</li>
    </ul>
  </li>
  <li>사용자가 편집기에서 코드를 원하는 부분만 남긴다. 충돌이 일어난 부분은 git이 명확하게 표시를 해 준다.
    <ul>
      <li>표시를 한다는 것은, 실제로 코드 파일을 git이 수정한다는 뜻이다. 물론 알아서 충돌을 해결한다는 뜻이 아니라, “여기 충돌 생겼어”하고 강력하게 표시를 한다는 뜻이다. 만약 코드 테스트를 한다면 틀림없이 이 부분에서 syntax error가 뜬다.</li>
    </ul>
  </li>
  <li>사용자가 직접 수정을 끝냈으면, commit을 한 다음 merge 혹은 push 작업을 완료한다.
    <ul>
      <li>이때 따로 새로운 commit이 생기는 대신 원래 있어야 할 merge commit만 생성된다.</li>
    </ul>
  </li>
</ol>

<p>하나씩 살펴보자.</p>

<hr />

<h3 id="1-conflict-발생시키기">1. Conflict 발생시키기</h3>

<p>일부러는 절대 해서는 안 되지만, 예시를 보여주어야 하기 때문에 고의로 conflict를 발생시켜 보겠다.</p>

<p>일단은 git_tutorial repo의 3rd-branch로 이동한 다음, <code class="highlighter-rouge">git rebase master</code> 명령을 실행한다.<br />
2nd-branch부터 시작한 수정사항이 반영되어있지 않기 때문이다.</p>

<blockquote>
  <p>git checkout 3rd-branch<br />
git rebase master</p>
</blockquote>

<p><code class="highlighter-rouge">second.py</code>의 마지막에 다음을 추가한다.</p>

<p>git_tutorial repo의 2nd-branch로 이동한 다음, <code class="highlighter-rouge">first.py</code>의 마지막에 다음을 추가한다.</p>

<blockquote>
  <p>git checkout 2nd-branch</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">"Desired sentence in 2nd-branch"</span><span class="p">)</span>
</code></pre></div></div>

<p>commit을 한 뒤, master branch에서 2nd-branch의 내용을 merge한다.</p>

<blockquote>
  <p>git add first.py<br />
git commit -m “Desired commit from 2nd-branch”<br />
git checkout master<br />
git merge 2nd-branch</p>
</blockquote>

<p>그리고 3rd-branch로 이동하여 비슷하게 반복한다. 수정하는 파일은 당연히 <code class="highlighter-rouge">first.py</code>이다.</p>

<blockquote>
  <p>git checkout 3rd-branch</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">"Unwanted sentence in 3nd-branch"</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>git add first.py<br />
git commit -m “Unwanted commit from 2nd-branch”<br />
git checkout master<br />
git merge 3rd-branch</p>
</blockquote>

<p><img src="/public/img/GitHub/2018_08_19_github_usage_08_Conflict/01_conflict.PNG" alt="01_conflict" /></p>

<p>예상대로 conflict가 뜬다.</p>

<hr />

<h3 id="2-conflict-해결하기">2. Conflict 해결하기</h3>

<p>이제 편집기로 가서 <code class="highlighter-rouge">first.py</code>를 살펴보라. 메모장 코딩을 하는 것이 아니라면, 에러 표시줄이 여럿 보일 것이다.</p>

<p><img src="/public/img/GitHub/2018_08_19_github_usage_08_Conflict/02_file.PNG" alt="02_file" /></p>

<p>파일을 살펴보면 확실히 어느 부분에서 conflict가 일어났는지 바로 확인이 가능하다.<br />
참고로 필자와 빈 줄의 개수가 달라도 별 상관은 없다.</p>

<p>git이 수정해놓은 부분을 보면 다음과 갈은 구조로 되어 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
(현재 브랜치의 HEAD의 내용)
=======
(merge한 브랜치의 내용)
&gt;&gt;&gt;&gt;&gt;&gt;&gt; (merge한 브랜치 내용)
</code></pre></div></div>

<p>여기서 각 브랜치의 내용 중 사용자가 원하는 부분만 남기고 모두 지우면 된다. 한쪽 브랜치의 내용만 남길 수도 있고, 양쪽 모두의 내용의 일부 혹은 전체를 남길 수도 있다.</p>

<p>수정을 마쳤으면 필요 없는 부분인 <code class="highlighter-rouge">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>, <code class="highlighter-rouge">=======</code>, <code class="highlighter-rouge">&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;branch&gt;</code> 등은 모두 제거하면 된다.</p>

<p><img src="/public/img/GitHub/2018_08_19_github_usage_08_Conflict/04_resolve.PNG" alt="04_resolve" /></p>

<p>예상대로 남길 부분은 “Desired sentence”이므로 이 문장만 남기고 나머지 부분은 모두 삭제하면 된다.</p>

<p>IDE에 따라서는 다음과 같이 표시될 수도 있다. 이때는 조금 더 편하게 진행할 수 있다.<br />
아래 예시는 Visual Studio Code의 경우이다.</p>

<p><img src="/public/img/GitHub/2018_08_19_github_usage_08_Conflict/03_vscode.PNG" alt="03_vscode" /></p>

<p>수정하기 전 ‘변경 사항 비교’를 누르면 어떤 부분이 다른지를 양쪽에 나누어 보여준다.<br />
내용을 확인한 뒤 ‘현재 변경 사항 수락’을 누르면 원하는 부분만 남겨지고 나머지는 알아서 삭제될 것이다. 물론 다른 부분을 남겨도 상관없다.</p>

<hr />

<h3 id="3-commitmerge--push하기">3. commit(merge) &amp; push하기</h3>

<p>그리고 수정한 파일을 <code class="highlighter-rouge">git add</code> 명령으로 추가한 뒤 commit한다. 정상적으로 처리되었는지 보기 위해 로그도 한번 출력해 보자.</p>

<blockquote>
  <p>git add first.py<br />
git commit</p>
</blockquote>

<p><img src="/public/img/GitHub/2018_08_19_github_usage_08_Conflict/05_commit.PNG" alt="05_commit" /></p>

<blockquote>
  <p><strong>ESC 입력 후 :wq</strong><br />
git log –oneline</p>
</blockquote>

<p><img src="/public/img/GitHub/2018_08_19_github_usage_08_Conflict/06_merge.PNG" alt="06_merge" /></p>

<p>이러면 conflict가 해결된 것이다. remote repo에 push하자.</p>

<blockquote>
  <p>git push</p>
</blockquote>

<p>그리고 3rd-branch로 이동하여 rebase를 한다.</p>

<blockquote>
  <p>git checkout 3rd-branch<br />
git rebase master</p>
</blockquote>

<hr />

<h3 id="4-conflict가-발생하지-않는-경우">4. Conflict가 발생하지 않는 경우</h3>

<p>조금 전 처음에 했던 것처럼 2nd-branch로 이동해 업데이트한다.</p>

<blockquote>
  <p>git checkout 2nd-branch<br />
git rebase master</p>
</blockquote>

<p>이번엔 <code class="highlighter-rouge">first.py</code> 파일 끝에 다음을 추가한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">"This is the 2nd sentence written in 2nd-branch."</span><span class="p">)</span>
</code></pre></div></div>

<p>그리고 <code class="highlighter-rouge">second.py</code>의 내용은 다음 문장 빼고 모두 지운다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">"This is the 1st sentence written in 2nd-branch."</span><span class="p">)</span>
</code></pre></div></div>

<p>다시 비슷한 과정을 반복한다.</p>

<blockquote>
  <p>git add *.py<br />
git commit -m “No-collision commit from 2nd-branch”<br />
git checkout master<br />
git merge 2nd-branch</p>
</blockquote>

<blockquote>
  <p>git checkout 3rd-branch</p>
</blockquote>

<p>다음으로는 3rd-branch로 이동하여, <code class="highlighter-rouge">first.py</code> 파일의 내용을 다음 문장 빼고는 모두 지운다.<br />
지우기 전에, <code class="highlighter-rouge">print("This is the 1st sentence written in 2nd-branch.")</code> 문장은 없어야 정상이다. 있다면, checkout을 제대로 했는지 살펴보라.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">"Desired sentence in 2nd-branch"</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>git add first.py<br />
git commit -m “No-collision commit from 3rd-branch”<br />
git checkout master<br />
git merge 3rd-branch</p>
</blockquote>

<p><img src="/public/img/GitHub/2018_08_19_github_usage_08_Conflict/07_no_conflict.PNG" alt="07_no_conflict" /></p>

<p>문제없이 잘 병합된 것을 확인할 수 있다. 다른 파일, 혹은 같은 파일을 수정했더라도 수정한 부분이 다르면 conflict가 일어나지 않는다.<br />
위 예시의 경우 <code class="highlighter-rouge">first.py</code>를 2nd-branch에서는 파일의 끝 부분을, 3rd-branch에서는 파일의 시작 부분을 수정했기 때문에 문제가 일어나지 않았다.</p>

<hr />

<h3 id="5-이유없이-conflict가-생기는-것-같은-경우">5. 이유없이 conflict가 생기는 것 같은 경우</h3>

<p>사실 이유가 없는 경우는 없지만, 간혹 두 branch 간 차이가 전혀 없어 보이고 파일 수정까지 끝마쳤는데도 conflict가 계속해서 발생하는 경우가 있다.</p>

<p>다른 원인일 수도 있지만, 정말로 아무 차이도 없어 보인다면 운영체제의 line-feed 문자의 차이로 인한 문제일 수 있다.<br />
즉 Windows는 <code class="highlighter-rouge">'\r\n'</code>을, Linux나 Mac은 <code class="highlighter-rouge">'\n'</code>을 개행 문자로 사용하기 때문인데, 이 차이를 제대로 인식하지 못해 실패하는 경우가 있으니 참고하면 되겠다.</p>

<p><a href="https://stackoverflow.com/questions/861995/is-it-possible-for-git-merge-to-ignore-line-ending-differences/12194759#12194759">해결법</a>은 다음과 갈다.</p>

<blockquote>
  <p>git config merge.renormalize true</p>
</blockquote>

<p>그리고 merge를 시도하면 된다.</p>

<hr />

<p><a href="https://greeksharifa.github.io/github/2020/05/27/github-usage-09-overall/">다음 글</a>에서는 Git 전체 명령어 사용법을 다룬다.</p>

<hr />

<h2 id="git-명령어">Git 명령어</h2>

<p><a href="https://greeksharifa.github.io/github/2018/06/29/github-usage-00-command-list/">GitHub 사용법 - 00. Command List</a>에서 원하는 명령어를 찾아 볼 수 있다.</p>

    </article>
    <div class="post-more">
      
      <a href="/github/2018/08/19/github-usage-08-conflict/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/github/2018/08/19/github-usage-08-conflict/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/blog/page12">Older</a>
  
  
    
      <a class="pagination-item newer" href="/blog/page10">Newer</a>
    
  
</div>


  </div>
</div>

<label for="sidebar-checkbox" class="sidebar-toggle"></label>

<script>
  (function (document) {
    let toggle = document.querySelector('.sidebar-toggle');
    let sidebar = document.querySelector('#sidebar');
    let checkbox = document.querySelector('#sidebar-checkbox');

    document.addEventListener('click', function (e) {
      let target = e.target;

      if (target === toggle) {
        checkbox.checked = !checkbox.checked;
        e.preventDefault();
      } else if (checkbox.checked && !sidebar.contains(target)) {
        /* click outside the sidebar when sidebar is open */
        checkbox.checked = false;
      }
    }, false);
  })(document);
</script>

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    };
    i[r].l = 1 * new Date();
    a = s.createElement(o);
    m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

  ga('create', 'UA-00000000-1', 'auto');
  ga('send', 'pageview');
</script>


<!-- Naver Analytics -->	
<script type="text/javascript" src="//wcs.naver.net/wcslog.js"></script>
<script type="text/javascript">
  if(!wcs_add) var wcs_add = {};
    wcs_add["wa"] = "18cbce78e94161";
  wcs_do();
</script>

</body>

<script id="dsq-count-scr" src="//greeksharifa-github-io.disqus.com/count.js" async></script>

</html>
