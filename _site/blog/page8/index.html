<!DOCTYPE html>
<html lang="en-us">
<head>
  <head>
  <!-- Description of Blog -->
  <meta name="description" content="Python, Machine & Deep Learning">
  <link rel="canonical" href="https://greeksharifa.github.io/">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Python, Machine & Deep Learning">
  <meta property="og:description" content="Python, Machine Learning & Deep Learning 설명서">
  <meta property="og:image" content="https://greeksharifa.github.io/public/img/icon-144x144.png">
  <meta property="og:url" content="https://greeksharifa.github.io/">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Python, Machine & Deep Learning">
  <meta name="twitter:description" content="Python, Machine Learning & Deep Learning 설명서">
  <meta name="twitter:image" content="https://greeksharifa.github.io/public/img/icon-144x144.png">
  <meta name="twitter:domain" content="https://greeksharifa.github.io/">

  <!-- link -->
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/main.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="icon-144x144" sizes="144x144" href="/public/img/icon-144x144.png">
  <link rel="shortcut icon" href="/public/img/icon_32x32.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"> </script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });
  </script>
  

  <!-- Ads -->
  <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
  </script>
</head>

  <!-- for Google AdSense-->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-9951774327887666",
    enable_page_level_ads: true
  });
</script>

  <style>blockquote {
    font-size: 1em;
    line-height: 1.4
  }</style>
  <link href='http://fonts.googleapis.com/css?family=Gill+Sans' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Consolas' rel='stylesheet' type='text/css'>
</head>
<body>

<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <div class="sidebar-personal-info">
      <div class="sidebar-personal-info-section">
        <a href="http://gravatar.com/3c2986ad7ac1f2230ea3596f44563328">
          <img src="/public/img/maple_tree.jpg" title="Cover Photo" alt="Maple tree" />
        </a>
      </div>
      <div class="sidebar-personal-info-section">
        <p><strong>Developer and Analyst</strong>, YW & YY.</p>
      </div>
      
      
      
      <div class="sidebar-personal-info-section">
        <p> Follow me:
        
        
        
        <a href="https://github.com/greeksharifa">
          <i class="fa fa-github" aria-hidden="true"></i>
        </a>
        
        |
        
        
        
        <a href="mailto:greeksharifa@gmail.com">
          <i class="fa fa-envelope" aria-hidden="true"></i>
        </a>
        
        
        
        </p>
      </div>
      
    </div>
  </div>

  <nav class="sidebar-nav">
    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/">
          Home
        </a>

        
      </span>

    
      
      
      

      

      <span class="foldable">
        <a class="sidebar-nav-item " href="/blog/">
          Blog
        </a>

        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/categories/">
                Categories
              </a>
          
        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/tags/">
                Tags
              </a>
          
        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/about/">
          About
        </a>

        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="http://greeksharifa.github.io/">
          Github Project
        </a>

        
      </span>

    

  </nav>

  <div class="sidebar-item">
    <p>
    &copy; 2020 YW & YY. This work is liscensed under <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a>.
    </p>
  </div>

  <div class="sidebar-item">
    <p>
    Powered by <a href="http://jekyllrb.com">jekyll</a> and <a href="http://greeksharifa.github.io">YW & YY</a>
    </p>
  </div>
</div>


<!-- Wrap is the content to shift when toggling the sidebar. We wrap the
     content to avoid any CSS collisions with our real content. -->
<div class="wrap">
  <div class="masthead">
    <div class="container">
      <h3 class="masthead-title" align="center">
        <a href="/" title="Home" title="YW & YY">
          <img class="masthead-logo" src="/public/img/logo.png"/>
        </a>
        <small>YW & YY's Python, Machine & Deep Learning</small>
        <!-- HTML elements for search -->
        <a href="/search/" id="search_icon">
          <img src="/public/img/search.png" width="25" height="25"
               align="right" style="margin-top:5px; margin-bottom:0;"
               onmouseover="this.style.opacity=0.7" onmouseout="this.style.opacity=0.5"
               alt="search">
        </a>
      </h3>
    </div>
  </div>

  <div class="container content">
    <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/DCGAN/">
        DCGAN(Deep Convolutional GAN)
      </a>
    </h1>

    <span class="post-date">17 Mar 2019</span>
     |
    
    <a href="/blog/tags/#gan" class="post-tag">GAN</a>
    
    <a href="/blog/tags/#dcgan" class="post-tag">DCGAN</a>
    
    <a href="/blog/tags/#machine-learning" class="post-tag">Machine Learning</a>
    
    <a href="/blog/tags/#cnn" class="post-tag">CNN</a>
    
    <a href="/blog/tags/#generative-model" class="post-tag">Generative Model</a>
    
    <a href="/blog/tags/#paper-review" class="post-tag">Paper_Review</a>
    
    

    <article>
      <hr />

<p>이 글에서는 2015년 11월 <em>Alec Radford</em> 등이 발표한 DCGAN(Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks)를 살펴보도록 한다.</p>

<p>DCGAN은 GAN의 개선 모델로 GAN과 다른 점은 다음과 같다.</p>

<ul>
  <li><strong>$D$</strong>
    <ul>
      <li>Strided Convolution을 사용한다.</li>
      <li>Batch Normalization을 사용한다. 입력 레이어(첫 번째)에는 사용하지 않는다.</li>
      <li>activation function으로 Leaky ReLU를 사용한다.</li>
    </ul>
  </li>
  <li><strong>$G$</strong>
    <ul>
      <li>Fractional Strided Convolution(Transposed Convolution)을 사용한다.</li>
      <li>Batch Normalization을 사용한다. 출력 레이어(마지막)에는 사용하지 않는다.</li>
      <li>activation function으로 ReLU를 사용하고 마지막 레이어에는 tanh를 사용한다.</li>
    </ul>
  </li>
</ul>

<p><em>참고</em>: 논문에서 deconvolution이라 되어 있는 것은 Transposed 또는 fractional strided convolution을 의미한다. 이 연산은 엄밀히 말해 convolution의 역연산이 아니기 때문에(그 비슷한 것을 의도하긴 했지만) deconvolution은 사실 틀린 표현이다.</p>

<p>그래서 나아진 점, 혹은 알아낸 것은?</p>

<ul>
  <li>(흔히 생각하는 FHD를 넘는 고해상도랑은 거리가 멀지만) 고해상도 이미지를 생성할 수 있게 되었다.</li>
  <li>거의 대부분의 상황에서 안정적인 학습이 가능하다.</li>
  <li>단순히 이미지를 기억(overfitting)하는 것이 아님을 보였다.</li>
  <li>convolution의 각 filter는 의미 있는 부분에 대한 정보를 갖고 있다. 논문에서는 침실 데이터를 사용하였는데, 어떤 필터는 창문에 대한 정보를 갖고 있는 식이다. 논문에서는 이를 시각화하여 보여주었다.</li>
  <li>input인 noise($z$)는 별 의미 없는 값이 아니라, 이것이 생성될 이미지의 특징을 결정하는 벡터이다. 논문에서는,
    <ul>
      <li>웃는 여자를 생성한 noise $z_1$</li>
      <li>무표정 여자를 생성한 noise $z_2$</li>
      <li>무표정 남자를 생성한 noise $z_3$</li>
      <li>$z_4 :=$ $z_1$ - $z_2$ + $z_3$이라 할 때</li>
      <li>$z_4$를 noise로 쓰면 웃는 남자를 생성해낸다.</li>
    </ul>
  </li>
  <li>또 왼쪽을 보는 사람과 오른쪽을 보는 사람을 생성한 두 벡터를 interpolating하면 마치 얼굴을 회전시킨 듯한 중간 결과들이 얻어진다.</li>
</ul>

<p>DCGAN은 GAN과 학습 방법 자체는 별로 다를 것이 없다(D 학습 후 G 학습시키는 것).</p>

<p><em>참고</em>: $G$로 들어가는 입력 벡터를 뜻하는 noise는 latent variable이라고도 하며, Auto-encoder에서 출력 영상을 만들기 위한 source와 비슷하기에 이 표현도 사용된다.</p>

<p>중요한 부분만 적을 예정이므로 전체가 궁금하면 원 논문을 찾아 읽어보면 된다.</p>

<hr />

<h1 id="논문dcgan">논문(DCGAN)</h1>

<p>논문 링크: <strong><a href="https://arxiv.org/abs/1511.06434">Deep Convolutional GAN</a></strong></p>

<h2 id="초록abstract">초록(Abstract)</h2>

<p>2015~2016년에 나온 논문임을 생각하라.</p>

<p>최근에는 CNN을 통한 supervised learning 연구가 많이 이루어졌지만 unsupervised learning은 별 주목을 받지 못했다. 우리는 Deep Convolutional GANs를 소개하여 그 간극을 좁히고자 한다. 여러 이미지 데이터셋을 학습시키면서 우리는 DCGAN의 G와 D 모두가 object로부터 유의미한 표현 구조를 찾았음을 보였다. 또, 이를 일반적인(general) 이미지 표현에도 응용해 보았다.</p>

<hr />

<h2 id="서론introduction">서론(Introduction)</h2>

<p>GAN은 최대우도(maximum likelihood) 테크닉의 매력적인 대체재이다. 또한 그 학습 방법과 heuristic cost function가 적다는 것 때문에 representation learning에도 훌륭히 잘 쓸 수 있다. 다만 학습이 불안정하고 G가 터무니없는 output을 내뱉을 때가 있다. 그래서 상당히 제한적으로 쓰일 수밖에 없었다.</p>

<p>이 논문에서는, 우리는 다음과 같은 것들을 보일 것이다:</p>
<ul>
  <li>거의 대부분의 상황에서 학습이 안정적인 Convolutional GAN을 제안하고 평가한다. 이것이 DCGAN이다.</li>
  <li>D에게 image classification를 시켜봤는데, 거의 state-of-the-art한 결과를 보인다.</li>
  <li>특정 필터가 특정 object를 그려낸다는 것을 시각화한다.</li>
  <li>G에 들어가는 noise에 산술 연산을 한 결과로 많은 의미있는 이미지를 생성함을 보인다.</li>
</ul>

<hr />

<h2 id="관련-연구related-works">관련 연구(Related Works)</h2>

<p>궁금하면 읽어보자.</p>

<h3 id="representation-learning-from-unlabeled-data">Representation Learning from Unlabeled Data</h3>

<p>Unsupervised representation learning은 꽤 잘 연구되었다. 전통적인 접근 방법으로는 clustering(K-means)이 있다.<br />
이미지 쪽에서는 image representation을 학습하기 위한 구조적 clustering, auto-encoder를 학습시키는 것, what/where 분리 구조, image를 간략한 code로 encode하고 다시 이미지로 복원하는 decoder를 포함하는 사다리 구조 등등이 있었다.<br />
Deep belief networks도 구조적 표현방식을 학습하는 데 좋은 성능을 보였다.</p>

<h3 id="generating-natural-images">Generating Natural Images</h3>

<p>이건 두 종류가 있다: parametric과 non-parametric.</p>

<p>database에 존재하는 이미지 찾기 등을 수행하는 non-parametric 모델들은 texture synthesis, super-resolution, in-painting 등에 사용되었다.</p>

<p>Parameteric 모델은 꽤 널리 알려졌지만(MNIST), 성공적인 것은 별로 없다. 대부분 흐린(blurry) 이미지만을 생성해냈다.<br />
GAN이 생성한 것은 noise가 많고 이해하기 어려웠다. Laplcian pyramid extension, recurrent network, deconvolution network 등의 접근은 자연 이미지를 생성하는 데 성공적이었지만 supervised task에 generator를 활용하진 않았다.</p>

<h3 id="visualizing-the-internals-of-cnns">Visualizing the Internals of CNNs</h3>

<p>Neural Networks의 문제점은 너무 black-box같다는 것이다(<em>참고</em>: 네트워크의 각 필터 등이 정확히 무엇을 의미하는지 사람이 이해할 수가 없다). 다만 각 필터의 의미를 찾으려는 시도는 있었다.</p>

<p>자세한 내용은 원문을 보고 각 논문을 찾아보라.</p>

<hr />

<h2 id="접근법과-모델-아키텍처approach-and-model-architecture">접근법과 모델 아키텍처(Approach and Model Architecture)</h2>

<p>GAN에 CNN을 써서 이미지 품질을 높이려는 시도는 지금까지 성공적이지 못했다.</p>

<p>우리는 많은 시도 끝에 다양한 데이터셋에서 안정적인 그리고 더 높은 해상도의 이미지를 생성하는 모델 구조를 찾아내었다.<br />
핵심은 다음 3가지를 CNN 구조에 적용시키는 것이다.</p>

<ol>
  <li>max-pooling과 같은 미분불가능한 레이어를 strided convolution으로 바꿔 spatial downsampling이 가능하게 한 것이다. 이는 G에 사용된 것이고, D에는 upsampling이 가능하게 바꿨다.</li>
  <li>요즘 트렌드는 FC(Fully Connected) Layer를 없애고 convolution layer로 바꾸는 것이다.</li>
  <li>Batch Normalization을 사용하여 학습을 안정화시킨다(<em>참고</em>: 2019년 현재 BN은 거의 필수처럼 되어 있다). 이는 weight 초기화가 나쁘게 된 경우와 깊은 모델에서 gradient flow를 도우며, 이는 학습 초기에 잘못된 방향으로 학습이 진행되어 망하는 경우를 막아준다. 그러나 sample이 요동치는 것을 막기 위해 G의 출력 레이어와 D의 input layer에는 넣지 않았다(이건 많은 시도 끝에 알아낸 듯).</li>
</ol>

<p>G에서는 activation function으로 ReLU를 사용하고 마지막 레이어에는 tanh를 사용한다. Bounded activation(tanh)은 더 빠르게 수렴하고 학습샘플의 분포를 따라갔다. D에는 Leaky ReLU를 사용하여 높은 해상도를 만들 수 있게 하였다. 이는 GAN과 다른 부분이다.</p>

<h2 id="적대적-학습-상세details-of-adversarial-training">적대적 학습 상세(Details of Adversarial Training)</h2>

<p>우리는 Large-scale Scene Understanding(LSUN), Imagenet-1k, Faces 데이터셋으로 학습을 진행했다.</p>

<ul>
  <li>pre-processing은 쓰지 않았고</li>
  <li>size 128인 mini-batch SGD</li>
  <li>(0, 0.02) 정규분포를 따르는 초기화</li>
  <li>Leaky ReLU의 기울기는 0.2</li>
  <li>AdamOptimizer(0.0002, 0.9)</li>
</ul>

<p>로 했다. AdamOptimizer의 beta1을 0.5로 줄이는 것보다 학습 안정성이 좋았다.</p>

<p>모델 구조는 아래와 같다.</p>

<center><img src="/public/img/2019-03-18-DCGAN/01.png" width="100%" /></center>

<p>단 1 epoch만 학습시켰을 때의 결과. minibatch SGD를 썼기 때문에 이미지를 기억한다고는 볼 수 없다. 따라서 overfitting 없이 잘 생성하고 있는 것이다.</p>

<center><img src="/public/img/2019-03-18-DCGAN/02.png" width="100%" /></center>

<p>5 epoch만 학습시켰을 때의 결과. 침대 근처 noise로 볼 때 오히려 underfitting이 일어난 것 같다.</p>

<center><img src="/public/img/2019-03-18-DCGAN/03.png" width="100%" /></center>

<hr />

<h2 id="dcgan의-능력의-경험적-검증empirical-validation-of-dcgans-capabilities">DCGAN의 능력의 경험적 검증(Empirical Validation of DCGANs Capabilities)</h2>

<p>Unsupervised representation learning 알고리즘을 평가하는 일반적인 방법은 supervised 데이터셋에 대해 특징 추출을 시킨 뒤 performance를 측정하는 것이다.</p>

<p>검증 요약:</p>
<ul>
  <li>CIFAR-10 데이터셋에 대해 검증한 결과, 다른 방법들(K-means, Exemplar CNN 등)과 비교하여 정확도가 별 차이가 없었다!(80.6~84.3%, DCGAN은 82.8%)</li>
  <li>StreetView House Numbers dataset(SVHN)은 state-of-the-art 결과를 얻었다.</li>
</ul>

<h2 id="네트워크-내부-조사-및-시각화investigating-and-visualizing-the-internals-of-the-networks">네트워크 내부 조사 및 시각화(Investigating and Visualizing the Internals of the Networks)</h2>

<p>우리는 가장 가까운 학습 데이터 이미지를 찾거나, 최근접 픽셀이나 특징 혹은 log-likelihood metric 같은 방법은 별로이기 때문에 사용하지 않았다.</p>

<p>생성된 2개의 이미지에 사용된 noise인 $z$를 선형 보간하며 그 보간된 $z$로 이미지를 생성시켜본 결과 한 이미지에서 다른 이미지로 서서히 변해가는 결과를 얻었다(아래 그림). 이미지를 보면 창문 없는 방이 거대한 창문이 있는 방으로 변해 가거나(6th row), TV가 창문으로 변해가는 과정(10th row)을 볼 수 있다.</p>

<center><img src="/public/img/2019-03-18-DCGAN/04.png" width="100%" /></center>

<p>벡터 산술 연산을 통해, vec(웃는 여자) $-$ vec(무표정 여자) $+$ vec(무표정 남자) $=$ vec(웃는 남자) 같은 결과를 얻을 수 있다.</p>

<center><img src="/public/img/2019-03-18-DCGAN/05.png" width="100%" /></center>

<center><img src="/public/img/2019-03-18-DCGAN/06.png" width="100%" /></center>

<p>네트워크 내부의 각 필터는 이해할 수 없는 형식이 아닌 특정 object나 특징을 추출하였음을 알 수 있다.</p>

<center><img src="/public/img/2019-03-18-DCGAN/07.png" width="100%" /></center>

<hr />

<h2 id="결론-및-추후-연구conclusions-and-future-work">결론 및 추후 연구(Conclusions and future work)</h2>

<p>우리는 안정적인 생성모델을 제안하였고 이 적대정 생성모델은 image representation에 탁월함을 보여 주었다. 그러나 아직 오래 학습시킬 시 필터 일부가 요동치는 것 등 모델에 불안정성이 남아 있다.</p>

<p>추후 연구는 이를 안정화하는 방법을 찾는 것이 될 것이다. 또한 이 framework를 영상 또는 음성 등의 다른 domain에도 확장시킬 수도 있다.</p>

<h3 id="acknowledgments">Acknowledgments</h3>

<p>Ian GoodFellow 등의 연구자와 Nvidia Titan-X GPU에 감사를 표한다.</p>

<p><del>(광고인줄)</del></p>

<h2 id="참고문헌references">참고문헌(References)</h2>

<p>논문 참조!</p>

<hr />

<h1 id="튜토리얼">튜토리얼</h1>

<h2 id="공식-튜토리얼">공식 튜토리얼</h2>

<p>DCGAN이 특별히 중요하기 때문인지 Pytorch 공식 홈페이지에 튜토리얼이 있다.</p>

<p>GAN의 핵심 부분을 제외한 부분은 <a href="https://greeksharifa.github.io/pytorch/2018/11/10/pytorch-usage-03-How-to-Use-PyTorch/">여기</a>를 참고하면 된다.</p>

<p>https://pytorch.org/tutorials/beginner/dcgan_faces_tutorial.html</p>

<hr />

<h1 id="이후-연구들">이후 연구들</h1>

<p>GAN 이후로 수많은 발전된 GAN이 연구되어 발표되었다. 가장 중요한 것 두 개는 GAN의 학습 불안정성을 많이 개선시킨 DCGAN(Deep Convolutional GAN), 단순 생성이 목적이 아닌 원하는 형태의 이미지를 생성시킬 수 있게 하는 CGAN(Conditional GAN)일 듯 하다.</p>

<p>많은 GAN들(catGAN, Semi-supervised GAN, LSGAN, WGAN, WGAN_GP, DRAGAN, EBGAN, BEGAN, ACGAN, infoGAN 등)에 대한 설명은 <a href="https://greeksharifa.github.io/generative%20model/2019/03/20/advanced-GANs/">여기</a>에서, CGAN에 대한 설명은 <a href="https://greeksharifa.github.io/generative%20model/2019/03/19/CGAN/">다음 글</a>에서 진행하도록 하겠다.</p>

<hr />


    </article>
    <div class="post-more">
      
      <a href="/DCGAN/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/DCGAN/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/GAN/">
        GAN(Generative Adversarial Networks)
      </a>
    </h1>

    <span class="post-date">03 Mar 2019</span>
     |
    
    <a href="/blog/tags/#gan" class="post-tag">GAN</a>
    
    <a href="/blog/tags/#machine-learning" class="post-tag">Machine Learning</a>
    
    <a href="/blog/tags/#cnn" class="post-tag">CNN</a>
    
    <a href="/blog/tags/#generative-model" class="post-tag">Generative Model</a>
    
    <a href="/blog/tags/#paper-review" class="post-tag">Paper_Review</a>
    
    

    <article>
      <hr />

<p>이 글에서는 2014년 6월 <em>Ian J. Goodfellow</em> 등이 발표한 Generative Adversarial Networks(GAN, 생성적 적대신경망)를 살펴보도록 한다.</p>

<p>간단히 GAN은 두 가지 모델을 동시에 학습시키는 구조이다. G(Generator, 생성자)라는 모델은 직접 볼 수 없는 진짜 데이터와 최대한 비슷하게 생긴 가짜 데이터를 만드려고 하고, D(Distriminator, 식별자 또는 감별자)라는 모델은 자신에게 주어진 데이터가 진짜 데이터인지 가짜 데이터인지 최대한 구분하려고 한다.</p>

<p>GAN을 도식화한 구조는 다음과 같다. <a href="https://github.com/hwalsuklee/tensorflow-generative-model-collections">출처</a></p>

<center><img src="/public/img/2019-03-03-GAN/04.PNG" width="50%" /></center>

<p>논문에서는 설명을 위한 예시로 화폐 위조범($G$)와 경찰($D$)을 제시하였다. 다만 차이가 있다면,</p>
<ul>
  <li>위조범은 진짜를 볼 수 없다는 것(그래서 장님blind라 불린다)</li>
  <li>경찰은 자신이 판별한 결과를 위조범에게 알려준다
는 것이 있다.</li>
</ul>

<p><em>참고</em>: $G$로 들어가는 입력 벡터를 뜻하는 noise는 latent variable이라고도 하며, Auto-encoder에서 출력 영상을 만들기 위한 source와 비슷하기에 이 표현도 사용된다.<br />
또 GAN은 특정한 모델 구조를 가진 것이 아니므로 코드가 특별히 정해진 것은 아니다.</p>

<p>논문을 적절히 번역 및 요약하는 것으로 시작한다. 많은 부분을 생략할 예정이므로 전체가 궁금하면 원 논문을 찾아 읽어보면 된다.</p>

<hr />

<h1 id="generative-adversarial-networksgan">Generative Adversarial Networks(GAN)</h1>

<p>논문 링크: <strong><a href="https://arxiv.org/abs/1406.2661">Generative Adversarial Networks</a></strong></p>

<h2 id="초록abstract">초록(Abstract)</h2>

<p>이 논문에서는 적대적으로 동작하는 두 생성 모델을 동시에 학습시키는 새 framework를 제안한다. 생성자 G는 원본 data distribution을 흉내내려 하고, D는 눈앞의 데이터가 G에게서 온 것인지를 판별한다. G의 목적은 D가 최대한 실수하게 만드는 것이고, D는 당연히 최대한 정확하게 진짜/가짜를 판별하는 것이다.<br />
이는 2인 minimax 게임과 비슷하다. 어떤 유일한 해가 존재하여 최종적으로 D는 실수할 확률이 0.5가 된다(즉 찍는 수준).<br />
G와 D가 multi-layer perceptron으로 구성되면 전체 시스템은 backpropagation으로 학습될 수 있다.<br />
GAN에는 어느 과정에서든 마르코프 체인이나 기타 다른 네트워크가 필요가 전혀 없다.</p>

<hr />

<h2 id="서론introduction">서론(Introduction)</h2>

<p><strong><em>적대적</em></strong>인 두 네트워크를 학습시킨다. D는 원본 data distribution인지 G에서 온 것인지를 판별하고, G는 D가 실수하도록 가짜 데이터를 잘 만들어내는 것이 목표이다.<br />
이 framework는 많은 특별한 학습 알고리즘과 optimizer를 사용할 수 있다. 앞서 말한 대로 multi-layer perception을 쓰면 다른 복잡한 네트워크는 필요 없이 오직 forward/backpropagation만으로 (이 논문에서는 dropout을 또 쓴다) 학습이 가능하다.</p>

<hr />

<h2 id="관련-연구related-works">관련 연구(Related Works)</h2>

<p>궁금하면 읽어보자.</p>
<ul>
  <li>RBMs: restricted Boltzmann machines, 잠재 변수를 가진 유향 그래프 모델에 대한 대안으로, 무향 그래프 모델</li>
  <li>DBMs: deep Boltzmann machines, RBMs와 비슷함. 다양한 변형이 존재</li>
  <li>MCMC: Markov chain Monte Carlo methods, 위 모델의 측정 방법</li>
  <li>DBNs: Deep belief networks, 하나의 무향 레이어와 여러 유향 레이어의 hybrid 모델. 계삭적 문제가 있음</li>
  <li>NCE: noise-contrasive estimation, log-likelihood를 근사하거나 경계값을 구하지 않는 방법</li>
  <li>GSN: generative stochastic network, 확률분포를 명시적으로 정의하지 않고 분포 샘플을 생성하도록 학습시키는 방법을 사용</li>
  <li><strong>adversarial nets</strong>: 적대적 망은 생성 중 feedback loop를 필요로 하지 않아 sampling에서 Markov chain이 필요가 없다. 이는 backpropagation 성능 향상으로 이어진다.</li>
  <li>auto-encoding varitional Bayes와 stochastic backpropagation은 생성 머신을 학습시키는 방법들 중 하나이다.</li>
</ul>

<hr />

<h2 id="적대적-망adversarial-nets">적대적 망(Adversarial nets)</h2>

<table>
  <thead>
    <tr>
      <th>기호</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$x$</td>
      <td>데이터</td>
    </tr>
    <tr>
      <td>$p_g$</td>
      <td>$x$에 대한 생성자의 분포</td>
    </tr>
    <tr>
      <td>$p_z(z)$</td>
      <td>input noise 변수</td>
    </tr>
    <tr>
      <td>$\theta_g$</td>
      <td>multilayer perceptrions의 parameters</td>
    </tr>
    <tr>
      <td>$G$</td>
      <td>$\theta_g$에 의해 표현되는 미분가능한 함수</td>
    </tr>
    <tr>
      <td>$G(z; \theta_g$)</td>
      <td>data space에 대한 mapping</td>
    </tr>
    <tr>
      <td>$D(x)$</td>
      <td>$x$가 $p_g$가 아니라 원본 데이터에서 나왔을 확률</td>
    </tr>
    <tr>
      <td>$D(x; \theta_d)$</td>
      <td>두 번째 multilayer perceptron</td>
    </tr>
  </tbody>
</table>

<p>D의 목적은 데이터가 ‘원본’인지 ‘G가 생성한 데이터’인지 판별하는 것이므로 어떤 데이터에 대해 정확한 label(‘원본’ 또는 ‘G로부터’)을 붙이는 것이다. G의 목적은 D가 실수하게 만드는 것, 즉 어떤 데이터가 주어졌을 때 D가 ‘원본’이라고 판별할 확률과 ‘G로부터 나온 데이터’라고 판별할 확률을 모두 높이는 것(정확히는 같게)이다.<br />
즉 $log(1-D(G(z)))$를 최소화하도록 G를 훈련시킨다.</p>

<p>D와 G 모두에 대해 value function $V(G, D)$를 정의하면,</p>

<script type="math/tex; mode=display">min_G max_D V(D, G) = \mathbb{E}_{x \sim p_{data}(x)}[log D(x)] + \mathbb{E}_{x \sim p_{z}(z)}[log (1-D(G(z)))]</script>

<p>위 식의 의미는,</p>
<ul>
  <li>$min_G$: G는 V를 최소화하려고 한다.</li>
  <li>$max_D$: D는 V를 최대화하려고 한다. 2-player minimax 게임과 같으므로 당연하다.</li>
  <li>$\mathbb{E}$: 기댓값</li>
  <li>$x \sim p_{data}(x)$: $x$가 원본 데이터 분포에서 왔을 때</li>
</ul>

<p>D가 <em>아주 똑똑한 경찰</em>이라면, $x$가 실제로 원본에서 온 것이라면 $D(x)=1$이 될 것이고, $G(z)$에서 온 것이라면 $D(G(z))=0$이 된다. 만약 G가 <em>완벽한 위조범</em>이 되었다면, $D(x) = {1 \over 2}$이다.<br />
따라서 D의 입장에서 V의 최댓값은 0이 되며, G의 입장에서 V의 최솟값은 $-\infty$임을 알 수 있다.</p>

<p>학습시킬 때, inner loop에서 D를 최적화하는 것은 매우 많은 계산을 필요로 하고 유한한 데이터셋에서는 overfitting을 초래하기 때문에, $k$ step만큼 D를 최적화하고 G는 1 step만 최적화하도록 한다.<br />
학습 초반에는 G가 형편없기 때문에 D는 진짜인지 G가 생성한 것인지를 아주 잘 구분해 낸다.<br />
또 G가 $log(1-D(G(z)))$를 최소화하도록 하는 것보다는 $log(D(G(z)))$를 최대화하도록 하는 것이 더 학습이 잘 된다. 이는 G가 형편없을 때는 $log(1-D(G(z)))$의 gradient를 계산했을 때 너무 작은 값이 나와 학습이 느리기 때문이라고 한다.</p>

<center><img src="/public/img/2019-03-03-GAN/01.PNG" width="100%" /></center>

<p>파란 점선은 disctiminative distribution(D), 검정색은 원본 데이터($p_x$), 초록색은 생성된 분포$p_g$(G), $x$는 원본 데이터 분포를, 화살표는 $x=G(z)$ mapping을 나타낸다. (a) 초기 상태. (b) D 학습 후, (c) G 학습 후, 분포가 비슷해지는 것을 볼 수 있다. (d) 여러 번의 학습 끝에 G가 완전히 원본을 흉내낼 수 있는 경지에 도달함. 즉 $p_g = p_{data}$. D는 이제 진짜인지 가짜인지 구분할 수 없다. 즉 $D(x) = {1 \over 2}$.</p>

<hr />

<h2 id="이론적-결과theoretical-results">이론적 결과(Theoretical Results)</h2>

<p>수학을 좋아한다면 직접 읽어보자.</p>
<ul>
  <li>Algorithm 1
    <ul>
      <li>for epochs do
        <ul>
          <li>for k steps do
            <ul>
              <li>noise prior $p_g(z)$로부터 $m$개의 noise sample $z^{(1)}, …, z^{(m)}$을 뽑는다.</li>
              <li>noise prior $p_{data}(x)$로부터 $m$개의 noise sample $x^{(1)}, …, x^{(m)}$을 뽑는다.</li>
              <li>D를 다음 stochastic gradient로 update한다. (ascending)
                <ul>
                  <li>$ \nabla_{\theta_d} {1 \over m} \sum^m_{i=1} [log D(x^{(i)}) + log (1-D(G(z^{(i)})))] $</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>noise prior $p_g(z)$로부터 $m$개의 noise sample $z^{(1)}, …, z^{(m)}$을 뽑는다.</li>
          <li>G를 다음 stochastic gradient로 update한다. (descending)
            <ul>
              <li>$ \nabla_{\theta_d} {1 \over m} \sum^m_{i=1} [log (1-D(G(z^{(i)})))] $</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이 minimax 게임은 $p_g = p_{data}$에 대한 global optimum을 가진다.
    <ul>
      <li>G를 고정했을 때, optimal한 D는 $ D^*<em>G(x) = {p</em>{data}(x) \over p_{data}(x) + p_g(x)} $</li>
    </ul>
  </li>
  <li>Algorithm 1은 수렴한다.</li>
</ul>

<hr />

<h2 id="실험experiments">실험(Experiments)</h2>

<p>MNIST, Toronto Face Database(TFD), CIFAR-10에 대해 학습을 진행했다.</p>

<ul>
  <li>G는 rectifier linear activations와 sigmoid를 사용했고, D는 maxout activations를 사용했다.</li>
  <li>Dropout은 D를 학습시킬 때 사용했다.</li>
  <li>noise는 G에서 가장 밑의 레이어에만 input으로 넣었다.</li>
</ul>

<p>자세한 실험 조건은 직접 읽어보자.</p>

<center><img src="/public/img/2019-03-03-GAN/02.PNG" width="100%" /></center>

<p>가장 오른쪽 열은 바로 옆에 있는 생성된 이미지와 가장 비슷한 학습 샘플이다. a) MNIST b) TFD c) CIFAR-10(fully connected model) d) CIFAR-10(convolutional D와 “deconvolutional” G)</p>

<center><img src="/public/img/2019-03-03-GAN/03.PNG" width="100%" /></center>

<p>숫자 간 보간을 했을 때는 위와 같이 된다. 물론 GAN을 통해 생성한 것이다.</p>

<hr />

<h2 id="장단점advantages-and-disadvantages">장단점(Advantages and disadvantages)</h2>

<h3 id="단점">단점</h3>

<ul>
  <li>$p_g(x)$가 명시적으로 존재하지 않는다.</li>
  <li>D는 G와 균형을 잘 맞추어서 성능이 향상되어야 한다(G는 D가 발전하기 전 너무 발전하면 안 된다).</li>
</ul>

<h3 id="장점">장점</h3>
<ul>
  <li>마르코프 체인이 전혀 필요 없이 backprop만으로 학습이 된다.</li>
  <li>특별히 어떤 추론(inference)도 필요 없다.</li>
  <li>다양한 함수들이 모델에 접목될 수 있다.</li>
  <li>마르코프 체인을 썼을 때에 비해 훨씬 선명한(sharp) 이미지를 결과로 얻을 수 있다.</li>
</ul>

<hr />

<h2 id="결론-및-추후-연구conclusions-and-future-work">결론 및 추후 연구(Conclusions and future work)</h2>

<ol>
  <li>conditional generative model로 발전시킬 수 있다(CGAN).</li>
  <li>Learned approximate inference는 $x$가 주어졌을 때 $z$를 예측하는 보조 네트워크를 학습함으로써 수행될 수 있다.</li>
  <li>parameters를 공유하는 조건부 모델을 학습함으로써 다른 조건부 모델을 대략 모델링 할 수 있다. 특히, deterministic MP-DBM의 stochastic extension의 구현에 대부분의 네트워크를 쓸 수 있다.</li>
  <li>Semi-supervised learning에도 활용 가능하다. classifier의 성능 향상을 꾀할 수 있다.</li>
  <li>효율성 개선: G와 D를 조정하는 더 나은 방법이나 학습하는 동안 sample $z$에 대한 더 나은 distributions을 결정하는 등의 방법으로 속도를 높일 수 있다.</li>
</ol>

<h2 id="참고문헌references">참고문헌(References)</h2>

<p>논문 참조!</p>

<hr />

<h1 id="보충-설명">보충 설명</h1>

<h2 id="목적함수">목적함수</h2>

<p>D의 목적함수는 G를 고정한 채로 진짜 데이터 $m$개와 가짜 데이터 $m$개를 D에 넣고, G에 대한 V를 계산한 뒤 gradient를 구하고 V를 높여 D를 최종적으로 업데이트한다.</p>

<script type="math/tex; mode=display">max_D V(D) = {1 \over m } \sum^m_{i=1} log D(x^i) + {1 \over m } \sum^m_{i=1} log D(1 - D(G(z^i)))</script>

<p>G의 목적함수는 D를 고정한 채로 가짜 데이터 $m$개를 생성해 V을 계산한 뒤, G에 대한 V의 gradient를 계산하고 V를 낮춰 G를 업데이트한다.<br />
G의 목적함수는 gradient가 0에 가까워지는 것을 막기 위해 논문에서 언급된 팁을 반영한 것이다.</p>

<script type="math/tex; mode=display">min_G V(G) = {1 \over m} \sum^m_{j=1} log(D(G(z^j)))</script>

<h3 id="목적함수-최적화의-의미">목적함수 최적화의 의미</h3>

<p>Machine Learning 관점에서 보면 모델이 loss가 최소화되는 parameter를 찾아가는 과정이다.<br />
또는 진짜 데이터의 분포와 G가 생성한 가짜 데이터 분포 사이의 차이를 줄이는 것과도 같다.</p>

<p>수학적으로는 D가 이미 최적이라는 가정 하에, GAN이 목적함수를 최적화한다는 과정($p_{data}$와 $p_g$를 똑같이 만드려는 것)은 $p_{data}$와 $p_g$ 사이의 <a href="https://en.wikipedia.org/wiki/Jensen%E2%80%93Shannon_divergence">Jensen-Shannon divergence(JSD)</a>를 최소화하는 것과 같다.<br />
JSD는 <a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence">Kullback–Leibler divergence</a>의 대칭(symmetrized and smoothed) 버전이다. 그래서 GAN은 KLD를 최소화하는 것이라고 말하기도 한다.</p>

<p>분포 $P$와 $Q$에 대해, $KLD = D(P \Vert Q), M = {1 \over 2}(P+Q)$라 할 때, JSD는</p>

<script type="math/tex; mode=display">JSD(P \Vert Q) = {1 \over 2} D(P \Vert M) + {1 \over 2} D(Q \Vert M)</script>

<p>이다.</p>

<hr />

<h2 id="학습-방법">학습 방법</h2>

<p>GAN은 서로 경쟁하는 두 가지 모델을 학습시킨다. GAN을 쓰려면 다음 방법을 따른다.</p>

<ol>
  <li>우선 다음을 정의한다.
    <ol>
      <li>R(Real): 실제 데이터. 논문에선 $x$로 표시</li>
      <li>I(Input 또는 Imaginary): G가 가짜 데이터를 생성할 source. 논문에선 $z$로 표시.
        <ul>
          <li>$G(z)$는 $G$가 $z$를 입력으로 받아 생성한 가짜 데이터이다.</li>
        </ul>
      </li>
      <li>$G$(generator): 생성자, 위조범</li>
      <li>$D$(Distriminator): 감별자 또는 식별자, 경찰</li>
    </ol>
  </li>
  <li>다음 전체 과정을 <code class="highlighter-rouge">num_epochs</code> 동안 반복한다:
    <ol>
      <li>D를 training하는 과정(<code class="highlighter-rouge">d_steps</code>만큼 반복): <strong>D와 G를 모두 사용은 하지만 D의 parameter만 업데이트한다.</strong>
        <ol>
          <li>$D$에 실제 데이터($x$)와 정답(1)을 입력으로 주고 loss를 계산한다.</li>
          <li>$D$에 가짜 데이터($G(z)$)와 정답(0)을 입력으로 주고 loss를 계산한다.</li>
          <li>두 loss를 합친 후 $D$의 parameter를 업데이트한다.</li>
        </ol>
      </li>
      <li>G를 training하는 과정(<code class="highlighter-rouge">g_steps</code>만큼 반복): <strong>D와 G를 모두 사용은 하지만 G의 parameter만 업데이트한다.</strong>
        <ol>
          <li>$D$에 가짜 데이터($G(z)$)와 정답(1)을 입력으로 주고 loss를 계산한다.</li>
          <li>계산한 loss를 이용하여 $G$의 parameter를 업데이트한다.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<hr />

<h2 id="단점-및-극복방안">단점 및 극복방안</h2>

<p>GAN 논문에서는 수학적인 증명이 포함되어 있지만(최소 해를 가지며, 충분히 학습할 시 항상 그 해답을 찾는다), 여러 요인들로 인해 실제 학습시킬 때에는 학습이 좀 불안정하다는 단점이 있다.</p>

<h3 id="mode-collapsing">Mode Collapsing</h3>

<p>간단히 이 현상은 학습 모델이 실제 데이터의 분포를 정확히 따라가지 못하고 그저 뭉뚱그리기만 하면서 다양성을 잃어버리는 것이다.<br />
예를 들면 1~9까지의 숫자 9개를 만드는 대신 5만 9개 만드는 것과 비슷하며, MNIST의 경우 10종류의 모든 숫자가 아닌 특정 숫자들만 생성하는 경우이다.</p>

<p>이는 GAN이 단순히 목적함수의 loss만을 줄이려는 방향으로 설정되어 있어 생기는 현상이다. 이 현상은 GAN의 개선 모델들에서 대부분 해결된다.</p>

<h3 id="oscillation">Oscillation</h3>

<p>G와 D가 수렴하지 않고 진동하는 모양새를 보일 때가 있다. 이 역시 비슷한 이유로 발생하며, 나중 모델들에서 해결된다.</p>

<h3 id="g와-d-사이의-imbalance">G와 D 사이의 Imbalance</h3>

<p>학습을 진행하면 처음에는 D가 발전하고 나중에 G가 급격히 학습되는 형상을 보이는데, 처음부터 D가 너무 성능이 좋아져버리면 오히려 G가 학습이 잘 되지 않는 문제가 발생한다(D가 시작부터 G의 기를 죽이는 셈).</p>

<h3 id="해결방안">해결방안</h3>

<ul>
  <li>진짜 데이터와 가짜 데이터 간 Least Square Error를 목적함수에 추가한다(LSGAN).</li>
  <li>모델의 구조를 convolution으로 바꾼다(DCGAN)</li>
  <li>mini-batch별로 학습을 진행할 경우 이전 학습이 잘 잊혀지는 것을 막기 위해 이를 기억하는 방향으로 학습시킨다.</li>
</ul>

<hr />

<h1 id="튜토리얼">튜토리얼</h1>

<h2 id="50줄로-짜보는-튜토리얼">50줄로 짜보는 튜토리얼</h2>

<p>원문 링크는 <a href="https://medium.com/@devnag/generative-adversarial-networks-gans-in-50-lines-of-code-pytorch-e81b79659e3f">여기</a>, 번역본은 <a href="http://ddanggle.github.io/GANinTorch">여기</a>에서 볼 수 있다.<br />
해당 튜토리얼에서는</p>
<ol>
  <li>이 전체 과정을 <code class="highlighter-rouge">num_epochs</code>(여기서는 5000)만큼 반복한다.
    <ol>
      <li>training D(<code class="highlighter-rouge">d_steps</code>만큼 반복):
        <ol>
          <li>가우시안 분포를 따르는 데이터를 Real Data로 생성하고</li>
          <li>그 momentum(mean, std, skews, kurtoses)를 계산하여 D에게 전달, error를 계산한다.</li>
          <li>또 Fake data를 G가 생성하게 하고</li>
          <li>D가 error를 계산하게 한다.</li>
          <li>위 두 과정(1~2, 3~4)으로 D의 parameter를 업데이트한다.</li>
        </ol>
      </li>
      <li>training G(<code class="highlighter-rouge">g_steps</code>만큼 반복):
        <ol>
          <li>G로 Fake data를 생성한다.</li>
          <li>D에게서 판별 결과를 받아온다.</li>
          <li>G가 error를 계산하게 한다.</li>
          <li>G의 parameter를 업데이트한다.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p><a href="https://github.com/devnag/pytorch-generative-adversarial-networks">코드</a>는 원문에도 소개되어 있지만 전체는 사실 186줄이다(…) 물론 GAN의 핵심 코드는 50줄 정도이다.</p>

<h2 id="mnist-튜토리얼">MNIST 튜토리얼</h2>

<p>GAN의 핵심 부분을 제외한 부분은 <a href="https://greeksharifa.github.io/pytorch/2018/11/10/pytorch-usage-03-How-to-Use-PyTorch/">여기</a>를 참고하면 된다.</p>

<p>우선 기본 설정부터 하자.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torch.optim</span> <span class="kn">import</span> <span class="n">Adam</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">transforms</span>

<span class="kn">import</span> <span class="nn">argparse</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">imageio</span>


<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s">'GAN tutorial: MNIST'</span><span class="p">)</span>

<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--epochs'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'number of epochs'</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--batch-size'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'size of mini-batch'</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--noise-size'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'size of random noise vector'</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--use-cuda'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'use cuda if available'</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--learning-rate'</span><span class="p">,</span> <span class="s">'-lr'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0002</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'learning rate of AdamOptimizer'</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--beta1'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'parameter beta1 of AdamOptimizer'</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--beta2'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.999</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'parameter beta2 of AdamOptimizer'</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--output-dir'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">'output/'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'directory path of output'</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--log-file'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">'log.txt'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'filename of logging'</span><span class="p">)</span>

<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

<span class="n">os</span><span class="p">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">use_cuda</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">use_cuda</span> <span class="ow">and</span> <span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="n">is_available</span><span class="p">()</span>

<span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">.</span><span class="n">Compose</span><span class="p">([</span>
    <span class="n">transforms</span><span class="p">.</span><span class="n">ToTensor</span><span class="p">(),</span>
    <span class="n">transforms</span><span class="p">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,),</span> <span class="n">std</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,))</span>
<span class="p">])</span>

<span class="n">mnist</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">.</span><span class="n">MNIST</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="s">'data'</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
<span class="n">dataloader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">mnist</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">args</span><span class="p">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<p>Generator는 다음과 같이 선언한다. 레이어는 총 4개, activation function은 LeakyRELU와 Tanh를 사용하였다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Generator</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Generator</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">linear1</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">linear2</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">linear3</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">linear4</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">28</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s">"""
        :param x: input tensor[batch_size * noise_size]
        :return: output tensor[batch_size * 1 * 28 * 28]
        """</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)(</span><span class="bp">self</span><span class="p">.</span><span class="n">linear1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)(</span><span class="bp">self</span><span class="p">.</span><span class="n">linear2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)(</span><span class="bp">self</span><span class="p">.</span><span class="n">linear3</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Tanh</span><span class="p">()(</span><span class="bp">self</span><span class="p">.</span><span class="n">linear4</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
</code></pre></div></div>

<p>Discriminator는 다음과 같다. Linear Layer는 G의 역방향으로 가는 것과 비슷하지만, activation function에는 차이가 있다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Discriminator</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Discriminator</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">linear1</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">28</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">linear2</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">linear3</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">linear4</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s">"""
        :param x: input tensor[batch_size * 1 * 28 * 28]
        :return: possibility of that the image is real data
        """</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)(</span><span class="bp">self</span><span class="p">.</span><span class="n">linear1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Dropout</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)(</span><span class="bp">self</span><span class="p">.</span><span class="n">linear2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Dropout</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)(</span><span class="bp">self</span><span class="p">.</span><span class="n">linear3</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="n">Dropout</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nn</span><span class="p">.</span><span class="n">Sigmoid</span><span class="p">()(</span><span class="bp">self</span><span class="p">.</span><span class="n">linear4</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre></div></div>

<p>GAN의 핵심 부분은 다음과 같다. 위의 Gaussian 분포 예제와 크게 다르지 않아서 크게 설명은 필요없을 듯 하다. 차이점을 조금 적어보자면</p>
<ol>
  <li>분포의 momentum을 G의 데이터 생성 source로 사용하는 대신 길이 100(MNIST의 경우 보통)짜리 random vector를 사용한다. G는 이 길이 100짜리 벡터를 갖고 MNIST의 숫자 이미지와 비슷한 이미지를 생성하려고 하게 된다.</li>
  <li>또 <code class="highlighter-rouge">.cuda()</code>와 <code class="highlighter-rouge">DataLoader</code>를 사용하는 것 정도가 있겠으나 GAN의 핵심 부분은 아니다.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">epochs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">D_real_data</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">:</span>
            
            <span class="n">batch_size</span> <span class="o">=</span> <span class="n">D_real_data</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="c1"># Training D with real data
</span>            <span class="n">D</span><span class="p">.</span><span class="n">zero_grad</span><span class="p">()</span>
            
            <span class="n">target_real</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">target_fake</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">use_cuda</span><span class="p">:</span>
                <span class="n">D_real_data</span><span class="p">,</span> <span class="n">target_real</span><span class="p">,</span> <span class="n">target_fake</span> <span class="o">=</span> \
                <span class="n">D_real_data</span><span class="p">.</span><span class="n">cuda</span><span class="p">(),</span> <span class="n">target_real</span><span class="p">.</span><span class="n">cuda</span><span class="p">(),</span> <span class="n">target_fake</span><span class="p">.</span><span class="n">cuda</span><span class="p">()</span>
            
            <span class="n">D_real_decision</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="n">D_real_data</span><span class="p">)</span>
            <span class="n">D_real_loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">D_real_decision</span><span class="p">,</span> <span class="n">target_real</span><span class="p">)</span>
            
            <span class="c1"># Training D with fake data
</span>            
            <span class="n">z</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">randn</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">noise_size</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">use_cuda</span><span class="p">:</span> <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">cuda</span><span class="p">()</span>
            
            <span class="n">D_fake_data</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">D_fake_decision</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="n">D_fake_data</span><span class="p">)</span>
            <span class="n">D_fake_loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">D_fake_decision</span><span class="p">,</span> <span class="n">target_fake</span><span class="p">)</span>
            
            <span class="n">D_loss</span> <span class="o">=</span> <span class="n">D_real_loss</span> <span class="o">+</span> <span class="n">D_fake_loss</span>
            <span class="n">D_loss</span><span class="p">.</span><span class="n">backward</span><span class="p">()</span>
            
            <span class="n">D_optimizer</span><span class="p">.</span><span class="n">step</span><span class="p">()</span>
            
            <span class="c1"># Training G based on D's decision
</span>            <span class="n">G</span><span class="p">.</span><span class="n">zero_grad</span><span class="p">()</span>
            
            <span class="n">z</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">randn</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">noise_size</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">use_cuda</span><span class="p">:</span> <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">cuda</span><span class="p">()</span>
            
            <span class="n">D_fake_data</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">D_fake_decision</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="n">D_fake_data</span><span class="p">)</span>
            <span class="n">G_loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">D_fake_decision</span><span class="p">,</span> <span class="n">target_real</span><span class="p">)</span>
            <span class="n">G_loss</span><span class="p">.</span><span class="n">backward</span><span class="p">()</span>
            
            <span class="n">G_optimizer</span><span class="p">.</span><span class="n">step</span><span class="p">()</span>
</code></pre></div></div>

<p>전체 코드는 <a href="https://github.com/greeksharifa/Tutorial.code/blob/master/Python/GAN_tutorial/gan_tutorial.py">여기</a>를 참조하라.</p>

<hr />

<h1 id="이후-연구들">이후 연구들</h1>

<p>사실 2014년 발표된 original GAN은</p>
<ul>
  <li>학습이 불안정하고</li>
  <li>고해상도 이미지는 생성하지 못하는
한계를 갖고 있었다. 논문에서 optimal point가 있고 그쪽으로 수렴한다는 것을 보였지만, 실제로는 여러 변수 때문에 학습이 항상 잘 되는 것이 아니라는 현상을 보인다. 이러한 문제를 보완하기 위해 GAN 이후로 수많은 발전된 GAN이 연구되어 발표되었다.</li>
</ul>

<p>그 중에서 가장 중요한 것을 3가지 정도만 뽑자면</p>

<ol>
  <li>Convolution을 사용하여 GAN의 학습 불안정성을 많이 개선시킨 <a href="https://greeksharifa.github.io/generative%20model/2019/03/17/DCGAN/">DCGAN(Deep Convolutional GAN, 2015)</a></li>
  <li>단순 생성이 목적이 아닌 원하는 형태의 이미지를 생성시킬 수 있게 하는 시초인 <a href="https://greeksharifa.github.io/generative%20model/2019/03/19/CGAN/">CGAN(Conditional GAN, 2014)</a></li>
  <li>GAN이 임의의 divergence를 사용하는 경우에 대해 local convergence함을 보여주고 그에 대해 실제 작동하는 GAN을 보여준 <a href="https://greeksharifa.github.io/generative%20model/2019/03/19/f-GAN/">f-GAN(2016)</a></li>
</ol>

<p>일 듯 하다.</p>

<p>많은 GAN들(catGAN, Semi-supervised GAN, LSGAN, WGAN, WGAN_GP, DRAGAN, EBGAN, BEGAN, ACGAN, infoGAN 등)에 대한 설명은 <a href="https://greeksharifa.github.io/generative%20model/2019/03/20/advanced-GANs/">여기</a>에서, DCGAN에 대해서는 <a href="https://greeksharifa.github.io/generative%20model/2019/03/17/DCGAN/">다음 글</a>에서 진행하도록 하겠다.</p>

<hr />


    </article>
    <div class="post-more">
      
      <a href="/GAN/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/GAN/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/argparse-usage/">
        Python argparse 사용법
      </a>
    </h1>

    <span class="post-date">12 Feb 2019</span>
     |
    
    <a href="/blog/tags/#pytorch" class="post-tag">PyTorch</a>
    
    <a href="/blog/tags/#argparse" class="post-tag">Argparse</a>
    
    <a href="/blog/tags/#usage" class="post-tag">usage</a>
    
    

    <article>
      <p>이 글에서는 Python 패키지인 argparse에 대해 알아본다. Machine Learning 코드를 볼 때 꽤 자주 볼 수 있을 것이다.</p>

<hr />

<h1 id="import">Import</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">argparse</span>
</code></pre></div></div>

<hr />

<h1 id="argparse">argparse</h1>

<script data-ad-client="ca-pub-9951774327887666" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python train.py --epochs 50 --batch-size 64 --save-dir weights
</code></pre></div></div>
<p>Machine Learning을 포함해서, 위와 같은 실행 옵션은 많은 코드에서 볼 수 있었을 것이다. 학습 과정을 포함하여 대부분은 명령창 또는 콘솔에서 <code class="highlighter-rouge">python 파일명 옵션들...</code>으로 실행시키기 때문에, argparse에 대한 이해는 필요하다.</p>

<p><strong><em>중요:</em></strong></p>
<ul>
  <li>기본적으로 <code class="highlighter-rouge">argparse</code> 라이브러리는 명령창(터미널)에서 실행하는 것을 원칙으로 한다. Jupyter notebook이나 (iPython) 대화형 실행 framework에서는 제대로 실행되지 않을 수 있다. 또한 이러한 대화형 framework에서는 코드 상에서 명시적으로 집어 넣는 게 아닌 이상 인자에 값을 바로 줄 수도 없다.</li>
  <li>그래도 쓰고 싶다면 <code class="highlighter-rouge">args = parser.parse_args()</code>를 <code class="highlighter-rouge">args = parser.parse_args(args=[])</code>로 바꾸고 사용할 수는 있다…하지만 위의 이유로 인해 별 의미는 없을 듯하다.</li>
</ul>

<p>필자는 이 글에서 위의 명령 중 <code class="highlighter-rouge">--epochs</code>와 같은 것을 <strong>인자</strong>, <code class="highlighter-rouge">50</code>과 같은 것을 (같이 준) <strong>값</strong>으로 부르겠다.</p>

<p>argparse는 python에 기본으로 내장되어 있다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">os</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">import os</code>는 output directory를 만드는 등의 역할을 위해 필요하다.</p>

<p>argparse를 쓰려면 기본적으로 다음 코드가 필요하다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">argparse</span>

<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s">'Argparse Tutorial'</span><span class="p">)</span>
<span class="c1"># argument는 원하는 만큼 추가한다.
</span><span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--print-number'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> 
                    <span class="n">help</span><span class="o">=</span><span class="s">'an integer for printing repeatably'</span><span class="p">)</span>

<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">print_number</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'print number {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>
<ol>
  <li>일단 <a href="https://docs.python.org/3/library/argparse.html?highlight=argparse#argparse.ArgumentParser">ArgumentParser</a>에 원하는 description을 입력하여 parser 객체를 생성한다. description 외에도 usage, default value 등을 지정할 수 있다.</li>
  <li>그리고 <code class="highlighter-rouge">add_argument()</code> method를 통해 원하는 만큼 인자 종류를 추가한다.</li>
  <li><code class="highlighter-rouge">parse_args()</code> method로 명령창에서 주어진 인자를 파싱한다.</li>
  <li><code class="highlighter-rouge">args</code>라는 이름으로 파싱을 성공했다면 <code class="highlighter-rouge">args.parameter</code> 형태로 주어진 인자 값을 받아 사용할 수 있다.</li>
</ol>

<p>실행 결과</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; python argparseTest.py -h
usage: argparseTest.py [-h] [--print-number PRINT_NUMBER]

Argparse Tutorial

optional arguments:
  -h, --help            show this help message and exit
  --print-number PRINT_NUMBER
                        an integer for printing repeatably

&gt; python argparseTest.py --print-number 5
print number 1
print number 2
print number 3
print number 4
print number 5
</code></pre></div></div>

<p>argparse의 인자는 지정할 수 있는 종류가 상당히 많다.</p>
<h2 id="help--h">–help, -h</h2>
<p><code class="highlighter-rouge">--help</code> 또는 <code class="highlighter-rouge">-h</code>: 기본으로 내장되어 있는 옵션이다. 이 인자를 넣고 python으로 실행하면 인자 사용법에 대한 도움말이 출력된다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; python argparseTest.py -h
usage: argparseTest.py [-h] [--print-number PRINT_NUMBER]
...
</code></pre></div></div>

<h2 id="argument-이름-정의">argument 이름 정의</h2>
<p>인자의 이름을 지정할 때 여러 이름을 짓는 것이 가능하다. 지정할 때 두 개를 연속해서 나열한다. 보통 1~2개를 지정하는데, <code class="highlighter-rouge">--help</code>와 <code class="highlighter-rouge">-h</code>같이 fullname과 약자를 하나씩 지정하는 편이다. 또 <code class="highlighter-rouge">help=</code>에서 description을 써줄 수 있다.<br />
참고로 help 메시지는 % formatting을 지원한다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--print-number'</span><span class="p">,</span> <span class="s">'-p'</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">'an integer for printing repeatably'</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="type-지정">type 지정</h2>
<p>기본적으로 <code class="highlighter-rouge">parse_args()</code>가 주어진 인자들을 파싱할 때는 모든 문자를 숫자 등이 아닌 문자열 취급한다. 따라서 데이터 타입을 지정하고 싶으면 <code class="highlighter-rouge">add_argument()</code>에서 <code class="highlighter-rouge">type=</code>을 지정해 주어야 한다. default는 말한 대로 <code class="highlighter-rouge">str</code>이다.</p>
<ul>
  <li>ex) <code class="highlighter-rouge">parser.add_argument('--print-number', '-p', type=int, ...)</code></li>
  <li>type으로 사용 가능한 것은 한 개의 문자열을 받아들여 return 문이 있는 모든 callable 객체이다.</li>
  <li>Common built-in types과 functions이 사용 가능한데, <code class="highlighter-rouge">str</code>, <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">float</code>, <code class="highlighter-rouge">bool</code>과 <code class="highlighter-rouge">open</code> 등이 있다. <code class="highlighter-rouge">list</code>와 같은 것은 불가능하다. list처럼 쓰고 싶으면 아래쪽에서 설명할 <code class="highlighter-rouge">action=append</code>를 이용한다.</li>
  <li><code class="highlighter-rouge">argparse.FileType()</code> 함수도 <code class="highlighter-rouge">type=</code>에 사용 가능한데, <code class="highlighter-rouge">mode=</code>, <code class="highlighter-rouge">bufsize=</code>, <code class="highlighter-rouge">encoding=</code>, <code class="highlighter-rouge">errors=</code> parameter를 취하는 함수로서 다양한 파일을 여러 옵션으로 지정할 수 있다. 예를 들어 <code class="highlighter-rouge">argparse.FileType('w')</code>는 쓰기 가능한 파일을 만든다. 자세한 것은 <a href="https://docs.python.org/3/library/argparse.html?highlight=argparse#type">여기</a>를 참조한다.</li>
</ul>

<h2 id="positional--optional-인자">positional / optional 인자</h2>
<p>positional 인자와 optional 인자가 있다. 인자의 이름 앞에 <code class="highlighter-rouge">-</code>가 붙어 있으면 optional, 아니면 positional 인자로서 필수로 지정해야 한다.<br />
단, positional 인자도 필수로 넣어야 하게끔 할 수 있다. <code class="highlighter-rouge">add_argument()</code> 함수에 <code class="highlighter-rouge">required=True</code>를 집어넣으면 된다. 그러나 C언어에서 <code class="highlighter-rouge">#define true false</code>같은 짓인 만큼 권장되지 않는다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># argparseTest.py
# ...
</span><span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--foo'</span><span class="p">,</span> <span class="s">'-f'</span><span class="p">)</span> <span class="c1"># optional
</span><span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'bar'</span><span class="p">)</span>         <span class="c1"># positional
</span><span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'args.foo:'</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">foo</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'args.bar:'</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">bar</span><span class="p">)</span>
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># optional 인자는 지정하지 않아도 되고, 그럴 경우 기본값이 저장된다.
&gt; python argparseTest.py bar_value
args.foo: None
args.bar: bar_value

# positional 인자는 반드시 값을 정해 주어야 한다.
&gt; python argparseTest.py --foo 1
usage: argparseTest.py [-h] [--foo FOO] bar
argparseTest.py: error: the following arguments are required: bar

# optional 인자 뒤에는 반드시 저장할 값을 지정해야 한다. 
# 이는 `action=store`인 optional 인자에 해당한다. 6번 항목에서 설명하겠다.
&gt; python argparseTest.py bar_value --foo
usage: argparseTest.py [-h] [--foo FOO] bar
argparseTest.py: error: argument --foo/-f: expected one argument

# optional 인자는 `--foo 3`또는 `--foo=3` 두 가지 방식으로 지정할 수 있다.
# positional 인자는 그런 거 없다.
&gt; python argparseTest.py --foo=5 bar=bar_value
args.foo: 5
args.bar: bar_value

# positional 인자가 여러 개라면 순서를 반드시 지켜야 한다.
# optional 인자는 값만 잘 지정한다면 어디에 끼워 넣어도 상관없다.
&gt; python argparseTest.py bar_value --foo 7
args.foo: 7
args.bar: bar_value
</code></pre></div></div>
<h2 id="default-값-지정">default 값 지정</h2>
<p>값을 저장할 때 명시적으로 지정하지 않았을 때 들어가는 기본값을 설정할 수 있다. <code class="highlighter-rouge">add_argument()</code>에서 <code class="highlighter-rouge">default=</code> 옵션을 지정한다.
    - <code class="highlighter-rouge">argparse.SUPPRESS</code>를 적을 경우, 인자를 적지 않았을 때 None이 들어가는 것이 아닌 아예 인자 자체가 생성되지 않는다. 또한 <code class="highlighter-rouge">--help</code>에도 표시되지 않는다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--foo'</span><span class="p">,</span> <span class="s">'-f'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; python argparseTest.py
args.foo: 5

# 그러나 인자를 적어 놓고 값은 안 주면 에러가 난다. 
# 기본적으로 한 개의 값을 추가로 받아야 하기 때문이다.
# 이걸 바꾸려면 6번이나 7번 항목을 참조한다.
&gt; python argparseTest.py --foo
usage: argparseTest.py [-h] [--foo FOO]
argparseTest.py: error: argument --foo/-f: expected one argument
</code></pre></div></div>
<h2 id="action의-종류-지정">action의 종류 지정</h2>
<p>인자를 정의(<code class="highlighter-rouge">add_argument()</code>에 의해)할 때 action을 지정할 수 있다. 액션에는 다음과 같은 것들이 있으며, 기본값은 <code class="highlighter-rouge">store</code>이다.</p>
<ul>
  <li><code class="highlighter-rouge">store</code>: action을 지정하지 않으면 <code class="highlighter-rouge">store</code>이 된다. 인자 이름 바로 뒤의 값을 해당 인자에 대입(저장)시킨다.</li>
  <li><code class="highlighter-rouge">store_const</code>: <code class="highlighter-rouge">add_argument()</code>에서 미리 지정되어 있는 <code class="highlighter-rouge">const=</code>에 해당하는 값이 저장된다. <code class="highlighter-rouge">const=</code>는 반드시 써 주어야 한다.</li>
  <li><code class="highlighter-rouge">store_true</code>, <code class="highlighter-rouge">store_false</code>: 인자를 적으면(값은 주지 않는다) 해당 인자에 <code class="highlighter-rouge">True</code>나 <code class="highlighter-rouge">False</code>가 저장된다.</li>
  <li><code class="highlighter-rouge">append</code>: 값을 하나가 아닌 여러 개를 저장하고 싶을 때 쓴다. 인자를 여러 번 호출하면 같이 주는 값이 계속 append된다.</li>
  <li><code class="highlighter-rouge">append_const</code>: append와 비슷하지만 사전에 지정한 const 값이 저장된다.</li>
  <li><code class="highlighter-rouge">count</code>: 인자를 적은 횟수만큼 값이 올라간다. 보통 <code class="highlighter-rouge">verbose</code> 옵션에 많이 쓴다.</li>
  <li><code class="highlighter-rouge">help</code>: 도움말 메시지를 출력하게 하고 종료하여 코드는 실행시키지 않는다. <code class="highlighter-rouge">--help</code> 역할을 대신한다.</li>
  <li><code class="highlighter-rouge">version</code>: <code class="highlighter-rouge">version</code> 인자에 사용가능하다. 버전 정보를 출력하고 종료한다.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parser.add_argument('--foo', action='store_const', const=10)
&gt; python argparseTest.py --foo
args.foo: 10

# 인자를 적지 않으면 default 값(None)이 저장된다.
parser.add_argument('--foo', action='store_const', const=10)
&gt; python argparseTest.py
args.foo: None

# default 값을 지정하면 당연히 바뀐다.
parser.add_argument('--foo', action='store_const', const=10, default=5)
&gt; python argparseTest.py
args.foo: 5

# store_true의 경우 default 값은 false이며, 인자를 적어 주면 true가 저장된다.
# store_false의 경우 반대이다.
parser.add_argument('--foo1', action='store_true')
parser.add_argument('--foo2', action='store_true')
parser.add_argument('--foo3', action='store_false')
parser.add_argument('--foo4', action='store_false')
args = parser.parse_args()

print('args.foo1:', args.foo1)
print('args.foo2:', args.foo2)
print('args.foo3:', args.foo3)
print('args.foo4:', args.foo4)
&gt; python argparseTest.py --foo1 --foo4
args.foo: True
args.foo: False
args.foo: True
args.foo: False

# 참고로 한 번만 호출해도 args.foo는 데이터 타입이 list가 된다. 안 하면 None이다.
parser.add_argument('--foo', action='append')
&gt; python argparseTest.py --foo 1 --foo 123 --foo=xyz
args.foo: ['1', '123', 'xyz']
</code></pre></div></div>

<h2 id="attribute-name---_-구분">attribute name: -, _ 구분</h2>
<p>인자의 이름에는 <code class="highlighter-rouge">-</code>와 <code class="highlighter-rouge">_</code>을 쓸 수 있다. 단, python 기본 문법은 변수명에 <code class="highlighter-rouge">-</code>를 허용하지 않기 때문에, 인자의 이름에 <code class="highlighter-rouge">-</code>가 들어갔다면 <code class="highlighter-rouge">args.인자</code>로 접근하려면 <code class="highlighter-rouge">-</code>를 <code class="highlighter-rouge">_</code>로 바꿔 주어야 한다.</p>
<ul>
  <li><code class="highlighter-rouge">--print-number</code>의 경우 <code class="highlighter-rouge">args.print_number</code>로 접근할 수 있다.</li>
  <li><code class="highlighter-rouge">--print_number</code>의 경우 <code class="highlighter-rouge">args.print_number</code>로 동일하다.</li>
</ul>

<h2 id="dest-적용-위치-지정">dest: 적용 위치 지정</h2>
<p>argument를 지정할 때 store나 action의 저장 또는 적용 위치를 바꿔서 지정할 수 있다. 예를 들어 <code class="highlighter-rouge">--foo</code>의 <code class="highlighter-rouge">dest=</code> 옵션을 <code class="highlighter-rouge">--foo-list</code>로 지정하면, <code class="highlighter-rouge">args.foo_list</code>에 값이 저장되는 식이다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--foo'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">'append'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">'foo_list'</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">'--bar'</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">'bar_value'</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s">'args.foo_list:'</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">foo_list</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'args.bar_value:'</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">bar_value</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">foo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Hmm?'</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'Where are you gone?'</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; python argparseTest.py --foo 1 --foo 123 --foo=xyz --bar ABC
args.foo_list: ['1', '123', 'xyz']
args.bar_value: ABC
Where are you gone? 'Namespace' object has no attribute 'foo'
</code></pre></div></div>

<h2 id="nargs-값-개수-지정">nargs: 값 개수 지정</h2>
<p>argparse는 일반적으로 1개의 값을 추가로 받거나, <code class="highlighter-rouge">action=store_true</code>의 경우는 값을 추가로 받지 않는다. 이를 바꿔 주는 것이 <code class="highlighter-rouge">nargs=</code> 이다.</p>
<ul>
  <li><code class="highlighter-rouge">N</code>: N개의 값을 읽어들인다.</li>
  <li><code class="highlighter-rouge">?</code>: 0개 또는 1개의 값을 읽어들인다.
    <ul>
      <li>인자와 값을 모두 적은 경우 해당 값이 저장된다.</li>
      <li>인자만 적은 경우 const 값이 저장된다.</li>
      <li>아무것도 적지 않았으면 default 값이 저장된다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">*</code>: 0개 이상의 값을 전부 읽어들인다.</li>
  <li><code class="highlighter-rouge">+</code>: 1개 이상의 값을 전부 읽어들인다. 정규표현식의 것과 매우 비슷하다.</li>
  <li><code class="highlighter-rouge">argparse.REMAINDER</code>: 남은 값을 개수 상관없이 전부 읽어들인다.</li>
</ul>

<p>예제는 <a href="https://docs.python.org/3/library/argparse.html?highlight=argparse#nargs">원문</a>이나 <a href="https://docs.python.org/ko/3.7/library/argparse.html#nargs">번역본</a>을 참조한다.</p>

<h2 id="choices-값-범위-지정">choices: 값 범위 지정</h2>
<p>인자와 같이 주어지는 값의 범위를 제한하고 싶으면 <code class="highlighter-rouge">choices=</code> 옵션을 쓰면 된다. <code class="highlighter-rouge">choices=</code>에 들어갈 수 있는 정의역은 list 등 iterable 객체이다(<code class="highlighter-rouge">in</code> 조건검사를 할 수 있으면 된다).</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parser.add_argument('--foo', choices=range(1, 5))
&gt; python argparseTest.py --foo 5
usage: argparseTest.py [-h] [--foo {1,2,3,4}]
argparseTest.py: error: argument --foo: 
invalid choice: '5' (choose from 1, 2, 3, 4)
</code></pre></div></div>

<h2 id="metavar-이름-재지정">metavar: 이름 재지정</h2>
<p>metavar은 <code class="highlighter-rouge">help=</code>에서 도움말 메시지를 생성할 때 표시되는 이름을 변경할 수 있다(직접 값을 참조하는  <code class="highlighter-rouge">args.foo</code> 같은 경우 기본 이름 또는 <code class="highlighter-rouge">dest=</code>에 의해 재지정된 이름을 써야 한다).</p>

<hr />

<h1 id="references">References</h1>

<ul>
  <li><a href="https://docs.python.org/3/library/argparse.html">원문</a></li>
  <li><a href="https://docs.python.org/ko/3.7/library/argparse.html">번역본</a></li>
</ul>

    </article>
    <div class="post-more">
      
      <a href="/argparse-usage/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/argparse-usage/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/PyCharm-usage/">
        PyCharm 사용법
      </a>
    </h1>

    <span class="post-date">07 Feb 2019</span>
     |
    
    <a href="/blog/tags/#pycharm" class="post-tag">PyCharm</a>
    
    <a href="/blog/tags/#usage" class="post-tag">usage</a>
    
    

    <article>
      <hr />

<p>PyCharm(파이참)은 Jetbrains 사에서 제작 및 배포하는 <strong>유료</strong>/무료 프로그램이다.<br />
Professional 버전은 돈을 주고 구입하거나, 학생이라면 <a href="https://www.jetbrains.com/student/">학생 인증</a>을 하고 무료로 사용할 수 있다.</p>

<p>글이 길기 때문에 사용법을 검색하고 싶다면 <code class="highlighter-rouge">Ctrl + F</code> 키를 누른 다음 검색해 보자.</p>

<p><em>2020.05.10 updated</em></p>

<hr />

<h2 id="설치">설치</h2>

<p>PyCharm 홈페이지에서 설치 파일을 다운받는다.</p>

<script data-ad-client="ca-pub-9951774327887666" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<p><a href="https://www.jetbrains.com/pycharm/download/#section=windows">Windows</a>, <a href="https://www.jetbrains.com/pycharm/download/#section=mac">Mac</a>, <a href="https://www.jetbrains.com/pycharm/download/#section=linux">Linux</a></p>

<p>유료 버전을 구매했거나 <a href="https://www.jetbrains.com/student/">학생 인증</a>이 가능하다면, Professional 버전을 다운받도록 한다.</p>

<h3 id="settings">Settings</h3>

<p>설치 시 다음 창을 볼 수 있다. 해당 컴퓨터에 설치한 적이 있으면 설정 파일 위치를 지정하고, 아니면 말도록 하자.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/01.png" width="70%" /></center>

<p>필자는 Darcula로 지정했고, 왼쪽 아래의 <code class="highlighter-rouge">Skip Remaining and Set Defaults</code> 버튼을 누른다. 본인이 추가 설정하고 싶은 부분이 있으면 이후 설정에서 마음대로 바꾸면 된다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/02.png" width="100%" /></center>

<p>설정을 완료하면 아래와 같은 화면을 볼 수 있다. 오른쪽 아래의 <code class="highlighter-rouge">Configure</code> &gt; <code class="highlighter-rouge">Settings</code> 를 클릭한다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/03.png" width="100%" /></center>

<p>정확히는 <code class="highlighter-rouge">Settings for New Projects</code>라는 대화창을 볼 수 있다. 이는 새 프로젝트를 만들 때 적용되는 <strong>기본 설정</strong>이다. 새로운 설정을 만들고 싶다면 <code class="highlighter-rouge">Default</code> 설정을 복제(Duplicate)한 뒤 새 설정에서 바꾸도록 한다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/04.png" width="100%" /></center>

<p>설정에서 <code class="highlighter-rouge">Appearance &amp; Behavior</code> &gt; <code class="highlighter-rouge">Appearance</code>에서, <code class="highlighter-rouge">Theme</code>를 <code class="highlighter-rouge">Darcula</code> 또는 다른 것으로 지정할 수 있다. 아래의 <code class="highlighter-rouge">Use Custom Font</code>는 메뉴 등의 폰트를 해당 폰트로 지정할 수 있다.<br />
참고로, 코드의 폰트는 <code class="highlighter-rouge">Editor</code> &gt; <code class="highlighter-rouge">Font</code>에서 지정한다. 이 두 가지 역시 구분하도록 한다. 기본값은 <code class="highlighter-rouge">Monospaced</code>이다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/05.png" width="100%" /></center>

<p><code class="highlighter-rouge">Keymap</code>에서는 단축키를 지정할 수 있다. PyCharm의 기본 단축키는 타 프로그램과 좀 다른 부분이 많아 필자는 일부를 바꿨다.<br />
변경하고 싶은 단축키를 찾아서 더블클릭 또는 우클릭하면 기존에 지정되어 있는 단축키를 삭제하고 새 단축키를 지정할 수 있다. 이때 겹친다면 기존 단축키를 남겨둘지 제거할지 선택할 수 있다. 또한 마우스와 조합한 단축키로 지정할 수도 있다.<br />
그리고 검색창 옆에 <code class="highlighter-rouge">돋보기 + 네모 3개</code>로 이루어진 아이콘을 클릭하면 명령의 이름이 아닌 현재 지정되어 있는 단축키로 검색할 수 있다(예: Ctrl + W).</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/06.png" width="100%" /></center>

<p>추천하는 변경할 단축키는 다음과 같다.<br />
아래쪽은 필자가 지정하여 사용하는 단축키이다. 이외에도 유용한 기능을 몇 개 적어 놓았다.</p>

<table>
  <thead>
    <tr>
      <th>Menu</th>
      <th>변경 전</th>
      <th>변경 후</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Execute selection in console</td>
      <td>Alt + Shift + E</td>
      <td>Ctrl + Enter</td>
    </tr>
    <tr>
      <td>Edit &gt; Find &gt; Replace</td>
      <td>Ctrl + H</td>
      <td>Ctrl + R</td>
    </tr>
    <tr>
      <td>Refactor &gt; Rename</td>
      <td>Shift + F6</td>
      <td>F2</td>
    </tr>
    <tr>
      <td>Other &gt; Terminal</td>
      <td> </td>
      <td>Alt + T</td>
    </tr>
    <tr>
      <td>Other &gt; Python Console</td>
      <td> </td>
      <td>Alt + 8</td>
    </tr>
    <tr>
      <td>Other &gt; SciView</td>
      <td> </td>
      <td>Alt + 0</td>
    </tr>
    <tr>
      <td>Show in Explorer</td>
      <td> </td>
      <td>Ctrl + Alt + Shift + E</td>
    </tr>
    <tr>
      <td>Window &gt; Editor Tabs &gt; Close</td>
      <td> </td>
      <td>Ctrl + W</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>Type Info</td>
      <td> </td>
      <td>Ctrl + Alt + Button1 Click</td>
    </tr>
    <tr>
      <td>Split and Move Right</td>
      <td> </td>
      <td>Ctrl + Alt + Shift + R</td>
    </tr>
    <tr>
      <td>Go to Declaration or Usages</td>
      <td> </td>
      <td>Ctrl + Button1 Click</td>
    </tr>
  </tbody>
</table>

<p>필자의 경우 나머지 설정은 그대로 두는 편이나, <code class="highlighter-rouge">Ctrl + Enter</code>로 바꿀 때는 다른 곳에 할당된 것을 지운다(Already assigned 경고창에서 Leave 대신 Remove를 선택). 안 그러면 선택한 부분이 Python Console(대화형)에서 실행되지 않는다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/07.png" width="100%" /></center>

<p>위 그림에서 기본 Python Interpreter 파일(python.exe)를 설정한다. 새 프로젝트를 생성 시 Configure Python Interpreter라는 경고가 보이면서 코드 실행이 안 되면 인터프리터가 설정되지 않은 것이다. 컴퓨터에 설치된 파이썬 파일을 찾아 설정하자.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/08.png" width="100%" /></center>

<p><code class="highlighter-rouge">Show All...</code>을 클릭하면 처음에는 빈 창이 보인다. <code class="highlighter-rouge">+</code>를 눌러서 원하는 환경을 추가한다. 기존의 것을 추가하거나, 새로운 가상환경(virtualenv 또는 conda)를 즉석에서 생성 가능하다.<br />
이렇게 만든 가상환경은 해당 프로젝트에서만 쓰거나(기본 설정), 아래쪽의 <code class="highlighter-rouge">Make available to all projects</code>를 체크하여 다른 프로젝트에서도 해당 인터프리터를 택할 수 있도록 정할 수도 있다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/09.png" width="100%" /></center>

<p>PyCharm에서 코드 실행을 대화형으로 하면 Python Console에 자꾸 <code class="highlighter-rouge">Special Variables</code>라는 창이 뜨는 것을 볼 수 있다. 보통 쓸 일이 없는데 기본으로 표시되는 것이므로, <code class="highlighter-rouge">Build, Execution, Deployment</code> &gt; <code class="highlighter-rouge">Console</code>에서 <code class="highlighter-rouge">Show console variable by default</code> 체크를 해제한다.</p>

<p>해당 설정을 마쳤으면 첫 화면에서 <code class="highlighter-rouge">Create New Project</code>를 클릭한다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/10.png" width="100%" /></center>

<p>프로젝트 이름은 기본적으로 Untitled 이므로 바꿔주고, 아래쪽의 Project Interpreter를 설정해 둔다. 미리 설정했다면 목록이 보일 것이고, 아니라면 새로 생성하거나 <code class="highlighter-rouge">python.exe</code> 위치를 찾아 지정해준다.</p>

<h3 id="sync-settings">Sync Settings</h3>

<p>시작 화면에서 <code class="highlighter-rouge">Configure</code> &gt; <code class="highlighter-rouge">Settings Repository...</code>, 또는 프로젝트 생성 후 <code class="highlighter-rouge">File</code> &gt; <code class="highlighter-rouge">Settings Repository...</code> 를 클릭하면 지금까지 설정한 설정들을 git repository에 저장할 수 있다. git을 알고 있다면, Merge, Overwrite Local, Overwrite Remote의 뜻을 알 것이라 믿는다. git repository에 저장하면 컴퓨터를 옮겨도 동일한 설정을 쉽게 지정할 수 있다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/11.png" width="80%" /></center>

<p>git repository는 그냥 여러분의 git 계정에서 빈 거 하나 만든 다음에 그 주소를 복사하면 된다. 그러면 PyCharm이 알아서 설정을 동기화시켜 줄 것이다.</p>

<p>이를 지정하려면 Personal Access Token이 필요하다. <a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/">여기</a>를 참조한다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/12.png" width="70%" /></center>

<p>등록이 완료되면 Merge, Overwrite Local(git에 저장된 내용을 local로 덮어씀), Overwrite Remote(현재 local 설정을 인터넷에 덮어씀) 중 하나를 선택해 설정을 동기화할 수 있다.</p>

<p>참고: 이렇게 동기화한 경우 일부 설정(예: <code class="highlighter-rouge">kepmap</code> 등)이 바로 적용되지 않는 경우가 있다. 그런 경우는</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/48.png" width="100%" /></center>

<p>여기에서 Keymap 설정을 변경해 주면 된다. 보통 처음 동기화를 시도하면 기본 설정이나 어떤 <code class="highlighter-rouge">Default Copy</code> 버전으로 동작하고 있는 경우가 많다.</p>

<p>여기까지 초기 설정이 끝났다(원하는 부분만 진행해도 좋다). 이제 PyCharm 프로젝트 화면을 살펴보도록 하자.</p>

<hr />

<h2 id="project-창alt--1">Project 창(<code class="highlighter-rouge">Alt + 1</code>)</h2>

<p>처음 프로젝트를 열면 다음과 같은 화면이 보일 것이다. (Show tips at startup은 무시한다)</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/13.png" width="100%" /></center>

<p>맨 왼쪽에는 프로젝트 창이 있다. 맨 왼쪽 빨간 박스로 표시한 곳을 클릭하면 프로젝트 창을 접었다 폈다 할 수 있다. 단축키를 눌러도 된다(Alt + 1).</p>

<p>필자는 현재 untitled라는 이름으로 프로젝트를 생성했기 때문에, 루트 폴더는 현재 untitled이다. 주황 박스를 오른쪽 클릭하면 꽤 많은 옵션이 있다. 참고로 프로젝트 내 모든 디렉토리 또는 파일에 오른쪽 클릭하여 기능을 쓸 수 있다. 디렉토리를 우클릭했을 때와 파일을 우클릭했을 때 옵션이 조금 다르다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/14.png" width="70%" /></center>

<p>각 옵션을 대략 설명하면,</p>
<ul>
  <li>New: File, Directory, Python File(<code class="highlighter-rouge">.py</code>), Jupyter Notebook(<code class="highlighter-rouge">.ipynb</code>) 등을 생성한다. 단축키 설정하는 방법은 다음과 같다.
    <ul>
      <li>새 Python 파일을 생성할 때는 <code class="highlighter-rouge">New &gt; Python File</code>을 선택하면 된다. 단축키를 설정하는 방법은 <code class="highlighter-rouge">Settings &gt; Keymap</code>의 검색창에서 <code class="highlighter-rouge">Python File</code>을 검색하면 아무 단축키가 지정되어 있지 않은 것을 볼 수 있다. <code class="highlighter-rouge">Add Keyboard Shortcut</code>을 눌러 원하는 키를 설정해주자.</li>
    </ul>
  </li>
  <li>Cut, Copy, Paste 등은 설명하지 않겠다.</li>
  <li>Copy Path, Copy Relative Path: 각각 해당 디렉토리 또는 파일의 절대/상대 경로를 복사한다. 이미지나 데이터 파일 등의 경로를 써야 할 때 유용하게 쓸 수 있다. 단, 사용 환경에 따라 디렉토리 구분자가 <code class="highlighter-rouge">/</code>, <code class="highlighter-rouge">\</code>, <code class="highlighter-rouge">//</code> 등으로 달라지는 경우가 있으니 주의.</li>
  <li>Refactor: 해당 디렉토리 또는 파일의 이름을 변경한다. 이때 이 파일명을 사용하는 코드(file open 등)이 있으면 그 코드를 자동으로 수정하게 할 수 있다.</li>
  <li>Find Usages: 해당 파일을 참조하는 코드를 살펴볼 수 있다. Refactor와 같이 사용하면 좋다.</li>
  <li>Show in Explorer: 해당 디렉토리나 파일이 있는 디렉토리를 탐색기나 Finder 등에서 열 수 있다.</li>
  <li>Mark Directory as: 디렉토리의 속성을 설정한다. 세부 옵션이 4개 있다.
    <ul>
      <li>Sources Root: 프로젝트에서 코드의 최상위 폴더를 지정한다. 코드를 짜다 보면 프로젝트 루트 폴더에 직속된 파일이 아닌 경우 패키지나 파일 reference를 찾지 못하는 경우가 많은데, 그럴 때는 해당 코드를 포함하는 파일 바로 상위의 디렉토리를 Sources Root로 설정하면 빨간 줄이 사라지는 것을 볼 수 있다.</li>
      <li>Excluded: PyCharm 색인(Index)에서 제외시킨다. PyCharm은 Find Usages와 같은 기능을 지원하기 위해 프로젝트 내 모든 파일과 코드에 대해 indexing을 수행하는데(목차를 생성하는 거랑 비슷함), 프로젝트 크기가 크면 굳이 필요 없는 수많은 파일들까지 indexing해야 한다. 이는 PyCharm 성능 저하와 함께 색인 파일의 크기가 매우 커지므로(임시 파일까지 포함하여 수 GB까지 되기도 함) 너무 많으면 적당히 제외시키도록 하자.</li>
      <li>Resource Root: 말 그대로 Resource Root로 지정한다.</li>
      <li>Template Folder: 템플릿이 있는 폴더에 지정하면 된다. Pure Python을 쓸 때에는 별 의미 없다.</li>
    </ul>
  </li>
  <li>Add to Favorites: Favorites창에 해당 디렉토리나 파일을 추가한다. 즐겨찾기 기능이랑 같다. 프로젝트 창 아래에서 창을 찾을 수 있고, <code class="highlighter-rouge">Alt + 2</code> 단축키로 토글할 수 있다.</li>
</ul>

<center><img src="/public/img/2019-02-07-PyCharm-usage/14_1.png" width="70%" /></center>

<h3 id="새-파일-생성">새 파일 생성</h3>

<p>이제 우클릭 &gt; New &gt; Python File로 새 파이썬 파일을 하나 생성하자. (현재 프로젝트 이름은 <code class="highlighter-rouge">PythonTutorial</code>이다)</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/15.png" width="100%" /></center>

<p>안타깝게도 새 Python 파일 생성을 위한 단축키는 지정할 수 없는 듯하다.</p>

<hr />

<h2 id="코드-실행전체-또는-선택">코드 실행(전체 또는 선택)</h2>

<p>그리고 원하는 파일명을 입력한다. 필자는 <code class="highlighter-rouge">tutorial</code>이라고 입력하겠다. 그러면 파일명은 <code class="highlighter-rouge">tutorial.py</code>가 될 것이다.</p>

<p>이제 코딩할 수 있는 창이 열렸으니 코드를 입력하자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'Hello Pycharm!'</span><span class="p">)</span>
</code></pre></div></div>

<p>코드를 작성했으면 실행을 해 보아야 하지 않겠는가? 실행하는 방법은 여러 가지가 있다.</p>

<ul>
  <li>실행하고 싶은 코드 라인에 커서를 놓거나 실행할 만큼 드래그를 한 다음 <a href="https://greeksharifa.github.io/references/2019/02/07/PyCharm-usage/#settings">위</a>에서 단축키를 바꿨다면 <code class="highlighter-rouge">Ctrl + Enter</code>, 바꾸지 않았다면 <code class="highlighter-rouge">Alt + Shift + E</code>를 누른다. 그러면 <code class="highlighter-rouge">Python Console</code>이라는 창이 아래쪽에 열리면서 실행한 코드와 실행 결과가 나타난다. 역시 단축키를 설정했다면 <code class="highlighter-rouge">Alt + 8</code>로 열 수 있다. PyCharm Default settings에는 단축키가 할당되어 있지 않다.
    <ul>
      <li>이것은 정확히는 Interpreter라고 부르는 대화형 파이썬 창에서 실행시키는 것이다. 명령창(cmd, terminal)에서 <code class="highlighter-rouge">python</code>을 실행시키고 코드를 입력하는 것과 같은 형태이다. <a href="https://greeksharifa.github.io/references/2019/01/26/Jupyter-usage/">Jupyter notebook</a>과도 비슷하다.</li>
      <li>장점은 명령창에서 바로 입력하는 경우 오타가 나면 다시 입력해야 하는데 편집기에 코드를 써 놓고 필요한 만큼만 <code class="highlighter-rouge">Ctrl + Enter</code>로 실행시키는 이 방식은 코드 수정과 재사용이 훨씬 편하다는 것이다.</li>
      <li>콘솔에 문제가 있거나 해서 현재 실행창을 재시작하고 싶으면 <code class="highlighter-rouge">Python Console</code> 왼쪽 <code class="highlighter-rouge">Rerun</code> 버튼(화살표)을 누르거나 <code class="highlighter-rouge">Ctrl + F5</code>를 입력한다.</li>
      <li>참고로 PyCharm 아래쪽/왼쪽/오른쪽에 있는 창들 중에서 옆의 숫자는 단축키를 간략하게 나타낸 것이다. 예를 들어 필자는 좀 전 설정에서 <code class="highlighter-rouge">Python Console</code> 창의 단축키를 <code class="highlighter-rouge">Alt + 8</code>로 설정해 놨는데, 그래서 옆에 <code class="highlighter-rouge">8</code> 이라는 숫자가 표시된다.</li>
    </ul>
  </li>
</ul>

<center><img src="/public/img/2019-02-07-PyCharm-usage/16.png" width="100%" /></center>

<ul>
  <li>Run &gt; Run…을 누르면 실행시키고 싶은 파일 목록이 나타난다. 이 중 원하는 파일(현재는 <code class="highlighter-rouge">tutorial</code>)을 선택하면 <code class="highlighter-rouge">Terminal</code>이라는 창에서 <strong><em>해당 파일의 전체 코드</em></strong>가 실행된다.
    <ul>
      <li>다시 실행할 때는 Run &gt; Run을 선택하면 마지막으로 실행한 파일이 전체 실행된다.</li>
      <li>아래 그림의 <code class="highlighter-rouge">Terminal</code> 창 왼쪽의 <code class="highlighter-rouge">ReRun</code> 버튼을 눌러도 마지막으로 실행한 파일이 다시 실행된다. 단축키는 <code class="highlighter-rouge">Ctrl + F5</code>이다.</li>
      <li>PyCharm 오른쪽 위에서도 실행할 파일을 선택 후 실행시킬 수 있다.</li>
    </ul>
  </li>
</ul>

<center><img src="/public/img/2019-02-07-PyCharm-usage/17.png" width="100%" /></center>

<center><img src="/public/img/2019-02-07-PyCharm-usage/18.png" width="100%" /></center>

<center><img src="/public/img/2019-02-07-PyCharm-usage/19.png" width="80%" /></center>

<ul>
  <li>PyCharm 아래쪽의 <code class="highlighter-rouge">Terminal</code> 창을 클릭하거나 <code class="highlighter-rouge">Alt + T</code> 단축키(바꾼 것이다)로 <code class="highlighter-rouge">Terminal</code> 창을 열어서 <code class="highlighter-rouge">python tutorial.py</code>를 입력한다.
    <ul>
      <li>그렇다. Python 파일 실행 방법과 똑같다. 이 <code class="highlighter-rouge">Terminal</code> 창은 명령창(cmd 또는 터미널)과 똑같다.</li>
      <li>대략 <code class="highlighter-rouge">tu</code> 정도까지만 입력하고 <code class="highlighter-rouge">Tab</code> 키를 누르면 파일명이 자동완성된다.</li>
      <li>이 방법도 역시 해당 파일에 들어있는 모든 코드를 전체 실행시킨다.</li>
      <li>터미널 창 답게 여러 개의 세션을 열어 놓을 수 있다. 기본적으로 <code class="highlighter-rouge">Local</code>이라는 이름의 탭이 생성되며, 오른쪽의 <code class="highlighter-rouge">+</code> 버튼을 클릭하라.</li>
    </ul>
  </li>
</ul>

<center><img src="/public/img/2019-02-07-PyCharm-usage/20.png" width="80%" /></center>

<ul>
  <li><code class="highlighter-rouge">Project</code> 창에서도 해당 파일을 <code class="highlighter-rouge">우클릭 &gt; Run (파일명)</code>을 클릭하면 해당 파일의 코드 전체가 실행된다.</li>
  <li>편집 창에서도 파일명 탭을 <code class="highlighter-rouge">우클릭 &gt; Run (파일명)</code>해도 된다. 실행 방법은 많다.</li>
  <li>Terminal에서 Local Environment에서 실행되는 대신, Remote SSH session에서 실행시키는 방법은 <a href="https://greeksharifa.github.io/references/2019/02/07/PyCharm-usage/#terminal%EC%97%90%EC%84%9C-ssh-session%EC%9C%BC%EB%A1%9C-%EC%97%B4%EA%B8%B0">여기</a>를 참고하면 된다.</li>
</ul>

<hr />

<h2 id="편집-창코드-편집기">편집 창(코드 편집기)</h2>

<p>코드를 편집하는 부분에도 여러 기능들이 숨어 있다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/27.png" width="100%" /></center>

<p>위 그림의 오른쪽 부분을 보자. 경고인 듯한 느낌표와 함께 여러 색깔의 줄이 있다. 현재 커서는 9번째 라인의 <code class="highlighter-rouge">example</code> 변수에 위치해 있다.</p>

<ul>
  <li>먼저 왼쪽에는 줄 번호(line number)라는 것을 다들 알 수 있을 것이다.
    <ul>
      <li>하지만 이 단축키는 모르는 사람이 많다. <code class="highlighter-rouge">Ctrl + G</code>를 누르면 원하는 라인으로 이동할 수 있다. 줄의 어느 부분으로 이동할지도 <code class="highlighter-rouge">line:column</code> 형식으로 정할 수 있다. 줄 번호만 지정하고 싶으면 그냥 숫자만 입력하면 된다.</li>
    </ul>
  </li>
  <li>빨간 화살표가 가리키고 있는 경고 표시는 현재 이 파일에 <strong>syntax error</strong>가 있다는 뜻이다. 메인 화면에도 해당 부분에는 빨간 줄이 그어진다(<code class="highlighter-rouge">printf</code>). 그리고 오른쪽에도 빨간색 bar가 생긴다.
    <ul>
      <li>이 bar들은 현재 파일에서의 상대적 위치를 뜻한다. 즉, 예를 들어 맨 아래에 있는 오류 코드가 화면에 안 보이더라도 bar는 제일 아래쪽 근처에 표시된다.</li>
    </ul>
  </li>
  <li>커서가 위치한 곳이 변수나 함수 등이라면 해당 파일의 모든 부분에서 같은 이름을 가진 변수(또는 함수)에는 옅은 초록색 배경색이 칠해진다. 그리고 해당 변수(함수)가 선언된 곳에는 옅은 주황색으로 배경색이 칠해진다(이 색깔은 <code class="highlighter-rouge">Settings</code>에서 바꿀 수 있다). 어디서 사용되고 있는지 쉽게 알 수 있다. 그리고 그림에서 오른쪽에도 주황색 또는 초록색 짧은 bar가 생긴 것을 볼 수 있다.
    <ul>
      <li>옅어서 잘 안보인다면 색깔을 바꾸거나 아니면 Find and Replace(<code class="highlighter-rouge">Ctrl + H</code>)로 찾으면 더 선명하게 표시되기는 하는데, 해당 이름을 포함한 다른 변수 등도 같이 선택된다는 문제가 있다. 적당히 선택하자.</li>
    </ul>
  </li>
  <li>특별히 <strong><em>TODO</em></strong> 주석문은 일반 회색 주석과는 다르게 연두색으로 눈에 띄게 칠해진다. 또한 오른쪽에 파란색 bar가 생긴다. 이 주석은 참고로 <code class="highlighter-rouge">TODO</code> 창(<code class="highlighter-rouge">Alt + 6</code>)에서도 확인 가능하다. 못다한 코딩이 있을 때 쓸 수 있는 좋은 습관이다.</li>
</ul>

<p>편집 창의 아무 부분을 우클릭하여 <code class="highlighter-rouge">Local History &gt; Show History</code>를 클릭하면 해당 파일이 어떻게 수정되어 왔었는지가 저장된다. 잘 안 쓸 수도 있지만 잘못 지운 상태로 코딩을 좀 진행했다거나 하는 상황에서 쓸모 있는 기능이다.</p>

<hr />

<h3 id="ipynb-파일-사용">.ipynb 파일 사용</h3>

<p>PyCharm에서도 <code class="highlighter-rouge">.ipynb</code>파일을 사용할 수 있다. 웹브라우저에서 보는 jupyter notebook과 모양이 매우 흡사하다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/36.png" width="100%" /></center>

<p>위쪽의 셀 실행 버튼을 누르면(초록색 삼각형) jupyter 서버 주소 토큰을 입력하라고 나온다. 본인이 jupyter 서버를 실행시켰다면 <a href="https://greeksharifa.github.io/references/2019/01/26/Jupyter-usage/#%EC%8B%A4%ED%96%89-%EB%B0%8F-%EC%A2%85%EB%A3%8C">jupyter notebook 서버를 켠 상태</a>에서 해당 주소를 입력해주고 실행하면 .ipynb 파일을 브라우저에서 쓰는 것처럼 사용할 수 있다.</p>

<hr />

<h3 id="자동완성-기능">자동완성 기능</h3>

<p>일반적인 편집기에는 다 들어있는, 변수나 함수 등의 이름을 일부만 입력하고 <code class="highlighter-rouge">Tab</code> 키를 누르면 자동완성이 된다는 것은 알고 있을 것이다.</p>

<p>아래는 일부 코드 블록을 간편하게 입력할 수 있는 방법을 소개한 것이다.</p>

<ul>
  <li>클래스 내부의 함수를 작성할 때는 <code class="highlighter-rouge">(</code>를 입력하는 순간 <code class="highlighter-rouge">self</code> 인자가 자동으로 추가된다. 기본적으로 써야 하는 인자이기 때문에 자동 추가되며, 이를 비활성화하고 싶으면 <code class="highlighter-rouge">File &gt; Settings &gt; Editor &gt; General &gt; Smart Keys</code>에서 바꿀 수 있다.</li>
  <li>함수나 클래스를 작성할 때, 삼중따옴표를 함수 prototype 정의 바로 밑에 써 주면 깔끔하게 함수 사용법을 정리할 수 있는 주석이 나타난다.
    <ul>
      <li>빈 줄에 함수 설명을, <code class="highlighter-rouge">param</code>에는 각 인자의 설명을, <code class="highlighter-rouge">return</code>에는 이 함수의 반환값에 대한 설명을 써 주자.</li>
    </ul>
  </li>
</ul>

<center><img src="/public/img/2019-02-07-PyCharm-usage/34.png" width="60%" /></center>

<hr />

<h3 id="빠른-선택-코드-정리-편집-등등-단축키">빠른 선택, 코드 정리, 편집 등등 단축키</h3>

<p>원하는 부분을 빠르게 선택할 수 있는 단축키는 많다. 이를 다 알고 빠르게 할 수 있다면 코딩 속도는 아주 빨라진다.</p>

<ul>
  <li>변수/함수 더블클릭: 해당 변수 이름 선택</li>
  <li><code class="highlighter-rouge">Ctrl + Z</code>: 실행 취소(Undo)</li>
  <li><code class="highlighter-rouge">Ctrl + Shift + Z</code>: 재실행(Redo)</li>
  <li><code class="highlighter-rouge">Ctrl + D</code>(Duplicate): 현재 커서가 있는 한 줄(또는 드래그한 선택 범위)을 복사해 아래에 붙여 넣는다.</li>
  <li><code class="highlighter-rouge">Ctrl + X</code> / <code class="highlighter-rouge">Ctrl + C</code>: 현재 커서가 있는 한 줄(또는 드래그한 선택 범위)을 잘라내기/복사한다. 한 줄도 된다는 것을 기억하라.</li>
  <li><code class="highlighter-rouge">Ctrl + W</code>: 현재 선택 범위의 한 단계 위 범위를 전체 선택한다. 무슨 말인지 모르겠다면 직접 해 보면 된다. 범위는 블록이나 괄호 등을 포함한다.</li>
  <li><code class="highlighter-rouge">Tab</code>: 현재 커서가 있는 한 줄(또는 드래그한 선택 범위)를 한 단계(오른쪽으로 이동) indent한다.</li>
  <li><code class="highlighter-rouge">Shift + Tab</code>: 현재 커서가 있는 한 줄(또는 드래그한 선택 범위)를 반대 방향으로(왼쪽으로 이동) 한 단계 indent한다.</li>
  <li>
    <p><code class="highlighter-rouge">Ctrl + A</code>: 현재 파일의 코드를 전체선택한다.</p>
  </li>
  <li><code class="highlighter-rouge">Ctrl + Shift + O</code>(Import Optimization): 코드 내에 어지럽게 널려 있는 import들을 파일 맨 위로 모아 잘 정리한다.</li>
  <li>
    <p><code class="highlighter-rouge">Ctrl + Shift + L</code>: 코드의 빈 줄, indentation 등을 한 번에 정리한다.</p>
  </li>
  <li><code class="highlighter-rouge">Ctrl + 좌클릭</code>: 해당 변수/함수가 선언된 위치로 화면/커서가 이동한다. 변수가 어떻게 정의됐는지 또는 함수가 어떻게 생겼는지 보기 유용하다.</li>
  <li><code class="highlighter-rouge">Alt + 좌클릭</code>: 커서를 원하는 곳에 일단 놓고, 또 같은 것을 입력하고 싶은 곳에 <code class="highlighter-rouge">Alt</code>를 누른 채로 새로 클릭하면, 커서가 여러 개가 되는 것을 확인할 수 있다. 이 상태에서 키보드로 입력을 시작하면 여러 곳에서 한번에 입력이 가능하다.</li>
</ul>

<p>이외에도 기능은 정말 많다(Toggle Case, Convert indents to space/tab, Copy as Plain Text, Paste without Formatting, …). 한번 잘 찾아보자.</p>

<p>각각의 기능들은 Edit 탭이나 Navigate, Code, Refactor 탭 등에 잘 분류되어 있다. 한번쯤 살펴보고 본인에게 필요한 기능들은 기억해두면 좋다.</p>

<hr />

<h3 id="찾기및-바꾸기-ctrl--f--ctrl--h">찾기(및 바꾸기), (<code class="highlighter-rouge">Ctrl + F | Ctrl + H</code>)</h3>

<p>찾기 및 바꾸기의 기본 단축키는 <code class="highlighter-rouge">Ctrl + R</code>이다(<strong>R</strong>eplace). 많은 다른 프로그램들은 <code class="highlighter-rouge">Ctrl + H</code>를 쓰기 때문에 바꾸는 것도 좋다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/28.png" width="100%" /></center>

<p>여기도 여러 기능들이 있다. 찾기 설명은 찾기 및 바꾸기의 설명 안에 포함되므로 생략하겠다.<br />
아래에서 설명할 기능들은 모두 그림에 나온 버튼이나 체크박스 등에 대한 것이다.</p>

<ul>
  <li>왼쪽 검색창에 찾고자 하는(또는 대체될) 문자열 또는 정규식을 입력한다. 아래쪽 창에는 대체할 문자열을 입력한다.
    <ul>
      <li>왼쪽 돋보기를 클릭하면 이전에 검색했던 문자열들을 재검색할 수 있다.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">F3</code>: 다음 것 찾기</li>
  <li><code class="highlighter-rouge">Shift + F3</code>: 이전 것 찾기</li>
  <li>Find All: 전부 다 찾아서 보여준다.</li>
  <li>Select All Occurrences: 매칭되는 결과를 전부 선택한다.</li>
  <li>Show Filter Popup: 찾을 범위를 지정할 수 있다. 전부(Anywhere), 주석에서만(In comments), 문자열에서만(In String Literals), 둘 다에서만, 혹은 제외하고 등의 필터를 설정 가능하다.</li>
  <li>Match Case: 체크하면 대소문자를 구분한다.</li>
  <li>Words: 정확히 단어로 맞아야 할 때(해당 문자열을 포함하는 단어를 제외하는 등) 체크한다.</li>
  <li>Regex: <a href="https://greeksharifa.github.io/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(re)/2018/07/20/regex-usage-01-basic/">정규표현식</a>을 사용하여 찾는다. 잘 쓸 줄 안다면 아주 좋다.</li>
  <li>오른쪽에는 몇 개나 매칭되는 문자열을 찾았는지 보여준다(3 matches). 만약 하나도 없으면 문자 입력 창이 빨갛게 되면서 No matches라고 뜬다.</li>
  <li>Replace(<code class="highlighter-rouge">Alt + p</code>): 현재 선택된 부분을 대체한다..</li>
  <li>Replace all(<code class="highlighter-rouge">Alt + a</code>): 매칭되는 모든 문자열을 찾아 대체한다.</li>
  <li>Exclude: 해당 매칭된 부분은 대체할 부분에서 제외한다.</li>
  <li>Preserve Case: 대체 시 대소문자 형식을 보존한다.</li>
  <li>In Selection: 파일 전체가 아닌 선택한 부분에서만 찾는다.</li>
</ul>

<h3 id="더-넓은-범위에서-찾기">더 넓은 범위에서 찾기</h3>

<p>선택한 파일 말고 더 넓은 범위에서 찾으려면 <code class="highlighter-rouge">Ctrl + Shift + F</code>를 누르거나 다음 그림을 참고한다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/29.png" width="100%" /></center>

<center><img src="/public/img/2019-02-07-PyCharm-usage/30.png" width="80%" /></center>

<p>위의 Match Case등은 사용법이 똑같지만, 여기서는 파일뿐 아니라 프로젝트 전체, 모듈, 디렉토리, 또는 특정 범위(scope)에서 찾을 수 있다. <code class="highlighter-rouge">Edit &gt; Find &gt; </code>안의 다른 선택지들 역시 사용법은 크게 다르지 않으니 참고하자.</p>

<p>다른 (범용) 찾기 단축키로 <code class="highlighter-rouge">Shift + Shift</code>(Shift 키를 두번 누름)이 있다. 한번 해 보자.</p>

<h3 id="변수함수-등이-사용된-위치-찾기">변수/함수 등이 사용된 위치 찾기</h3>

<p>찾고자 하는 변수/함수를 우클릭하여 <code class="highlighter-rouge">Find Usages</code>를 클릭하거나 <code class="highlighter-rouge">Alt + F7</code>을 누른다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/31.png" width="100%" /></center>

<p>그러면 해당 변수/함수가 어디서 사용되었는지 정보가 전부 나온다. 왼쪽에 있는 많은 버튼들로 적절한 그룹별로 묶거나 하는 등의 작업을 할 수 있다.</p>

<h3 id="refactor이름-재지정">Refactor(이름 재지정)</h3>

<p>변수명을 바꾸고 싶어졌을 때가 있다. 무식하게 일일이 바꾸거나, 아니면 <code class="highlighter-rouge">Find and Replace</code>로 선택적으로 할 수도 있다.</p>

<p>하지만 매우 쉽고 편리한 방법이 있다. 해당 변수를 선택하고 <code class="highlighter-rouge">Shift + F6</code>을 누른다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/32.png" width="80%" /></center>

<p>원하는 이름으로 바꾸고 <code class="highlighter-rouge">Refactor</code>을 누르면 해당 변수만 정확하게 원하는 이름으로 바뀐다. 심지어 import해서 사용한 다른 파일에서도 바뀐다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/33.png" width="100%" /></center>

<p><em>아주 편리하다.</em></p>

<hr />

<h2 id="창-위치-및-크기-변경">창 위치 및 크기 변경</h2>

<p><code class="highlighter-rouge">Python Console</code> 등의 창은 위치나 크기가 변경 가능하다. 크기는 창의 경계에 마우스 커서를 갖다대는 방식이니 굳이 설명하지 않겠다.<br />
위치는 탭을 끌어서 이동시키거나 아니면 <code class="highlighter-rouge">우클릭 &gt; Move to &gt; 원하는 곳</code>을 선택하면 된다.</p>

<p>또 모니터를 2개 이상 쓴다면 <code class="highlighter-rouge">View Mode</code>에서 해당 설정을 변경할 수 있다. 기본은 PyCharm 내부에 위치 고정된 <code class="highlighter-rouge">Dock Pinned</code> 모드이다. <code class="highlighter-rouge">Float</code>이나 <code class="highlighter-rouge">Window</code>를 선택하면 위치를 자유롭게 이동할 수 있다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/21.png" width="100%" /></center>

<p>모니터 크기는 충분한데 코드는 위아래로만 길게 보여서 공간이 아까웠다면, PyCharm에서는 굳이 그럴 필요 없다. Vim의 Split View와 비슷한 기능이 있다.</p>

<p>편집 창(메인 화면)의 탭을 우클릭한 다음 <code class="highlighter-rouge">Split Vertically</code>를 클릭해 보라. <code class="highlighter-rouge">Split Horizontally</code>도 괜찮다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/23.png" width="100%" /></center>

<center><img src="/public/img/2019-02-07-PyCharm-usage/24.png" width="100%" /></center>

<p>동일한 파일을 여러 번 열고 다른 부분을 보는 것도 가능하다. 꽤 유용한 기능이다.</p>

<hr />

<h2 id="favorites-창alt--2">Favorites 창(<code class="highlighter-rouge">Alt + 2</code>)</h2>

<p><code class="highlighter-rouge">Alt + 2</code>를 눌러 <code class="highlighter-rouge">Favorites</code> 창을 연다.</p>

<p>말 그대로 즐겨찾기이다. 자주 사용하는 파일을 <code class="highlighter-rouge">Favorites</code>에 등록할 수 있다. 기본적으로 현재 프로젝트 이름으로 리스트가 하나 생성되어 있다.<br />
이게 싫거나 새로운 리스트를 추가하고 싶으면 아래 그림의 오른쪽에 보이는 <code class="highlighter-rouge">Add to New Favorites List</code>를 클릭하라.</p>

<p>그러면 <code class="highlighter-rouge">Favorites</code> 창에 해당 리스트에 추가한 파일이 등록된다. 이제 프로젝트 창에서 찾을 필요 없이 바로 파일을 열어볼 수 있다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/25.png" width="100%" /></center>

<hr />

<h2 id="run-창alt--4">Run 창(<code class="highlighter-rouge">Alt + 4</code>)</h2>

<p><code class="highlighter-rouge">Alt + 3</code>은 기본적으로 할당되어 있지 않다. 추가하고 싶으면 추가하라.</p>

<p><code class="highlighter-rouge">Run</code> 창은 조금 전 코드를 실행할 때 본 것이다. 여기서는 왼쪽에 몇 가지 버튼이 있는데, 각각</p>

<ul>
  <li>Rerun(마지막 실행 파일 재실행)</li>
  <li>Stop(현재 실행 중인 파일 실행 중단)</li>
  <li>Restore Layout(레이아웃 초기화)</li>
  <li>Pin Tab(현재 실행 탭 고정)</li>
  <li>Up/Down to Stack Trace(trace 상에서 상위 또는 하위 단계로 이동)</li>
  <li>Soft-Wrap(토글 키. 활성화 시 출력 내용이 한 줄을 넘기면 아래 줄에 출력됨. 비활성화 시 스크롤해야 나머지 내용이 보인다)</li>
  <li>Scroll to the end(제일 아래쪽으로 스크롤)</li>
  <li>Print(출력 결과를 정말 프린터에서 뽑는 거다)</li>
  <li>Clear All(현재 출력 결과를 모두 지우기)</li>
</ul>

<p>Soft-wrap 등은 꽤 유용하므로 잘 사용하자.</p>

<p><code class="highlighter-rouge">Run</code> 창을 우클릭 시 <code class="highlighter-rouge">Compare with Clipboard</code> 항목이 있는데, 현재 클립보드에 있는(즉, <code class="highlighter-rouge">Ctrl + C</code> 등으로 복사한) 내용과 출력 결과를 비교하는 창을 띄운다. 정답 출력 결과를 복사해 놨다면 유용하게 쓸 수 있다.</p>

<hr />

<h2 id="todo-창alt--6">TODO 창(<code class="highlighter-rouge">Alt + 6</code>)</h2>

<p>PyCharm에서는 주석(<code class="highlighter-rouge">#</code>)을 달면서 앞에 <code class="highlighter-rouge">TODO:</code>라는 문구를 적으면 해당 주석은 특별히 눈에 띄는 연두색으로 바뀐다.</p>

<p>이 <strong>TODO</strong>들은 앞으로 해야 할 것을 모아 놓은 것이다. 이를 나중에 찾아보려면 PyCharm 아래쪽의 <code class="highlighter-rouge">TODO</code> 창을 클릭하거나 <code class="highlighter-rouge">Alt + 6</code>으로 열자.<br />
그럼 현재 프로젝트의 어느 부분이 미완성인 채로 남아 있는지 한번에 볼 수 있다. 기본적으로 파일별로 정렬되어 있다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/35.png" width="100%" /></center>

<hr />

<h2 id="structure-창alt--7">Structure 창(<code class="highlighter-rouge">Alt + 7</code>)</h2>

<p>현재 파일이 어떤 구조로(클래스는 무엇을 포함하고, 함수는 어떤 statement들을 포함하는지 등) 되어 있는지 살펴보려면 코드를 한줄한줄 다 뜯어보는 대신 Structure 창에서 볼 수 있다.<br />
어떤 변수가 어디에 정의되었는지까지도 볼 수 있다.</p>

<hr />

<h2 id="python-console-창alt--8">Python Console 창(<code class="highlighter-rouge">Alt + 8</code>)</h2>

<p>단축키는 필자가 지정한 것이다.</p>

<p>이는 명령창에서 Python을 실행했을 때 나타나는 것과 같다고 말했었다. 어려울 것 없이 똑같이 사용할 수 있다.</p>

<p>단, 사용 환경에 따라 이런 대화형 창에서는 가용 메모리를 다 쓰지 못하는 경우가 있다. 예를 들어 GPU 메모리를 수 GB씩 쓰는 학습 알고리즘 등의 경우 터미널에서 <code class="highlighter-rouge">python 파일명</code>으로 실행하면 잘 작동하는데 대화형 창에서 실행하면 작동이 중지되는 것을 종종 볼 수 있다. 참고하자.</p>

<hr />

<h2 id="version-control-창alt--9">Version Control 창(<code class="highlighter-rouge">Alt + 9</code>)</h2>

<p>이건 Git 기능을 PyCharm에 옮겨놓은 것과 같다. git 사용법을 안다면 쉽게 이용 가능하다. 하지만 git을 잘 알고 있다면 그냥 Python의 <code class="highlighter-rouge">terminal</code> 창을 열어서 git 명령어를 치는 것이 편할 수 있다.</p>

<hr />

<h2 id="sciview-창alt--0">SciView 창(<code class="highlighter-rouge">Alt + 0</code>)</h2>

<p>PyCharm에서 <code class="highlighter-rouge">matplotlib</code> 등으로 그래프를 그린다면 바로 이 창에 표시가 된다.</p>

<p>여기서 한 장씩 보기 또는 grid 모드로 보기 등을 선택할 수 있고, 확대 및 축소, 1:1, 창 크기에 맞추기 등의 옵션도 가능하다.</p>

<p>그림 오른쪽 위에 작게 표시되는 x 표시를 누르면 그림을 지울 수 있다. 또한 우클릭을 통해 저장하거나 전체 삭제 등의 작업을 할 수 있다. 배경화면 사진으로도 지정할 수 있다(!).</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/37.png" width="100%" /></center>

<p>참고로 pycharm에서는 일반적으로 <code class="highlighter-rouge">plt.show()</code>를 그냥 하면 그림이 표시되지 않는 경우가 있다. 이에 대한 해결법은 <a href="https://stackoverflow.com/questions/24886625/pycharm-does-not-show-plot">링크</a>를 참고하자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">interactive</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="c1"># plt.show(block=True)
</span></code></pre></div></div>

<hr />

<h2 id="디버깅debugging">디버깅(Debugging)</h2>

<p>PyCharm의 훌륭한 기능 중 하나이다. 사실 웬만한 코드 편집기에 있기는 한데, python을 쓰는 사람들 중에 이를 활용할 줄 알아서 쓰는 경우는 생각보다 많지 않은 것 같다.<br />
<em>(물론 알아서 코드를 수정해 주는 것은 아니다…)</em></p>

<p>예를 들어 다음과 같은 프로그램을 짰다고 생각해 보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">example</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">example</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

<span class="n">example</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">20</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
    <span class="n">func</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">example</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'fibonacci({})</span><span class="se">\t</span><span class="s">: {:8d}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
</code></pre></div></div>

<p>결과는 다음과 갈다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fibonacci(0)	:        2
fibonacci(1)	:        3
fibonacci(2)	:        5
fibonacci(3)	:        8
...
</code></pre></div></div>

<p>피보나치 수열은 2부터 시작하지 않으므로 잘못되었다. 그러면? 디버깅을 시작한다(물론 간단한 예시라서 바로 고칠 수 있지만 우선 넘어간다).</p>

<p>디버깅을 시작하는 방법은 여러 가지가 있다. 이는 코드를 실행할 때와 매우 비슷한데, 초록색 삼각형 대신 벌레 모양의 아이콘을 클릭하면 된다. 그게 다이다. <code class="highlighter-rouge">Run</code> 대신에 <code class="highlighter-rouge">Debug</code>를 누를 뿐이다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/38.png" width="60%" /></center>

<p>그러나 시작하기 전 <strong>Breakpoint</strong>를 하나 설정한다. 버그가 있다고 생각하는 시점 직전에 설정하면 된다. 우선 이번 예시에서는 example을 선언한 라인에 설정하겠다. 코드 왼쪽, 라인 번호 바로 오른쪽 빈 공간을 클릭하자.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/39.png" width="80%" /></center>

<p>그러면 빨간 점과 함께 해당 라인의 배경이 빨간색으로 칠해진다.</p>

<p>그리고 <code class="highlighter-rouge">Run &gt; Debug</code>를 클릭한다. 벌레를 클릭해도 좋다.<br />
뭔가 다른 프로그램이 실행되고 있는 것 같으면, 실행하려는 파일명을 다시 확인하라.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/40.png" width="100%" /></center>

<p>디버깅할 때는 코드를 그냥 실행할 때와는 동작이 많이 다르다.</p>
<ul>
  <li>실행 시에는 코드가 처음부터 끝까지 멈춤 없이 진행된다.
    <ul>
      <li>물론 사용자의 입력을 기다리거나, 계산이 오래 걸리거나, <code class="highlighter-rouge">sleep()</code>등으로 지연시키는 경우는 예외이다. 그러나 이 경우에도 입력/계산/시간이 완료되면 자동으로 다음 코드를 지체 없이 빠르게 실행한다.</li>
    </ul>
  </li>
  <li>디버깅 시, 처음에는 <strong>Breakpoints</strong> 까지는 실행 시와 똑같이 순식간에 진행된다. 그러나 <strong>Breakpoints</strong>에 도달하면 그 라인의 실행 직전까지만 코드가 실행된 후 대기 상태로 전환한다(이름이 왜 breakpoint이겠는가?).</li>
  <li>그리고 이후 진행은 사용자가 무엇을 클릭했느냐에 따라 달라진다. 디버깅 모드에서는
    <ul>
      <li>한 줄 실행(딱 한줄만 실행),</li>
      <li>지정 위치까지 실행(해당 지점을 <strong>Breakpoints</strong> 삼아 그 라인 직전까지 실행),</li>
      <li>어떤 함수 내부로 들어가 한 줄씩 실행,</li>
      <li>현재 실행 중인 함수 밖으로 나오는 데까지 실행</li>
      <li>등등의 옵션이 있는데, 각각의 옵션에 따라 딱 필요한 만큼까지만 코드가 실행된 후 대기 상태로 멈춰 있는다.</li>
    </ul>
  </li>
</ul>

<p>우선 <code class="highlighter-rouge">F8</code>을 눌러보자. <code class="highlighter-rouge">Step Over</code>이라고 되어 있다. 위 그림에서 빨간 박스 안의 첫 번째 아이콘을 클릭해도 된다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/41.png" width="100%" /></center>

<ul>
  <li>그럼 한 줄을 실행하고 다음 statement로 넘어가 있다. 빈 줄은 건너뛴다.</li>
  <li>실행한 줄 옆에 그 줄의 변수에 들어 있는 값이 업데이트된다. <code class="highlighter-rouge">example</code> 변수는 <code class="highlighter-rouge">list</code> 타입이며, 값 1을 20개 갖고 있는 리스트이다.</li>
  <li>왼쪽 아래 untitled.py: 7로 값이 바뀌었다. 현재 <code class="highlighter-rouge">untitled.py</code>의 7번째 줄을 실행하기 직전이란 뜻이다.</li>
  <li>아래쪽 <code class="highlighter-rouge">Variables</code> 창에서 접근할 수 있는 변수 목록이 업데이트되었다. 현재는 <code class="highlighter-rouge">example</code> 하나뿐이므로 그 값을 볼 수 있다.</li>
</ul>

<p><code class="highlighter-rouge">Variables</code> 창에서는 현재 scope에서 접근가능한 변수 목록이 자동으로 업데이트되지만, 미리 보고 싶거나 혹은 계산 결과 등을 보고 싶다면 새로운 <em>Watch</em>를 추가할 수 있다. <code class="highlighter-rouge">Variables</code> 창 아무 곳이나 우클릭하면 새로 보고 싶은 변수 혹은 수식 결과값 등을 추가할 수 있다. 예시로 <code class="highlighter-rouge">example * 2</code>를 추가해 보았다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/42.png" width="100%" /></center>

<p><code class="highlighter-rouge">Step Over</code> 외에 다른 버튼들은 다음과 같다.</p>

<ul>
  <li><code class="highlighter-rouge">Step Into</code>(<code class="highlighter-rouge">F7</code>): 코드가 어떤 함수를 실행하는 경우(예: 예시의 <code class="highlighter-rouge">func</code>, 내장 함수인 <code class="highlighter-rouge">print</code> 등), 해당 함수의 내부로 들어가서 실행할 수 있게 해 준다.
    <ul>
      <li>아래 예시는 <code class="highlighter-rouge">func()</code> 내부로 들어간 모습을 보여준다.</li>
      <li>참고로 argument로 무엇이 전달되었는지 등도 표시된다(아래 그림의 경우 <code class="highlighter-rouge">idx: 5</code>라고 되어 있는 것을 볼 수 있다). argument뿐 아니라 업데이트되고 있는 변수들 모두 값을 보여주며, 방금 업데이트된(조금 전 실행한 라인의 결과) 값은 회색이 아닌 주황색으로 표시된다.</li>
    </ul>
  </li>
</ul>

<center><img src="/public/img/2019-02-07-PyCharm-usage/43.png" width="80%" /></center>

<ul>
  <li><code class="highlighter-rouge">Step Into My Code</code>: 위의 <code class="highlighter-rouge">Step Into</code>는 <code class="highlighter-rouge">print</code> 같은 내장 함수들 안으로까지 파고들어 코드를 실행한다. 내장 함수가 오작동하는 것은 아니기 때문에 자신의 코드만 검사하고 싶다면 이쪽을 택하자.</li>
  <li><code class="highlighter-rouge">Force Step Into</code>: 말 그대로 강제로 함수 안으로 들어가 실행시킨다. 비활성화된 경우가 많을 것이다.</li>
  <li><code class="highlighter-rouge">Step Out</code>(<code class="highlighter-rouge">Shift + F8</code>): 실행되고 있는 함수 밖으로 나오는 데까지 실행시킨다. <code class="highlighter-rouge">func</code>  또는 <code class="highlighter-rouge">print</code> 끝난 다음 줄로 이동한다.</li>
  <li><code class="highlighter-rouge">Run to Cursor</code>(<code class="highlighter-rouge">Alt + F9</code>): 커서가 있는 곳으로까지 코드를 실행시킨다. 반복문 내부인 경우 가장 가까운 반복 단계에서 멈춘다.</li>
</ul>

<p>위의 모든 명령은 <strong>Breakpoint</strong>에서 걸린다. 즉, <code class="highlighter-rouge">Run to Cursor</code> 등으로 많이 이동하려 해도 그 사이에 <strong>Breakpoint</strong>가 있으면 그 직전까지만 실행된 상태로 멈춘다.</p>

<p>이런 기능들을 활용하면서 디버깅하면 어느 단계에서 코드가 잘못 되었는지 확인할 수 있다.</p>

<p><strong>Breakpoint</strong>에는 한 가지 중요한 기능이 있다. 지금까지 설정한 것은 코드가 설정된 라인에 가면 무조건 멈추는데, 이 조건을 바꿀 수 있다. 8번째 줄에 <strong>Breakpoint</strong>를 설정하고, <strong>Breakpoint</strong>를 나타내는 빨간 원을 우클릭하자.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/44.png" width="60%" /></center>

<p>조건을 설정할 수 있는 창이 나온다.</p>

<p>아래의 <code class="highlighter-rouge">More...</code>를 클릭하면,</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/45.png" width="100%" /></center>

<p>더 자세한 조건을 설정할 수 있다.</p>

<p>예시를 한 개만 들어보겠다. 8번째 줄의 <strong>Breakpoint</strong>를 아래처럼 설정한다. <code class="highlighter-rouge">i == 5</code> 일 때만 Breakpoint가 작동할 것이다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/46.png" width="85%" /></center>

<p>조건을 설정하면 빨간 원 옆에 <code class="highlighter-rouge">?</code>가 생기면서 condition이 설정되었음을 나타낸다.<br />
디버깅 모드를 종료했다가 다시 시작한 다음, 프로그램 끝에 커서를 놓고 <code class="highlighter-rouge">Run to Cursor</code>를 실행해 보자.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/47.png" width="100%" /></center>

<p>그러면 <code class="highlighter-rouge">i == 5</code>일 때 <code class="highlighter-rouge">func</code> 함수 내부에 멈춰 있음을 볼 수 있다. 한 번 더 <code class="highlighter-rouge">Run to Cursor</code>로 이동하면 그때서야 끝부분으로 이동한다. 즉 <code class="highlighter-rouge">i == 5</code>인 조건을 지났기 때문에 다시 발동하지 않는 것이다.</p>

<p>이 기능은 반복문이 여러 차례 반복된 뒤에야(예: 1000번쯤, <code class="highlighter-rouge">Step Over</code>를 1000번씩 누르긴 싫을 것이다) 버그가 나타나는 경우 해당 지점 직전에까지 가도록 Breakpoint를 설정하는 방법으로 쉽게 탐색할 수 있다.</p>

<p>잘 쓰면 꽤 유용하니 이것도 익혀 두도록 하자.</p>

<hr />

<h2 id="profilers코드-실행시간-측정">Profilers(코드 실행시간 측정)</h2>

<p>코드 실행시간을 측정할 때 매번 코드 시작과 끝 지점에 <code class="highlighter-rouge">start_time</code>와 <code class="highlighter-rouge">end_time</code> 같은 코드를 삽입하지 않고도 특정 함수나 코드 일부분 등의 실행 시간을 측정하는 기능을 PyCharm에서 제공한다. 이는 Terminal이나 IPython 등으로 실행한 것이 아닌 PyCharm의 <code class="highlighter-rouge">Run</code> 과 같은 방식으로 파일을 실행시켰을 때(<a href="https://greeksharifa.github.io/references/2019/02/07/PyCharm-usage/#configurations%EC%8B%A4%ED%96%89-%EC%8B%9C-parameter-%EC%84%A4%EC%A0%95">Configurations</a>에서 설정 가능) 설정 가능하며, Professional 버전에서만 이용 가능하다.</p>

<p>정확히는, <code class="highlighter-rouge">Configurations</code>에서 실행할 파일을 지정한 다음, <code class="highlighter-rouge">Run</code> 버튼이 아닌 <code class="highlighter-rouge">Profile</code> 버튼을 클릭한다.</p>

<p><code class="highlighter-rouge">temp.py</code> 파일을 다음과 같이 작성했다고 하자.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/69.png" width="80%" /></center>

<p>이제 이 코드에서 어느 부분이 실행시간의 많은 부분을 차지하는지 알아보자. PyCharm의 우상단에 있는 <code class="highlighter-rouge">Profile</code> 버튼을 클릭한다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/70.png" width="80%" /></center>

<p>그러면 실행창에는 다음과 같이 <code class="highlighter-rouge">Starting cProfile profiler</code>라는 문구가 출력되면서 실행이 된다. <code class="highlighter-rouge">done</code> 출력 이후에 한 줄이 더 출력되어 있는데, Snapshot(pstat 파일)이 지정된 경로에 저장되었다는 뜻이다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/71.png" width="100%" /></center>

<p>그리고 실행이 끝나면 확장자가 pstat인 파일이 열린다. 실행이 너무 오래 걸린다면, 위 그림의 빨간 박스(<code class="highlighter-rouge">Capture Snapshot</code>, 실행이 끝난 상태에서는 비활성화됨)를 클릭하면 snapshot이 바로 저장되면서 중간 결과를 볼 수 있다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/74.png" width="100%" /></center>

<p>pstat 파일에는 2개의 탭이 있다. <code class="highlighter-rouge">Statistics</code> 탭에는 각 함수별로</p>
<ul>
  <li>실행 수</li>
  <li>해당 함수에 포함된 모든 함수의 실행 시간을 모두 더한 값</li>
  <li>해당 함수 자체만의 실행 시간의 총합(해당 함수가 여러 번 실행되었을 수 있으므로)
이 나열되어 있다.</li>
</ul>

<p>정확히는 사용자 정의 함수와 같은 일반 함수 외에도 Python 내장 함수(<code class="highlighter-rouge">print</code> 등) 및 기본(<code class="highlighter-rouge">__init__</code> 등) 함수, class, 실행 파일 등이 포함된다.</p>

<p>원하는 함수명을 오른쪽 클릭하면 해당 함수가 위치한 곳으로 이동하거나, 아래의 <code class="highlighter-rouge">Call Graph</code>에서 찾아볼 수도 있다.</p>

<p><code class="highlighter-rouge">Call Graph</code> 탭에서는 어떤 파일/함수에서 어떤 함수가 실행(call)되었고, 각 함수의 실행 시간을 전부 볼 수 있다.<br />
이 기능은 복잡한 코드가 어떤 과정으로 실행되는지를 대략 알아보는 데도 쓸 수도 있다(순서는 Traceback을 보는 것이 낫다).</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/73.png" width="100%" /></center>

<p>왼쪽 위에 있는 <code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">-</code> 등의 메뉴에서는 그림 확대/축소, 화면 맞추기, 이미지로 저장 등을 수행할 수 있다.</p>

<hr />

<h2 id="configurations실행-시-parameter-설정">Configurations(실행 시 parameter 설정)</h2>

<p>실행(Run)이나, 디버깅(Debugging) 버튼을 통해서 실행하고자 할 때, 엉뚱한 파일이 실행되는 경우가 있다. 이는 실행 버튼 바로 옆의 실행 파일명 또는 configuration 이름을 살펴보고 원하는 부분이 아니라면 바꿔주도록 하자.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/49.png" width="70%" /></center>

<p>참고로, <code class="highlighter-rouge">Run/Debug configuration</code> 설정 창에서는 실행 파일뿐 아니라 인자(argparse 등에서 사용하는 argument)를 설정해 줄 수도 있다. Python에서는 기본적으로 실행 시 인자를 주기 위해서는 명령창에서 <code class="highlighter-rouge">python &lt;실행할 파일.py&gt; --option1 &lt;option1&gt;</code> 형식으로 실행시켜야 하는데, PyCharm에서는 이 설정을 저장해두고 바로바로 쓸 수 있다. 위의 그림에서 <code class="highlighter-rouge">Edit Configurations</code>를 눌러보자.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/50.png" width="100%" /></center>

<p>순서대로 설명하면,</p>
<ul>
  <li>(빨간색) configuration의 이름을 설정할 수 있다. 기본적으로 실행하고자 하는 파일명으로 설정되며, 파일명으로 뿐만 아니라 원하는 이름으로 변경할 수 있다.</li>
  <li>(주황색) 실행하고자 하는 python 파일을 설정할 수 있다. 여기서 직접 추가하거나, 상단 메뉴 바의 <code class="highlighter-rouge">Run</code>에서 새로 파일을 설정하면 추가된다.</li>
  <li><strong>(노란색) 딥러닝 등에서 보통 많이 쓰는 <code class="highlighter-rouge">argparse</code>에서 인자를 받곤 하는데 이를 여기서 추가할 수 있다. 물론 argparse 뿐만 아니라 <code class="highlighter-rouge">sys.argv[]</code>가 받는 것도 동일하다.</strong> <em>사실 이게 제일 중요한 듯</em></li>
  <li>(초록색) 원하는 실행 환경을 바꿔줄 수 있다.</li>
  <li>(파란색) 실행 폴더의 위치를 지정한다. 기본적으로 실행 파일과 같은 위치로 지정되며, Python 코드 내의 상대 경로는 이 경로의 영향을 받는다.</li>
  <li>(남색) 콘솔에서 실행시킬지 등을 결정할 수 있다. 기본적으로는 해제되어 있다.</li>
  <li>(보라색) 실행시키기 전에 tool window 등을 미리 활성화 할 수 있다. 가능한 메뉴는 다음과 같다.</li>
</ul>

<center><img src="/public/img/2019-02-07-PyCharm-usage/51.png" width="40%" /></center>

<hr />

<h2 id="ssh를-통한-외부-서버-원격-접속">SSH를 통한 외부 서버 원격 접속</h2>

<p>보통 ssh를 통해서 외부 서버에 진입할 때는 명령창에서 vim이나, 혹은 기타 조잡한(?) 편집기를 통해서 코드 수정을 하게 된다. 그러나, PyCharm Pro 버전은 SSH로 접속할 수 있는 외부 서버를 연결하여 코드를 편집하면서, 서버에 변경사항을 실시간으로 업데이트할 수 있다.</p>

<p>이 강력한 기능은 아쉽게도 community 버전에서는 지원하지 않는다.</p>

<p>먼저 새 프로젝트 또는 로컬에 존재하는 기존 프로젝트를 연다.<br />
<code class="highlighter-rouge">Settings &gt; Project: name  &gt; Project Interpreter</code> 로 이동한 뒤, 오른쪽 위의 톱니바퀴를 누르면 <code class="highlighter-rouge">Add</code> 또는 <code class="highlighter-rouge">Show All</code>이 뜬다. <code class="highlighter-rouge">Add</code>를 누르자. <code class="highlighter-rouge">Show All</code>을 누른 다음 <code class="highlighter-rouge">+</code> 버튼을 눌러도 좋다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/57.png" width="100%" /></center>

<p>새 Interpreter를 만드는 과정에서, Virtualenv나 conda 등이 아닌 SSH Interpreter를 선택해준다. 그리고 서버 설정을 똑같이 입력해준다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/58.png" width="100%" /></center>

<p>다음 화면에서 비밀번호도 잘 입력해준다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/59.png" width="100%" /></center>

<p>그러면 이제 서버에 저장되어 있을 Interpreter를 설정하는 단계이다. 여러분이 그냥 Python 하나만 깔아놓고 쓰거나, Conda를 쓰거나, Virtualenv를 쓰거나 하는 경우마다 Python Interpreter의 위치는 전부 다르다.<br />
아무튼 어딘가에 있을 <code class="highlighter-rouge">python.exe</code>를 잘 찾아서 경로를 지정해 주어야 한다. Ubuntu 환경에서 Miniconda를 쓰는 필자는 대략 다음과 같은 interpreter 경로를 갖는다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/60.png" width="100%" /></center>

<p>Interpreter 경로 지정은 오른쪽의 디렉토리 아이콘을 누르면 서버에 존재하는 파일과 디렉토리를 볼 수 있다.<br />
그리고 관리자 권한으로 실행해야 하는 경우가 있다면, 위 그림에서 파란색으로 표시한 <code class="highlighter-rouge">Execute code using this interprete with root privileges via sudo</code> 옵션을 체크한다. (보안 상 문제가 없으면 하는 거 추천)</p>

<p>다음으로는 아래쪽에 있는, 원격 서버의 파일과 로컬 파일을 동기화시키는 항목이 나온다. 이 부분의 의미는,</p>
<ul>
  <li>PyCharm의 기능은
    <ul>
      <li>원격 서버를 ssh를 통해 vim 등의 편집기로 수정만 하는 방식이 아니라,</li>
      <li>로컬에 같은 파일을 복사한 채로 진행되며,</li>
    </ul>
  </li>
  <li>로컬 파일을 수정하면 자동으로 원격 서버의 파일도 동기화가 되며(옵션을 체크했을 경우)</li>
  <li>로컬에서 실행 명령을 내리면 로컬에서 실행되는 것이 아닌 원격 서버에서 실행이 된다.</li>
</ul>

<center><img src="/public/img/2019-02-07-PyCharm-usage/61.png" width="100%" /></center>

<p>이를 위해서는 <code class="highlighter-rouge">Sync folders</code> 옵션의 오른쪽에 있는 디렉토리 아이콘(위쪽 빨간 박스)을 클릭한다. 그리고 <code class="highlighter-rouge">Edit Sync Folders</code> 대화창이 뜨면 동기화를 시킬 노란 박스로 표시한 <code class="highlighter-rouge">Local Path</code>와 <code class="highlighter-rouge">Remote Path</code>를 잘 지정한다(아래쪽 빨간 박스를 누르면 수정 가능). 클라우드 드라이브 서비스처럼 알아서 동기화가 된다.</p>

<p>초록 박스로 표시한 <code class="highlighter-rouge">+</code> 버튼을 누르면 동기화할 Path를 추가 지정할 수 있다. 이는 같은 Interpreter를 사용하는 여러 프로젝트가 있을 때 사용하면 된다.</p>

<p>원격 서버에 이미 파일이 존재하는 경우, 위 그림에서 파란 박스로 표시한 부분을 체크 해제한다. 반대로 로컬에서 처음 시작하는 경우, 체크해도 좋다. 만약 서버에 파일이 있는데 로컬 파일을 원격으로 자동 업데이트하는 옵션을 체크하면 원격 서버의 파일이 지워진다는 경고창을 보게 된다.</p>

<p><code class="highlighter-rouge">OK</code>를 누른 뒤 <code class="highlighter-rouge">Finish</code> 버튼을 누르면 한번 더 비밀번호를 입력하는 창이 뜬다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/62.png" width="50%" /></center>

<p>그러면 Interpreter 목록에서 원격 Interpreter를 확인할 수 있다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/63.png" width="100%" /></center>

<p>&lt;/br&gt;</p>

<p>다음으로 <code class="highlighter-rouge">Settings &gt; Build, Execution, Deployment &gt; Deployment</code>으로 이동한다. 그러면 Deployment에 조금 전 추가한 정보가 들어가 있을 것이다. 만약 없으면 아래 그림처럼 새 SFTP 서버를 추가한다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/52.png" width="100%" /></center>

<p>그러면 서버 이름을 입력하는 대화창이 나온다. 입력해주자.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/53.png" width="80%" /></center>

<p>다음 그림을 보자.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/54.png" width="100%" /></center>

<ul>
  <li>Host에는 서버의 IP 주소(ex. 123.124.125.126),</li>
  <li>포트 번호는 원격 서버에서 허용한 번호,</li>
  <li>User name은 서버의 사용자 이름,</li>
  <li>인증 방식은 보통 비밀번호를 많이 쓸 테니 사용자 이름에 맞는 비밀번호를 입력해준다. 비밀번호는 저장해도 좋다.</li>
  <li>그리고 아래쪽 Test Connection을 누르면 연결이 정상적인지 확인한다. 안 된다면 잘못 입력했거나, 외부 접속 또는 포트 등이 차단되어 있을 가능성이 높다. 테스트를 해보면 아래와 같은 창이 뜨는데, Yes를 눌러준다.</li>
</ul>

<center><img src="/public/img/2019-02-07-PyCharm-usage/55.png" width="100%" /></center>

<ul>
  <li>정상적이면 연결이 성공했다는 메시지가 뜬다.</li>
</ul>

<center><img src="/public/img/2019-02-07-PyCharm-usage/56.png" width="50%" /></center>

<ul>
  <li>Root Path는 기본값으로 두어도 되고, 인증이 잘 되었다면 AutoDetect를 사용해도 된다. 특정 directory에서 시작하고 싶으면 오른쪽 디렉토리 아이콘을 눌러 직접 지정해준다.</li>
  <li>Web Server URL와 그 아래 고급 옵션은 필수는 아니다.</li>
</ul>

<p>그리고 Mappings 탭을 클릭하면 <code class="highlighter-rouge">Local Path</code>와 <code class="highlighter-rouge">Deployment Path</code>(Remote Path)를 mapping할 수 있는 탭이 나온다. 역시 디렉토리 아이콘을 눌러 경로를 지정해 준다. 이때 경로는 위에서 기억한 <code class="highlighter-rouge">Root path</code>에 더한 상대 경로임을 유의한다. 즉 mapping되는 Remote Path는 <code class="highlighter-rouge">Root path</code> + <code class="highlighter-rouge">Deployment Path</code>이다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/67.png" width="100%" /></center>

<p>이제 <code class="highlighter-rouge">Project: name &gt; Project Interpreter</code>에서 조금 전에 만든 Interpreter를 선택하고 설정을 마치면 파일 전송이 이루어진다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/64.png" width="100%" /></center>

<p>코드 수정을 하면 자동 업로드가 된다(옵션을 체크했다면). 또한, 실행을 시키면 원격 서버에서 실행되게 된다.</p>

<p><em>참고.</em> 원격 서버에서 실행을 하긴 하지만 linux 시스템에서 사용하는 bash 파일을 윈도우에서 실행시킬 수는 없다. 이 부분은 조금 아쉬운 부분이다.</p>

<p>로컬 -&gt; 원격 또는 원격 -&gt; 로컬 간 파일 전송을 수동/자동으로 할 수도 있다. <code class="highlighter-rouge">Tools &gt; Deployment</code>를 누른다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/65.png" width="100%" /></center>

<ul>
  <li><code class="highlighter-rouge">Upload to</code>를 눌러 서버를 선택하면 현재 로컬 프로젝트 파일들을 저장된 원격 서버에 업로드할 수 있다.</li>
  <li><code class="highlighter-rouge">Download from</code>을 눌러 서버를 선택하면 마찬가지로 원격 서버의 파일을 로컬에 내려받을 수 있다.</li>
  <li><code class="highlighter-rouge">Configuration</code>을 누르면 조금 전 보았던 <code class="highlighter-rouge">Mappings</code> 탭을 포함해 설정을 다시 할 수 있다.</li>
  <li><code class="highlighter-rouge">Automatic Upload</code>를 누르면 토글이 되며, 로컬 파일을 원격 서버에 자동으로 업데이트할지를 결정할 수 있다.</li>
</ul>

<h3 id="terminal에서-ssh-session으로-열기">Terminal에서 SSH session으로 열기</h3>

<p>메뉴 바에서 <code class="highlighter-rouge">Tools &gt; Start SSH session...</code>을 클릭하면 <code class="highlighter-rouge">Select host to connect</code> 창이 뜬다. 이때 아래쪽 목록에는 현재 프로젝트에 설정되어 있는 python environment들이 뜬다. SSH 연결을 추가하고 싶으면, <code class="highlighter-rouge">Edit credentials...</code>를 클릭한다.</p>

<center><img src="/public/img/2019-02-07-PyCharm-usage/68.png" width="100%" /></center>

<p>그러면 위 그림과 같이 <code class="highlighter-rouge">SSH Session</code> 대화창이 뜬다. 여기서 보통 ssh 연결할 때처럼 서버 주소, 사용자명, 비밀번호 등을 입력하고 <code class="highlighter-rouge">OK</code>를 누르면 Terminal 창에서 로컬 환경 대신 SSH 환경에서 열리게 된다. 파일 접속은 물론이고 실행까지 원격 ssh 서버 상에서 이루어지게 된다.</p>

<hr />

<h2 id="references">References</h2>

<p><a href="https://www.jetbrains.com/pycharm/">공식 홈페이지</a>에서 더 자세한 사용법을 찾아볼 수 있다.</p>

    </article>
    <div class="post-more">
      
      <a href="/PyCharm-usage/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/PyCharm-usage/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/Miniconda-usage/">
        Miniconda(Anaconda) 사용법
      </a>
    </h1>

    <span class="post-date">01 Feb 2019</span>
     |
    
    <a href="/blog/tags/#miniconda" class="post-tag">Miniconda</a>
    
    <a href="/blog/tags/#usage" class="post-tag">usage</a>
    
    

    <article>
      <p>Anaconda는 Continuum Analytics라는 곳에서 만든 파이썬 배포판으로 수백 개의 파이썬 패키지를 포함하는 환경을 구성한다. Anaconda로는 virtualenv와 같은 여러 개의 가상환경을 만들어 각각의 환경을 따로 관리할 수 있다.<br />
그 중 Miniconda는 이것저것 설치할 것이 많은 Anaconda에서 패키지를 다르게 설치할 여러 환경들을 관리한다는 최소한의 기능만 가진 부분만 포함하는 mini 버전이다. 따라서 이 글에서는 Miniconda를 설치하여 가상환경을 관리하는 법을 알아보겠다.</p>

<hr />

<h2 id="설치">설치</h2>

<script data-ad-client="ca-pub-9951774327887666" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<p><a href="https://www.anaconda.com/distribution/#download-section">Anaconda</a>를 설치하거나, <a href="https://conda.io/en/latest/miniconda.html">Miniconda</a>를 설치한다. 설치하고 싶을 운영체제와 버전에 맞는 것을 골라 설치한다. 설치 방법은 공식 홈페이지에 따로 설명되어 있다.</p>

<p><img src="/public/img/conda/2019-02-01-Miniconda-usage/01.PNG" alt="01_install" />
Not recommended라고 되어 있는 옵션이지만 체크하면 PATH에 등록하지 않아도 된다(이건 환경마다 조금 다르다).
<img src="/public/img/conda/2019-02-01-Miniconda-usage/02.PNG" alt="02_install" /></p>

<p>설치 후 다음 명령을 명령창(cmd / 터미널)에 입력해본다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conda</span> <span class="nb">list</span>
</code></pre></div></div>

<p>만약 다음과 같이 오류가 뜬다면 conda가 System PATH에 등록되지 않은 것이므로 등록을 해 준다.</p>

<p><img src="/public/img/conda/2019-02-01-Miniconda-usage/03.PNG" alt="03_install" />
<img src="/public/img/conda/2019-02-01-Miniconda-usage/04.PNG" alt="04_install" /></p>

<p>윈도우10, Miniconda3인 경우 <code class="highlighter-rouge">C:\ProgramData\Miniconda3\Scripts</code>를 PATH에 등록해 준다.</p>

<p>설치 패키지 목록은 다를 것이지만 다음과 같이 뜬다. <code class="highlighter-rouge">conda list</code>는 현재 환경(기본 환경의 이름은 base이다)에서 설치된 패키지 목록을 나타내는 명령이다.</p>

<p><img src="/public/img/conda/2019-02-01-Miniconda-usage/05.PNG" alt="05_conda_list" /></p>

<hr />

<h2 id="가상환경-목록-확인-생성-및-삭제">가상환경 목록 확인, 생성 및 삭제</h2>

<p>다음을 명령창에 입력한다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conda</span> <span class="n">env</span> <span class="nb">list</span>
<span class="c1"># 또는,
</span><span class="n">conda</span> <span class="n">info</span> <span class="o">--</span><span class="n">envs</span>
</code></pre></div></div>

<p>현재 활성화된 가상환경 옆에는 * 가 추가된다.</p>

<p><img src="/public/img/conda/2019-02-01-Miniconda-usage/06.PNG" alt="06_env_list" /></p>

<p>처음 설치했을 때는 기본값인 base 하나만 있을 것이다.</p>

<p>다음 명령을 통해 새 가상환경을 하나 생성한다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -n 옵션은 --name과 같은 것으로, 가상환경 이름을 myenv로 지정한다.
</span><span class="n">conda</span> <span class="n">create</span> <span class="o">-</span><span class="n">n</span> <span class="n">myenv</span>
<span class="c1"># python=3.6 옵션은 가상환경 생성 시 파이썬 버전을 지정한다.
# 지정하지 않으면 conda에 기본 포함된 파이썬 버전으로 생성된다.
</span><span class="n">conda</span> <span class="n">create</span> <span class="o">-</span><span class="n">n</span> <span class="n">condatorch</span> <span class="n">python</span><span class="o">=</span><span class="mf">3.6</span>

<span class="c1"># 특정 패키지 버전을 지정하면서, 그리고 패키지를 설치하면서 생성하는 것도 가능하다.
</span><span class="n">conda</span> <span class="n">create</span> <span class="o">-</span><span class="n">n</span> <span class="n">myenv</span> <span class="n">python</span><span class="o">=</span><span class="mf">3.4</span> <span class="n">scipy</span><span class="o">=</span><span class="mf">0.15</span><span class="p">.</span><span class="mi">0</span> <span class="n">astroid</span> <span class="n">babel</span>

<span class="c1"># 가상환경 생성 시 이것저것 깔리는 것이 싫다면 다음 옵션을 주면 된다.
</span><span class="n">conda</span> <span class="n">create</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">default</span><span class="o">-</span><span class="n">packages</span> <span class="o">-</span><span class="n">n</span> <span class="n">myenv</span> <span class="n">python</span>

<span class="c1"># 새 가상환경을 만들 때 특정 가상환경 안에 설치된 패키지 전부를 설치하면서 생성할 수 있다.
# base 가상환경에 있는 패키지를 전부 설치하면서 생성한다면, 
</span><span class="n">conda</span> <span class="n">create</span> <span class="o">-</span><span class="n">n</span> <span class="n">myenv</span> <span class="o">--</span><span class="n">clone</span> <span class="n">base</span>

<span class="c1"># environment.yml 파일이 있다면 다음과 같이 생성할 수 있다.
# 생성 방법은 이후에 설명한다.
</span><span class="n">conda</span> <span class="n">env</span> <span class="n">create</span> <span class="o">-</span><span class="n">f</span> <span class="n">environment</span><span class="p">.</span><span class="n">yml</span>
</code></pre></div></div>

<p>계속 진행하겠냐는 물음이 보이면 <code class="highlighter-rouge">y</code>를 입력한다.</p>

<p><img src="/public/img/conda/2019-02-01-Miniconda-usage/07.PNG" alt="07_env_create" /></p>

<p>다시 <code class="highlighter-rouge">conda env list</code>로 목록을 확인해보면 지정한 이름으로 가상환경이 생성되었음을 확인할 수 있다.</p>

<p><img src="/public/img/conda/2019-02-01-Miniconda-usage/08.PNG" alt="08_env_create" /></p>

<p>위 그림에서 activate condatorch, deactivate 등의 명령이 쓰여 있는 것을 확인할 수 있는데, 이는 특정 가상환경을 활성화 또는 비활성화할때 사용하는 명령이다(가상환경이 무엇에 쓰는 것인지 알면 무슨 말뜻인지 알 수 있을 것이다). 이는 다음 절에서 설명한다.</p>

<p>가상환경 삭제는 다음 명령을 통해 수행할 수 있다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 생성할 때와는 다르게 env를 앞에 적어주어야 한다.
# 생성 시에는 env를 앞에 적으면 실행이 되지 않는다.
# remove 앞에 env를 써 주지 않으면 가상환경 삭제가 아닌 패키지 삭제가 이루어진다.
# conda env remove -n &lt;environment_name&gt;
</span><span class="n">conda</span> <span class="n">env</span> <span class="n">remove</span> <span class="o">-</span><span class="n">n</span> <span class="n">condatorch</span>
<span class="c1"># 다음도 가능하다.
</span><span class="n">conda</span> <span class="n">remove</span> <span class="o">--</span><span class="n">name</span> <span class="n">myenv</span> <span class="o">--</span><span class="nb">all</span>
</code></pre></div></div>

<p><img src="/public/img/conda/2019-02-01-Miniconda-usage/09.PNG" alt="09_env_remove" /></p>

<h3 id="requirementstxt로-가상환경-생성하기">Requirements.txt로 가상환경 생성하기</h3>

<p>아래 명령들은 가독성을 위해 두 줄로 펼쳐 놓았다.</p>

<p>Windows 환경이라면 명령창에 다음과 같이 쓰는 것이 가능하다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FOR /F "delims=~" %f in (requirements.txt) 
DO conda install --yes "%f" || pip install "%f"
</code></pre></div></div>

<p>Unix 환경이라면 다음과 같이 쓸 수 있다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while read requirement; do conda install --yes $requirement; 
done &lt; requirements.txt 2&gt;error.log
</code></pre></div></div>
<p>conda로는 설치가 안 되고 pip으로는 설치가 되는 패키지가 있다면 다음과 같이 쓸 수 있다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while read requirement; do conda install --yes $requirement 
|| pip install $requirement; done &lt; requirements.txt 2&gt;error.log
</code></pre></div></div>

<p>다음을 참조하였다: <a href="https://gist.github.com/luiscape/19d2d73a8c7b59411a2fb73a697f5ed4">github 글</a>, <a href="https://stackoverflow.com/questions/35802939/install-only-available-packages-using-conda-install-yes-file-requirements-t">stackoverflow 글</a></p>

<hr />

<h2 id="가상환경-활성화-비활성화">가상환경 활성화, 비활성화</h2>

<p>가상환경 활성화는 위에서도 설명했듯 다음과 같이 쓰면 된다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">activate</span> <span class="o">&lt;</span><span class="n">environment_name</span><span class="o">&gt;</span>
<span class="n">activate</span> <span class="n">condatorch</span>
</code></pre></div></div>
<p>Unix 등의 환경에서는 <code class="highlighter-rouge">activate</code>가 아닌 <code class="highlighter-rouge">source activate</code>를 써야 한다.</p>

<p>그러면 명령창의 맨 앞에 (condatorch)와 같이 활성화된 가상환경 이름이 뜬다.</p>

<p>비활성화는 다음 명령으로 할 수 있다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">deactivate</span>
<span class="c1"># 설치한 버전에 따라 deactivate는 deprecated되었다는 경고를 볼 수도 있다. 이 경우 conda deactivate이다.
</span></code></pre></div></div>

<p><img src="/public/img/conda/2019-02-01-Miniconda-usage/10.PNG" alt="10_activate" /></p>

<p>위 그림이 잘 이해가 되지 않는다면, <code class="highlighter-rouge">activate</code>를 여러 번 쓰지 않을 것을 권장한다.</p>

<hr />

<h2 id="가상환경-안에-패키지-설치">가상환경 안에 패키지 설치</h2>

<p>버전에 따라 조금씩 다른 경우도 있으나, 최신 버전(2019-02-01 기준)의 Miniconda3에서는 pip, whl, conda를 통한 설치 모두 현재 활성화된(없다면 base 또는 컴퓨터에 깔려 있는 다른 버전의 파이썬에) 가상환경에만 설치된다. 따라서 각 환경 간 거의 완전한 분리가 가능하다.</p>

<p>패키지 설치는 다음과 같다. <code class="highlighter-rouge">pip</code>과 거의 비슷하다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conda</span> <span class="n">install</span> <span class="n">seaborn</span>
<span class="c1"># 여러 개를 동시에 설치할 경우 comma 없이 그냥 나열한다.
</span><span class="n">conda</span> <span class="n">install</span> <span class="n">numpy</span> <span class="n">pandas</span>
</code></pre></div></div>

<p>설치된 패키지 목록을 보고 싶으면 다음을 입력한다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conda</span> <span class="nb">list</span>
</code></pre></div></div>

<p>참고로 conda 환경에서도 pip 등을 통한 설치가 가능하다.</p>

<h3 id="environmentyml-파일-생성-및-가상환경-생성">environment.yml 파일 생성 및 가상환경 생성</h3>

<p>설치된 패키지 목록을 <code class="highlighter-rouge">.yml</code> 파일로 저장하는 명령이다.<br />
<code class="highlighter-rouge">pip freeze &gt; requirements.txt</code>와 같은 역할이다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conda</span> <span class="n">env</span> <span class="n">export</span> <span class="o">&gt;</span> <span class="n">environment</span><span class="p">.</span><span class="n">yml</span>
</code></pre></div></div>

<p>만들어진 파일은 다음과 비슷하게 생겼다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name: condatorch
channels:
  - pytorch
  - defaults
dependencies:
  - blas=1.0=mkl
  - certifi=2018.11.29=py36_0
  ...
  - zstd=1.3.7=h508b16e_0
  - pip:
    - cycler==0.10.0
    ...
    - six==1.12.0
prefix: C:\ProgramData\Miniconda3\envs\condatorch
</code></pre></div></div>

<p>만들어진 파일로 가상환경을 생성하는 방법은 위에서도 설명했지만 다음과 같다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 이 경우에는 env를 앞에 써 주어야 한다.
# -f는 --file을 의미한다.
</span><span class="n">conda</span> <span class="n">env</span> <span class="n">create</span> <span class="o">-</span><span class="n">f</span> <span class="n">environment</span><span class="p">.</span><span class="n">yml</span> <span class="o">-</span><span class="n">n</span> <span class="n">myenv</span>
</code></pre></div></div>

<h3 id="패키지-업데이트">패키지 업데이트</h3>

<p>특정 환경 안의 특정 패키지를 업데이트하려면 다음과 같이 하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conda</span> <span class="n">update</span> <span class="o">-</span><span class="n">n</span> <span class="o">&lt;</span><span class="n">environment_name</span><span class="o">&gt;</span> <span class="n">spacy</span>
</code></pre></div></div>

<p>특정 환경 안의 모든 패키지를 업데이트하려면 다음과 같이 하면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">conda</span> <span class="n">update</span> <span class="o">-</span><span class="n">n</span> <span class="o">&lt;</span><span class="n">environment_name</span><span class="o">&gt;</span> <span class="o">--</span><span class="nb">all</span>
<span class="c1"># 현재 환경 업데이트
</span><span class="n">conda</span> <span class="n">update</span> <span class="o">--</span><span class="nb">all</span>
</code></pre></div></div>

<hr />

<h2 id="conda-버전-확인-및-update">Conda 버전 확인 및 update</h2>

<p>명령창에서 Conda의 버전을 확인하는 방법은 다음과 같다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda -V
conda --version
</code></pre></div></div>

<p>Conda 자체를 업데이트하는 방법은 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda update conda
conda update anaconda
</code></pre></div></div>

<hr />

<h2 id="references">References</h2>

<p><a href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html">공식 홈페이지</a>에서 더 자세한 사용법을 찾아볼 수 있다.</p>

    </article>
    <div class="post-more">
      
      <a href="/Miniconda-usage/#disqus_thread"> <i class="fa fa-comments" aria-hidden="true"></i>Comment</a>&nbsp;
      
      <a href="/Miniconda-usage/"><i class="fa fa-plus-circle" aria-hidden="true"></i>Read more</a>
    </div>
  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/blog/page9">Older</a>
  
  
    
      <a class="pagination-item newer" href="/blog/page7">Newer</a>
    
  
</div>


  </div>
</div>

<label for="sidebar-checkbox" class="sidebar-toggle"></label>

<script>
  (function (document) {
    let toggle = document.querySelector('.sidebar-toggle');
    let sidebar = document.querySelector('#sidebar');
    let checkbox = document.querySelector('#sidebar-checkbox');

    document.addEventListener('click', function (e) {
      let target = e.target;

      if (target === toggle) {
        checkbox.checked = !checkbox.checked;
        e.preventDefault();
      } else if (checkbox.checked && !sidebar.contains(target)) {
        /* click outside the sidebar when sidebar is open */
        checkbox.checked = false;
      }
    }, false);
  })(document);
</script>

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    };
    i[r].l = 1 * new Date();
    a = s.createElement(o);
    m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

  ga('create', 'UA-00000000-1', 'auto');
  ga('send', 'pageview');
</script>


<!-- Naver Analytics -->	
<script type="text/javascript" src="//wcs.naver.net/wcslog.js"></script>
<script type="text/javascript">
  if(!wcs_add) var wcs_add = {};
    wcs_add["wa"] = "18cbce78e94161";
  wcs_do();
</script>

</body>

<script id="dsq-count-scr" src="//greeksharifa-github-io.disqus.com/count.js" async></script>

</html>
