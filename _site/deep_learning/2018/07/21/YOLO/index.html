<!DOCTYPE html>
<html lang="en-us">
<head>
  <head>
  <!-- Description of Blog -->
  <meta name="description" content="Python, Machine & Deep Learning">
  <link rel="canonical" href="https://greeksharifa.github.io/">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Python, Machine & Deep Learning">
  <meta property="og:description" content="Python, Machine Learning & Deep Learning 설명서">
  <meta property="og:image" content="https://greeksharifa.github.io/public/img/icon-144x144.png">
  <meta property="og:url" content="https://greeksharifa.github.io/">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Python, Machine & Deep Learning">
  <meta name="twitter:description" content="Python, Machine Learning & Deep Learning 설명서">
  <meta name="twitter:image" content="https://greeksharifa.github.io/public/img/icon-144x144.png">
  <meta name="twitter:domain" content="https://greeksharifa.github.io/">

  <!-- link -->
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  
  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      YOLO
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/main.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="icon-144x144" sizes="144x144" href="/public/img/icon-144x144.png">
  <link rel="shortcut icon" href="/public/img/icon_32x32.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  
  <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG"> </script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });
  </script>
  

  <!-- Ads -->
  <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
  </script>
</head>

  <!-- for Google AdSense-->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-9951774327887666",
    enable_page_level_ads: true
  });
</script>

  <style>blockquote {
    font-size: 1em;
    line-height: 1.4
  }</style>
  <link href='http://fonts.googleapis.com/css?family=Gill+Sans' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Consolas' rel='stylesheet' type='text/css'>
</head>
<body>

<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <div class="sidebar-personal-info">
      <div class="sidebar-personal-info-section">
        <a href="http://gravatar.com/3c2986ad7ac1f2230ea3596f44563328">
          <img src="/public/img/maple_tree.jpg" title="Cover Photo" alt="Maple tree" />
        </a>
      </div>
      <div class="sidebar-personal-info-section">
        <p><strong>Developer and Analyst</strong>, YW & YY.</p>
      </div>
      
      
      
      <div class="sidebar-personal-info-section">
        <p> Follow me:
        
        
        
        <a href="https://github.com/greeksharifa">
          <i class="fa fa-github" aria-hidden="true"></i>
        </a>
        
        |
        
        
        
        <a href="mailto:greeksharifa@gmail.com">
          <i class="fa fa-envelope" aria-hidden="true"></i>
        </a>
        
        
        
        </p>
      </div>
      
    </div>
  </div>

  <nav class="sidebar-nav">
    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/">
          Home
        </a>

        
      </span>

    
      
      
      

      

      <span class="foldable">
        <a class="sidebar-nav-item " href="/blog/">
          Blog
        </a>

        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/categories/">
                Categories
              </a>
          
        
          
            
            
            
              <a class="sidebar-nav-item sidebar-nav-item-sub " href="/blog/tags/">
                Tags
              </a>
          
        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="/about/">
          About
        </a>

        
      </span>

    
      
      
      

      

      <span class="">
        <a class="sidebar-nav-item " href="http://greeksharifa.github.io/">
          Github Project
        </a>

        
      </span>

    

  </nav>

  <div class="sidebar-item">
    <p>
    &copy; 2020 YW & YY. This work is liscensed under <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a>.
    </p>
  </div>

  <div class="sidebar-item">
    <p>
    Powered by <a href="http://jekyllrb.com">jekyll</a> and <a href="http://greeksharifa.github.io">YW & YY</a>
    </p>
  </div>
</div>


<!-- Wrap is the content to shift when toggling the sidebar. We wrap the
     content to avoid any CSS collisions with our real content. -->
<div class="wrap">
  <div class="masthead">
    <div class="container">
      <h3 class="masthead-title" align="center">
        <a href="/" title="Home" title="YW & YY">
          <img class="masthead-logo" src="/public/img/logo.png"/>
        </a>
        <small>YW & YY's Python, Machine & Deep Learning</small>
        <!-- HTML elements for search -->
        <a href="/search/" id="search_icon">
          <img src="/public/img/search.png" width="25" height="25"
               align="right" style="margin-top:5px; margin-bottom:0;"
               onmouseover="this.style.opacity=0.7" onmouseout="this.style.opacity=0.5"
               alt="search">
        </a>
      </h3>
    </div>
  </div>

  <div class="container content">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 수직형 디스플레이 광고1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9951774327887666"
     data-ad-slot="7237421728"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<div class="post">
  <h1 class="post-title">YOLO</h1>
  <span class="post-date">21 Jul 2018</span>
   |
  
  <a href="/blog/tags/#keras" class="post-tag">Keras</a>
  
  <a href="/blog/tags/#detection" class="post-tag">Detection</a>
  
  <a href="/blog/tags/#cnn" class="post-tag">CNN</a>
  
  
  <article>
    <p><strong>목차</strong></p>
    <ul>
  <li><a href="#yolo-you-only-look-once">YOLO: You Only Look Once</a>
    <ul>
      <li><a href="#bounding-boxes-and-endocing-vector">Bounding Boxes and Endocing Vector</a></li>
      <li><a href="#filtering-with-a-threshold-on-class-scores">Filtering with a threshold on class scores</a></li>
      <li><a href="#non-max-suppression">Non-max Suppression</a></li>
      <li><a href="#wrapping-up-the-filtering">Wrapping up the filtering</a></li>
      <li><a href="#test">Test</a></li>
      <li><a href="#check-the-result">Check the result</a></li>
    </ul>
  </li>
</ul>

    <h2 id="yolo-you-only-look-once">YOLO: You Only Look Once</h2>
<blockquote>
  <p>본 포스트는 아래의 논문, 코드와
Joseph Redmon, Santosh Divvala, Ross Girshick, Ali Farhadi - You Only Look Once: Unified, Real-Time Object Detection (2015)
Joseph Redmon, Ali Farhadi - YOLO9000: Better, Faster, Stronger (2016)
Allan Zelener - YAD2K: Yet Another Darknet 2 Keras
Andrew Ng의 Convolutional Neural Networks 강의의 내용을 토대로 정리한 것임을 밝힌다.</p>
</blockquote>

<p><strong>YOLO</strong> 알고리즘은 Sliding Window를 사용하여 이미지의 픽셀을 Stride 단위로 하나하나<br />
살펴보는 것이 아니라 이미지를 Grid로 나누어 각각의 Grid Cell에 대해<br />
Label(그 셀의 정보)를 부여함으로써 한 번에 이미지를 스캔한다.<br />
이 때문에 YOLO 알고리즘은 빠른 속도라는 강점을 갖고 있다.</p>

<p>알고리즘에 대해 세세하게 설명하기 전에 코딩을 위한 Setting부터 진행하도록 하겠다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">from</span> <span class="nn">keras</span> <span class="kn">import</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">K</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">load_model</span><span class="p">,</span> <span class="n">Model</span>
<span class="kn">from</span> <span class="nn">yad2k.utils.yolo_utils</span> <span class="kn">import</span> <span class="n">read_classes</span><span class="p">,</span> <span class="n">read_anchors</span><span class="p">,</span> <span class="n">generate_colors</span><span class="p">,</span> <span class="n">preprocess_image</span><span class="p">,</span> <span class="n">draw_boxes</span><span class="p">,</span> <span class="n">scale_boxes</span>
<span class="kn">from</span> <span class="nn">yad2k.models.keras_yolo</span> <span class="kn">import</span> <span class="n">yolo_head</span><span class="p">,</span> <span class="n">yolo_boxes_to_corners</span><span class="p">,</span> <span class="n">preprocess_true_boxes</span><span class="p">,</span> <span class="n">yolo_loss</span><span class="p">,</span> <span class="n">yolo_body</span>
</code></pre></div></div>

<p>여기서 제일 아래 두 줄에 있는 yad2k 모듈은 터미널에서 바로 다운로드를 받을 수 없다.<br />
아래 깃헙들을 통해서 다운을 받도록 하자.
<a href="https://github.com/allanzelener/YAD2K/blob/master/yad2k/models/keras_yolo.py">yad2k-첫 번째</a>,
<a href="https://github.com/tejaslodaya/car-detection-yolo">yad2k-두 번째</a></p>

<p>첫 번째 깃헙에서는 아래에 보이는 것처럼 font와 yad2k폴더를 저장하면 된다.</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo01.PNG" width="90%" /></center>

<p>두 번째 깃헙에서는 아래에 보이는 것처럼 yolo_uilts.py파일만 저장하여<br />
위 코드에서 알 수 있듯이 yad2k.utils안에 넣어두어 편리하게 사용할 수 있다.</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo02.PNG" width="90%" /></center>

<p>하지만 이 사용자 패키지를 그대로 Lib/site-packages에 집어넣는다고 모든 게 해결되지는 않는다.<br />
폰트 설정 작업을 다시 해주어야 한다.</p>

<p>첫 번째 깃헙에서 다운로드를 받은 font폴더를 열어보면 아래의 파일을 확인할 수 있다.</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo03.PNG" width="50%" /></center>
<p>물론 다른 otf폰트를 사용해서 문제가 없을 것이다만, 나는 이 패키지를 만드신 분의 폰트를 그대로 따랐다.</p>

<p>여기서 FiraMono-Medium.otf파일을 글꼴 설치해주자. 그러고 나서는 모듈 내 함수에서 2가지만  수정해주면 된다. 모듈 내에 있는 draw_boxes.py와 yolo_utils.py를 열어보자</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo04.PNG" width="80%" /></center>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo05.PNG" width="80%" /></center>
<p>모두 draw_boxes란 함수를 포함하고 있는데, 여기서 <strong>font=” “</strong> 부분에 본인이 폰트를 저장한 경로로<br />
수정을 해주어야만 한다.</p>

<p><em>자 그럼 모듈 준비는 끝났다. 본격적으로 YOLO에 대해 탐구해볼까?</em></p>

<h3 id="bounding-boxes-and-endocing-vector">Bounding Boxes and Endocing Vector</h3>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo06.PNG" width="100%" /></center>
<p>YOLO 알고리즘을 사용하기 전에는 본인이 detect하고 싶은 물체를 구분할 수 있는 pre-trained된 CNN기반 모델이 필요하다. 즉, 내가 이미지에서 1개 이상의 차/보행자/오토바이를 구분하고 싶다면,<br />
pre-trained된 모델은 이미지가 차인지 보행자인지 오토바이인지 하나의 Class로 구분할 수 있는 모델이어야 한다는 것이다.</p>

<p><strong>Size가 608 X 608</strong>인 이미지 셋을 이용한다고 해보자.<br />
그리고 우리는 여러 object를 detect하기 위해 5개 종류의 anchor box를 사용한다고 해보자.<br />
그렇다면 처음 Input은 (m, 608, 608, 3)의 shape을 가질 것이고(m개의 이미지),<br />
이 Input은 Deep CNN을 거쳐 (m, 19, 19, 5, 85)의 shape으로 인코딩된다.</p>

<p>여기서 <strong>19, 19</strong>는 Grid의 Size를 말한다.<br />
즉 아래의 그림처럼 19*19개의 각각의 Grid Cell이 어떤 object를 detect하고 있는지<br />
각각의 sign을 남긴다는 뜻이다.</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo07.PNG" width="80%" /></center>

<p>마지막 85의 길이를 가진 벡터는 아래와 같이 생겼다.</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo08.PNG" width="80%" /></center>
<p>이러한 벡터가 각 anchor box별로 하나 씩 있기 때문에 shape의 마지막 부분이 5, 85)가 되는 것이다.</p>

<p>(m, 19, 19, 5, 85)는 필요 이상으로 고차원이기 때문에 계산의 편리함을 위해<br />
(m, 19, 19, 425)로 Unroll해주도록 한다.<br />
다시 정리하자면, 위 matrix의 의미는, <strong>19X19</strong>개 각각의 Cell이 자기자신이 어떤 Label인지에<br />
대한 정보를 425개의 숫자로 표현하고 있다는 것이다.</p>

<p>마지막 425의 길이를 가진 벡터를 분리하여 다음과 같이 Score를 계산해주도록 한다.
아래 코드에선 이를 <strong>box_scores</strong>라고 명명할 것이다.</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo09.PNG" width="80%" /></center>

<p>이제 위에서 구한 box_scores를 바탕으로,<br />
각 Grid Cell은 각각의 box(여기서는 5개의 anchor box가 있다.)와<br />
각각의 class(여기서는 80개의 classes가 있다.)에 대해 maximum probability를 찾고<br />
이를 토대로 자신의 정체성을 확립하게 된다. (나는 어떤 object이다라고 결정!)</p>

<p>Cell의 중심에 앵커의 중심을 놓고 bbox를 그리면, 아래와 같은 그림을 얻을 수 있을 것이다.</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo10.PNG" width="30%" /></center>
<p>Box가 너무 많기 때문에 일단 Score면에서 일정 수준 미달인 Box들을 제거해준다.<br />
Score가 낮다는 것은 Cell이 실제로 이 object를 detect했을 확률이 낮다는 것이다.<br />
그러고 나서 최고 Score를 받은 Box와 너무 많이 겹치는 Box들을 제거해준다.
(IOU가 높은 박스 제거) 이것이 바로 Non-max Suppression 과정이다.</p>

<p>자 이제 본격적으로 코드로 구현해보자.</p>

<h3 id="filtering-with-a-threshold-on-class-scores">Filtering with a threshold on class scores</h3>
<p>앞서 언급한 과정 중 첫 번째 단계를 실현하는 과정이다.<br />
아래 코드에 등장하는 객체에 대해 설명하자면,<br />
<strong>box_confidence</strong>: (19<em>19, 5, 1) - $P_c$를 담고 있다. (타겟 Object가 존재할 확률)<br />
<strong>boxes</strong>: (19</em>19, 5, 4) - Bounding Box 좌표 4개를 담고 있다.<br />
<strong>box_class_probs</strong>: (19*19, 5, 80) - Class 80개에 대한 확률 값을 담고 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">yolo_filter_boxes</span><span class="p">(</span><span class="n">box_confidence</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">box_class_probs</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.6</span><span class="p">):</span>
    <span class="s">"""
    threshold -- real value, if [highest class probability score &lt; threshold],
    then get rid of the corresponding box

    Returns:
    몇 개의 박스를 선택하는지 모르기 때문에 None을 쓴다. 
    이 개수는 설정된 threshold의 값에 달려 있다.
    scores -- tensor of shape (None,), containing the class probability score for selected boxes
    boxes -- tensor of shape (None, 4), containing (b_x, b_y, b_h, b_w)
    classes -- tensor of shape (None,), containing the index of the class
    detected by the selected boxes
    """</span>

    <span class="c1"># Step 1: Compute box scores
</span>    <span class="n">box_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">box_confidence</span><span class="p">,</span> <span class="n">box_class_probs</span><span class="p">)</span>

    <span class="c1"># Step 2: box_scores에서 제일 큰 스코어의 위치와 값을 찾는다.
</span>    <span class="n">box_classes</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">box_scores</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">box_class_scores</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="nb">max</span><span class="p">(</span><span class="n">box_scores</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Step 3: 아래 필터링 마스크는 부울렌 tensor로 threshold보다 큰 score를 가지는
</span>    <span class="c1"># box_class를 판별한다.
</span>    <span class="n">filtering_mask</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">box_class_scores</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

    <span class="c1"># Step 4: Apply the mask to scores, boxes and classes
</span>    <span class="n">scores</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">box_class_scores</span><span class="p">,</span> <span class="n">filtering_mask</span><span class="p">)</span>
    <span class="n">boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">filtering_mask</span><span class="p">)</span>
    <span class="n">classes</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">box_classes</span><span class="p">,</span> <span class="n">filtering_mask</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">scores</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span>
</code></pre></div></div>

<p>위에서 tf.boolean_mask함수는 아래와 같은 형식을 갖는다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">'boolean_mask'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div></div>
<p>해당 텐서에 True, False로 구성된 mask를 씌우면 True와 연결된 값만 남고 나머지는 지워진다.<br />
예를 들어</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tensor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">])</span>
<span class="n">boolean_mask</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
</code></pre></div></div>
<p>의 결과는 [0, 2]이다.</p>

<h3 id="non-max-suppression">Non-max Suppression</h3>
<p>이제 필요 없는 Box들을 제거해보자.<br />
아래 함수에서 사용할 메서드 중 tf.image.non_max_suppression에 대해 설명하자면,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tf</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">non_max_suppression</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">max_output_size</span><span class="p">,</span>
    <span class="n">iou_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">score_threshold</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s">'-inf'</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div></div>
<p>아래와 같은 arguements를 가진다.<br />
1) <strong>boxes</strong>: A 2-D float Tensor of shape [num_boxes, 4].<br />
2) <strong>scores</strong>: A 1-D float Tensor of shape [num_boxes] representing a single score corresponding to each box.<br />
3) <strong>max_output_size</strong>: NMS에 의해 선택될 box의 최대 개수 = num_boxes<br />
4) <strong>iou_threshold</strong></p>

<p>반환하는 객체는<br />
<strong>Selected_indices</strong>: A 1-D integer Tensor of shape [M] representing the selected indices from the boxes tensor, where M &lt;= max_output_size. 사실상 shape은 (M, 1)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">yolo_non_max_suppression</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">max_boxes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">iou_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="s">"""Applies NMS to set of boxes
    scores -- tensor of shape (None,), output of yolo_filter_boxes()
    boxes -- tensor of shape (None, 4), output of yolo_filter_boxes()
    that have been scaled to the image size (see later)
    classes -- tensor of shape (None,), output of yolo_filter_boxes()
    max_boxes -- integer, maximum number of predicted boxes you'd like
    iou_threshold -- real value, "intersection over union" threshold used for NMS

    Returns:
    scores -- tensor of shape (, None), predicted score for each box
    boxes -- tensor of shape (4, None), predicted box coordinates
    classes -- tensor of shape (, None), predicted class for each box

    Note: 이 함수는 scores, boxes, classes의 shape을 편의를 위해 transpose 시킬 것이다.
    """</span>
    <span class="c1"># 내가 예측하고 싶은 박스 최대치
</span>    <span class="n">max_boxes_tensor</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">variable</span><span class="p">(</span><span class="n">max_boxes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">'int32'</span><span class="p">)</span>

    <span class="c1"># initialize variable max_boxes_tensor
</span>    <span class="n">K</span><span class="o">.</span><span class="n">get_session</span><span class="p">(</span> <span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">variables_initializer</span><span class="p">([</span><span class="n">max_boxes_tensor</span><span class="p">]))</span>

    <span class="c1"># get the list of indices corresponding to boxes you keep
</span>    <span class="n">nms_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">non_max_suppression</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">max_boxes_tensor</span><span class="p">,</span> 
    <span class="n">iou_threshold</span><span class="o">=</span><span class="n">iou_threshold</span><span class="p">)</span>

    <span class="c1"># Use K.gather() to select only nms_indices from scores, boxes and classes
</span>    <span class="n">scores</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">nms_indices</span><span class="p">)</span>
    <span class="n">boxes</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">nms_indices</span><span class="p">)</span>
    <span class="n">classes</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">classes</span><span class="p">,</span> <span class="n">nms_indices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">scores</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span>
</code></pre></div></div>
<p>첫 줄부터 설명하면
내가 만약 최대 10개의 Box를 선택하고 싶다면, arguement에서 max_boxes=10을 설정하고, 이 숫자를 tensor로 만든 것이 max_boxes_tensor이다.<br />
다음 줄에서 위 텐서를 집어넣고 세션을 실행시킨다.<br />
tf.image.non_max_suppression을 통해 nms_indices를 얻게 되는데 이는 선택할 Box의 indices를 의미한다.</p>

<p>K.gather에 대해 설명하자면,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">validate_indices</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>
<p>여기서 <strong>params</strong>는 최소 axis+1의 rank를 갖는 텐서이다.<br />
<strong>indices</strong>는 [0, params.shape[axis]) 범위 사이에 있는 텐서이다.</p>

<p>이 함수는 아래와 같이 indices에 따라 결과 값을 직관적으로 반환한다.</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo11.PNG" width="30%" /></center>

<p>이제 return되는 scores, boxes, classes에는 NMS를 거쳐 축소된 (max_boxes 이하로 줄어든)<br />
값이 담겨 있다.</p>

<h3 id="wrapping-up-the-filtering">Wrapping up the filtering</h3>
<p>위에서 정의한 두 함수를 바탕으로 종합 함수를 만들어보자.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">yolo_eval</span><span class="p">(</span><span class="n">yolo_outputs</span><span class="p">,</span> <span class="n">image_shape</span><span class="o">=</span><span class="p">(</span><span class="mf">720.</span><span class="p">,</span> <span class="mf">1280.</span><span class="p">),</span> <span class="n">max_boxes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> 
<span class="n">score_threshold</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">iou_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="s">"""
    Converts the output of YOLO encoding (a lot of boxes) to your predicted boxes along 
    with their scores, box coordinates and classes.

    Arguments:
    yolo_outputs -- output of the encoding model (for image_shape of (608, 608, 3)),
    contains 4 tensors:
                    box_confidence: tensor of shape (None, 19, 19, 5, 1)
                    box_xy: tensor of shape (None, 19, 19, 5, 2)
                    box_wh: tensor of shape (None, 19, 19, 5, 2)
                    box_class_probs: tensor of shape (None, 19, 19, 5, 80)
    image_shape -- Input shape을 담은 (2,) 텐서: 여기선 (608., 608.)이고 float32여야 함
    max_boxes -- integer, maximum number of predicted boxes you'd like
    score_threshold -- highest class probability score &lt; threshold이면, 그 Box 제거
    iou_threshold -- IOU threshold used for NMS filtering

    Returns:
    scores -- tensor of shape (None, ), predicted score for each box
    boxes -- tensor of shape (None, 4), predicted box coordinates
    classes -- tensor of shape (None,), predicted class for each box
    """</span>

    <span class="c1"># Retrieve outputs of the YOLO model
</span>    <span class="n">box_xy</span><span class="p">,</span> <span class="n">box_wh</span><span class="p">,</span> <span class="n">box_confidence</span><span class="p">,</span> <span class="n">box_class_probs</span> <span class="o">=</span> <span class="n">yolo_outputs</span>

    <span class="c1"># Convert boxes to be ready for filtering functions
</span>    <span class="n">boxes</span> <span class="o">=</span> <span class="n">yolo_boxes_to_corners</span><span class="p">(</span><span class="n">box_xy</span><span class="p">,</span> <span class="n">box_wh</span><span class="p">)</span>

    <span class="n">scores</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span> <span class="o">=</span> <span class="n">yolo_filter_boxes</span><span class="p">(</span><span class="n">box_confidence</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">box_class_probs</span><span class="p">,</span> 
    <span class="n">threshold</span><span class="o">=</span><span class="n">score_threshold</span><span class="p">)</span>

    <span class="c1"># Scale boxes back to original image shape.
</span>    <span class="n">boxes</span> <span class="o">=</span> <span class="n">scale_boxes</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">)</span>

    <span class="n">scores</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span> <span class="o">=</span> <span class="n">yolo_non_max_suppression</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> 
    <span class="n">max_boxes</span><span class="o">=</span><span class="n">max_boxes</span><span class="p">,</span> <span class="n">iou_threshold</span><span class="o">=</span><span class="n">iou_threshold</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">scores</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span>
</code></pre></div></div>
<p>두 번째 줄에 등장한 yolo_boxes_to_corners는 yad2모듈의 사용자 함수로,<br />
height, width, x_center, y_center로 표기했던 좌표를 편의를 위해 코너 좌표로 바꿔준다.</p>

<p>위에서 정의한 yolo_filter_boxes함수를 통해 수준 미달인 Box들을 제거해주고,<br />
다음 단계를 위해 yad2k의 scale_boxes 메서드를 통해 scaling을 해준다.<br />
다음 NMS를 적용하는 yolo_non_max_suppression함수를 통해 겹치는 Box들을 제거해준다.</p>

<h3 id="test">Test</h3>
<p>이제 실제 이미지에 적용해보자.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yolo_model</span> <span class="o">=</span> <span class="n">load_model</span><span class="p">(</span><span class="s">'C:/Users/YY/Documents/Winter Data/NN/Model/yolo.h5'</span><span class="p">)</span>
<span class="n">yolo_model</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s">'sgd'</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s">'categorical_crossentropy'</span><span class="p">)</span>
<span class="c1"># yolo_model.count_params()
# yolo_model.summary()
</span>
<span class="n">sess</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">get_session</span><span class="p">()</span>
<span class="n">class_names</span> <span class="o">=</span> <span class="n">read_classes</span><span class="p">(</span><span class="s">"path/coco_classes.txt"</span><span class="p">)</span>
<span class="n">anchors</span> <span class="o">=</span> <span class="n">read_anchors</span><span class="p">(</span><span class="s">"path/yolo_anchors.txt"</span><span class="p">)</span>
<span class="n">image_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mf">720.</span><span class="p">,</span> <span class="mf">1280.</span><span class="p">)</span>

<span class="n">yolo_outputs</span> <span class="o">=</span> <span class="n">yolo_head</span><span class="p">(</span><span class="n">yolo_model</span><span class="o">.</span><span class="n">output</span><span class="p">,</span> <span class="n">anchors</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_names</span><span class="p">))</span>
<span class="n">scores</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span> <span class="o">=</span> <span class="n">yolo_eval</span><span class="p">(</span><span class="n">yolo_outputs</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">)</span>
</code></pre></div></div>

<p>적용을 위해선 class_names와 anchors가 필요하다. 각 txt파일의 내용은 아래와 같다.<br />
<strong>coco_classes</strong>: person/bicycle/car/motorbike/aeroplane/bus/train … 등 80개 class<br />
<strong>anchor</strong>: 0.57273, 0.677385, 1.87446, 2.06253, 3.33843, 5.47434, 7.88282, 3.52778, 9.77052, 9.16828 = 5개의 anchor box 길이</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">image_file</span><span class="p">):</span>
    <span class="s">"""Runs the graph stored in "sess" to predict boxes for "image_file".
    Prints and plots the preditions.

    Returns:
    out_scores -- tensor of shape (None, ), scores of the predicted boxes
    out_boxes -- tensor of shape (None, 4), coordinates of the predicted boxes
    out_classes -- tensor of shape (None, ), class index of the predicted boxes
    """</span>

    <span class="c1"># Preprocess your image
</span>    <span class="n">image</span><span class="p">,</span> <span class="n">image_data</span> <span class="o">=</span> <span class="n">preprocess_image</span><span class="p">(</span><span class="n">image_file</span><span class="p">,</span> <span class="n">model_image_size</span><span class="o">=</span><span class="p">(</span><span class="mi">608</span><span class="p">,</span> <span class="mi">608</span><span class="p">))</span>

    <span class="c1"># Run the session
</span>    <span class="n">out_scores</span><span class="p">,</span> <span class="n">out_boxes</span><span class="p">,</span> <span class="n">out_classes</span> <span class="o">=</span>
    <span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="n">scores</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span><span class="p">],</span>
     <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="n">yolo_model</span><span class="o">.</span><span class="nb">input</span><span class="p">:</span> <span class="n">image_data</span><span class="p">,</span> <span class="n">K</span><span class="o">.</span><span class="n">learning_phase</span><span class="p">(</span> <span class="p">):</span> <span class="mi">0</span><span class="p">})</span>

    <span class="c1"># Print predictions info
</span>    <span class="k">print</span><span class="p">(</span><span class="s">'Found {} boxes for {}'</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_boxes</span><span class="p">),</span> <span class="n">image_file</span><span class="p">))</span>
    <span class="c1"># Generate colors for drawing bounding boxes.
</span>    <span class="n">colors</span> <span class="o">=</span> <span class="n">generate_colors</span><span class="p">(</span><span class="n">class_names</span><span class="p">)</span>
    <span class="c1"># Draw bounding boxes on the image file
</span>    <span class="n">draw_boxes</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">out_scores</span><span class="p">,</span> <span class="n">out_boxes</span><span class="p">,</span> <span class="n">out_classes</span><span class="p">,</span> <span class="n">class_names</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>
    <span class="c1"># Save the predicted bounding box on the image
</span>    <span class="c1"># image.save(os.path.join("out", image_file), quality=90)
</span>    <span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">'path/output01.jpg'</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out_scores</span><span class="p">,</span> <span class="n">out_boxes</span><span class="p">,</span> <span class="n">out_classes</span>

<span class="n">image_file</span> <span class="o">=</span> <span class="p">(</span><span class="s">"path/image01.jpg"</span><span class="p">)</span>
<span class="n">out_scores</span><span class="p">,</span> <span class="n">out_boxes</span><span class="p">,</span> <span class="n">out_classes</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">image_file</span><span class="p">)</span>
</code></pre></div></div>
<p>image_file에 이미지가 있는 path를 입력하고 predict함수를 이용하면 원하는 결과물을 얻을 수 있다.</p>

<p>위 함수들에 보충설명을 하자면, image, image_data라는 output을 반환하는 preprocess_image메서드는 원하는 size에 맞게 이미지를 조정해준다.</p>

<p>image는 이미지 파일 자체를 말하며, image_file은 그 이미지의 RGB 데이터를 저장한다.<br />
generate_colors를 통해 다양한 색깔을 미리 생성해두면,<br />
draw_boxes는 찾고자하는 object 둘레에 bounding box를 그려준다.<br />
quality 설정을 통해 저장하고자 하는 이미지의 화질을 조정할 수 있다.<br />
image.save를 통해 자동으로 output 이미지를 저장할 수 있다.</p>

<h3 id="check-the-result">Check the result</h3>
<p>Input:</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo12.jpg" width="50%" /></center>

<p>Output:</p>
<center><img src="/public/img/Deep_Learning/2018_07_21_YOLO/yolo13.jpg" width="50%" /></center>


  </article>
  <script type="text/javascript" async
          src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  
  <script data-ad-client="ca-pub-9951774327887666" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</div>

<amp-auto-ads type="adsense"
              data-ad-client="ca-pub-9951774327887666">
</amp-auto-ads>

<script data-ad-client="ca-pub-9951774327887666" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-9951774327887666"
     data-ad-slot="6606866336"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

<script data-ad-client="ca-pub-9951774327887666" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
    <li>
      <h3>
        <a href="/github/2020/05/27/github-usage-09-overall/">
          GitHub 사용법 - 09. Overall
          <small>27 May 2020</small>
        </a>
      </h3>
    </li>
    
    <li>
      <h3>
        <a href="/generative/model/2020/05/25/VAE/">
          Variational AutoEncoder 설명
          <small>25 May 2020</small>
        </a>
      </h3>
    </li>
    
    <li>
      <h3>
        <a href="/machine_learning/2020/05/01/AFM/">
          추천 시스템의 기본 - 06. AFM 논문 리뷰 및 Tensorflow 구현
          <small>01 May 2020</small>
        </a>
      </h3>
    </li>
    
  </ul>
</div>

<div id="disqus_thread"></div>
<script>

  /**
   *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
   *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

  var disqus_config = function () {
    this.page.url = 'http://localhost:4000/deep_learning/2018/07/21/YOLO/';
    this.page.identifier = 'http://localhost:4000/deep_learning/2018/07/21/YOLO/';
    //this.page.url = 'https://greeksharifa.github.com/';  // Replace PAGE_URL with your page's canonical URL variable
    //this.page.identifier = 'greeksharifa'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };

  (function () { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://greeksharifa.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by
  Disqus.</a></noscript>

  </div>
</div>

<label for="sidebar-checkbox" class="sidebar-toggle"></label>

<script>
  (function (document) {
    let toggle = document.querySelector('.sidebar-toggle');
    let sidebar = document.querySelector('#sidebar');
    let checkbox = document.querySelector('#sidebar-checkbox');

    document.addEventListener('click', function (e) {
      let target = e.target;

      if (target === toggle) {
        checkbox.checked = !checkbox.checked;
        e.preventDefault();
      } else if (checkbox.checked && !sidebar.contains(target)) {
        /* click outside the sidebar when sidebar is open */
        checkbox.checked = false;
      }
    }, false);
  })(document);
</script>

<script>
  (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    };
    i[r].l = 1 * new Date();
    a = s.createElement(o);
    m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m)
  })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

  ga('create', 'UA-00000000-1', 'auto');
  ga('send', 'pageview');
</script>


<!-- Naver Analytics -->	
<script type="text/javascript" src="//wcs.naver.net/wcslog.js"></script>
<script type="text/javascript">
  if(!wcs_add) var wcs_add = {};
    wcs_add["wa"] = "18cbce78e94161";
  wcs_do();
</script>

</body>

<script id="dsq-count-scr" src="//greeksharifa-github-io.disqus.com/count.js" async></script>

</html>
