---
layout: post
title: HGT(Heterogeneous Graph Transformer) 설명
author: Youyoung
categories: [Machine_Learning]
tags: [Machine_Learning, Recommendation System, Paper_Review]
---

이번 글에서는 `HGT`란 알고리즘에 대해 다뤄보겠다. 상세한 내용은 [논문 원본](https://arxiv.org/abs/2003.01332)을 참고하길 바라며, 본 글에서는 핵심적인 부분에 대해 요약 정리하도록 할 것이다. 저자의 코드는 [Github](https://github.com/acbull/pyHGT)에서 확인할 수 있다.  

(작성 중입니다.)  

---
# Heterogeneous Graph Transformer 설명  
## 1. Background  
기존의 많은 GNN이 Homogenous Graph에만 집중된 것에 반해, `HGT`는 여러 node type, edge type을 가진 Heterogenous Graph 데이터에 대해 적합한 알고리즘으로 제안되었다.  

Heterogenous Graph에 대한 접근법은 여러 가지가 있지만 대표적으로 `meta-path`를 이용한 방법과 `GNN`을 이용한 방법이 존재한다. 그런데 이러한 방법에는 몇 가지 결점이 존재한다.  

1) heterogenous graph의 각 type에 맞는 meta-path design을 하려면 구체적인 domain 지식이 필요하다.  
2) 다른 type의 node/edge가 같은 feature를 공유하거나, 혹은 아예 다른 feature를 갖는 경우 graph의 특징을 온전히 포착하기는 어렵다.  
3) 모든 graph의 동적 특성은 대부분 무시되고 있다.  

`HGT`의 목표는 다음과 같다.  
1) Network dynamics는 포착하면서 각 node/edge-type에 적합한 representation 학습  
2) customized meta-path를 특별히 설계하지 않음  
3) Web-scale graph에 적합하도록 highly scalable할 것  


---
## 2. Heterogenous Graph Mining  
Heterogenous Graph의 정의에 대해 살펴보자.  

$$ G = (\mathcal{V}, \mathcal{E}, \mathcal{A}, \mathcal{R}) $$  

각 집합은 node, edge, node type, edge type을 의미한다. 이 때 각 node $v \in \mathcal{V}$ 이고, 각 edge $e \in \mathcal{E}$ 이다. 그리고 다음과 같은 **type mapping 함수**가 존재한다.  

$$ \tau(v): V \rightarrow \mathcal{A}, \phi(e): E \rightarrow \mathcal{R} $$  

본격적인 구조 설명에 앞서 몇 가지 개념들에 대해 짚고 넘어간다.  

**Meta Relation**  
edge $e = (s, t)$ 가 존재할 때, 각 node $s, t$ 는 물론 edge $e$ 도 각자의 type을 가질 것이다. 이 때 이들 관계의 meta relation은 아래와 같이 표현할 수 있다.  

$$ <\tau(s), \phi(e), \tau(t)> $$  

이는 기존의 여러 meta-path 방법론에서도 설명된 개념이다. 3개의 요소 모두가 같아야만 같은 **관계**로 인식된다. 그런데 `HGT`는 여기에서 시간의 개념을 추가한다.  

**Dynamic Heterogenous Graph**  
앞서 예시로 들었던 edge $e=(s, t)$ 에 timestamp $T$ 를 할당해보자. 이는 node $s$ 가 $T$ 시점에 node $t$ 와 연결되었음을 의미한다. 이러한 관계가 처음으로 나타났다면 $s$ 에게 $T$ 시점이 할당된다. 물론 node $s$ 가 여러 번 연결된다면 복수의 timestamp를 갖게 될 것이다.  

이는 edge의 timestamp는 불변함을 의미한다. 당연하다. 예를 들어 어떤 논문이 WWW에 1994년에 등재되었다면, 이 때의 timestamp는 1994년인 것이다.  


---
## 3. Heterogenous Graph Transformer  
`HGT`의 목표는 source node로 부터 정보를 통합하여 target node $t$ 에 대한 **contextualized representation**을 얻는 것이다.  

### 3.1. Heterogenous Message Passing & Aggregation  
아래 그림은 전체적인 구조를 나타낸다. 총 $L$ 개의 Layer를 쌓는 방식으로 되어 있고, $H^l$ 은 $l$ 번째 HGT layer의 output이다.  

<center><img src="/public/img/Machine_Learning/2021-10-02-HGT/overview.PNG" width="90%"></center>  

(1), (2), (3)으로 구분되어 있듯이 이 과정은 크게 3가지로 구분되며, 효과적인 학습을 위해 3가지의 추가적인 장치가 배치된다. 추가적인 장치는 3.2에서 설명하도록 하겠다.  

> Step1: Heterogenous Mutual Attention  
> Step2: Heterogenous Message Passingg  
> Step3: Target-specific Aggregation  

일단 주어진 상황은 다음과 같다. 특정 target node $t$ 가 존재할 때, 2개의 source node $s_1, s_2$ 가 $e_1, e_2$ 라는 edge를 통해 target node와 관계를 맺고 있는 것이다. 이 때 node인 $t, s_1, s_2$ 의 경우 node feature 벡터를 갖는다. (node feature가 없으면 인위적으로 생성해야 한다.) 각 feature 벡터의 길이는 일단 $d$ 로 같다고 가정한다. 실제로는 최초의 Projection Layer에서 같은 길이로 통일되기 때문에 node type별로 다른 feature 길이를 가져도 무방하다. 어쨌든 지금은 $d$ 라는 길이로 통일되어 있다고 생각하자. 그렇다면 지금까지의 이야기로 2개의 meta relation이 존재하는 것이다.  

$$ <\tau(s_1), \phi(e_1), \tau(t)>, <\tau(s_2), \phi(e_2), \tau(t)> $$  

1번째 meta relation을 기준으로 이야기를 이어나가 보겠다. **Step1, 2**에서 해야할 일은 source node $s_1$ 이 $e_1$ 이라는 edge를 통해 target node $t$ 에 주는 영향력을 수식으로 나타내는 것이다. 이는 **Multi-head Attention**으로 구현되는데, 기존의 Vanilla Transformer를 사용하면 다른 source/target node, 여러 node type 모두 같은 feature distribution을 공유하게 되므로 이는 현재 상황에 적합한 세팅은 아니다.  

이러한 단점을 보완하기 위해 `Heterogenous Mutual Attention` 메커니즘이 도입된다. 이 메커니즘은 Multi-head Attention의 핵심 구조는 그대로 따르지만 몇 가지 차이점이 있다. 먼저 target node 벡터와 source node 벡터는 각각 Query 벡터, Key 벡터로 매핑되는데 이 때 각각의 node type에 따라 projection weight parameter가 다르다. 즉 만약 node type이 10개 있다고 하면, Query 벡터를 만들기 위한 weight matrix는 기본적으로 10 종류가 있는 것이다. (후에 여기에 attention head 수를 곱해야 한다.)  

여기가 끝이 아니다. edge type도 weight parameter를 구분한다. $W_{\phi(e)}^{ATT}$ 가 edge type에 dependent한 weight으로 Query 벡터와 Key 벡터의 유사도를 반영한다. 지금까지 설명한 것을 식으로 보자.  

$$ Attention(s, e, t) = Softmax_{\forall s \in N(t)} ( \Vert_{i \in [1, h]} head^i(s, e, t) ) $$  

$$ head^i(s, e, t) = (K^i(s) W_{\phi(e)}^{ATT} Q^i(t)^T)) \cdot \frac{\mu <\tau(s), \phi(e), \tau(t)>}{\sqrt{d}} $$  

2번째 식을 $h$ 개 만들고 이를 concat한 뒤 target node의 type별로 softmax 함수를 적용한 것이 최종 결과이다. 즉 2번째 식은 head 1개에 대한 결과물을 의미한다.  

식의 좌측이 앞서 설명한 부분으로 아래와 같이 좀 더 세부적으로 표현할 수 있다.  

$$ K^i(s) = K-Linear^i_{\tau(s)} (H^{l-1}[s]) $$  

$$ Q^i(t) = Q-Linear^i_{\tau(t)} (H^{l-1}[t]) $$  

위는 node type에 따라 weight를 구분하는 projection layer다. 이전 layer의 결과물을 받아 linear layer 하나를 통과시켜 Query/Key 벡터를 얻는다. 최종적으로 $h$ 개의 attention head를 얻기 때문에 Query/Key 벡터는 $\mathcal{R}^d \rightarrow \mathcal{\frac{d}{h}}$ 로 바뀐다. $W_{\phi(e)}^{ATT}$ 는 $\mathcal{R}^{\frac{d}{h}, \frac{d}{h}}$ 의 형상을 갖는다.  

지금까지의 과정을 종합해보면, 이 `Heterogenous Mutual Attention` 메커니즘이 여러 종류의 semantic relation을 충분히 포착할 수 있을 구조를 갖고 있다는 느낌이 들기 시작한다. 그 효용성에 대해서는 검증해보아야겠지만 일단 장치는 마련해둔 셈이다.  

2번째 식에서 우측을 보면 아래와 같은 수식이 있다.  

$$ \frac{\mu <\tau(s), \phi(e), \tau(t)>}{\sqrt{d}} $$  

논문에서는 이 식을 **prior tensor**라고 지칭하고 있다. 생각해보면, 모든 node/edge type이 같은 영향력을 지니지는 않을 것이다. 즉 데이터 전반을 볼 때 특정 node/edge type이 더 강한 영향력을 지닐 수도 있는 것이다. 이를 반영하기 위해 만들어진 tensor라고 생각하면 된다. 이 tensor를 통해 attention에 대해 adaptive scaling을 수행한다.  

코드를 잠시 보고 지나가겠다.  

```python
self.relation_pri = nn.Parameter(torch.ones(num_relations, self.n_heads))
```

논문 원본에는 모든 node/edge type에 따른 prior를 부여하였는데, 저자의 코드는 이를 좀 단순화하여 나타냈다. 만약 원본 코드를 사용할 계획이라면 상황에 따라 수정을 가할 수도 있을 것이다. 만약 수정을 원한다면 아래 부분에서 행렬 곱 연산을 수행한 후에 합 연산을 수행하는 형태로 바꿔줘야 한다.  

```python
res_att[idx] = (q_mat * k_mat).sum(dim=-1) * self.relation_pri[relation_type] / self.sqrt_dk
```

code에 대한 자세한 리뷰는 추후에 업로드하도록 하겠다.  


### 3.2. Heterogenous Message Passing  


### 3.3. Target-specific Aggregation  


---
## 4. ???  
to be updated  




